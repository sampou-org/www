
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=EUC-JP">
  <title>Haskell 98 Syntax</title>
 </head>

 <body bgcolor="#ffffff">
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="standard-prelude.html">back</a>
   | <a href="literate.html">next</a> | <a href="index98.html">contents</a>
   | <a href="prelude-index.html">function index</a> <br />
  </p>

  <hr />

  <p><a name="syntax"></a><a name="sect9"></a></p>
  <!--<h2>9<tt>&nbsp;&nbsp;</tt>Syntax Reference</h2>-->
  <h2>9<tt>&nbsp;&nbsp;</tt>構文リファレンス</h2>

  <p> <a name="sect9.1"></a></p>
  <!--<h3>9.1<tt>&nbsp;&nbsp;</tt>Notational Conventions</h3>-->
  <h3>9.1<tt>&nbsp;&nbsp;</tt>表記規約</h3>

  <!--<p> These notational conventions are used for presenting syntax:</p>-->
  <p>以下の表記規約は、構文を表現するのに用いる。</p>

  <p>
  <table>
   <tr>
    <td align="center"> <i>[pattern]</i></td>
    <!--<td> optional</td>-->
    <td> オプション(あってもなくてもよい)</td>
   </tr>
   <tr>
    <td align="center"><i>{pattern}</i></td>
    <!--<td> zero or more repetitions</td>-->
    <td>0回以上のくりかえし</td>
   </tr>
   <tr>
    <td align="center"><i>(pattern)</i></td>
    <!--<td>groupinng</td>-->
    <td>グループ化</td>
   </tr>
   <tr>
    <td align="center"><i>pat</i><sub><i>1</i></sub><i> |
     pat</i><sub><i>2</i></sub></td>
    <!-- <td>choice</td> -->
    <td>選択</td>
   </tr>
   <tr>
    <td align="center"><i>pat</i><sub><i>&lt;pat'&gt;</i></sub></td>
    <!--<td> difference---elements generated by <i>pat</i></td>-->
    <td> 差異 --- <i>pat</i> によって生成される要素のうち</td>
   </tr>
   <tr>
    <td align="center"></td>
    <!--<td> except those generated by <i>pat'</i></td>-->
    <td> <i>pat'</i> によって生成される要素を除いたもの</td>
   </tr>
   <tr>
    <td align="center"><tt>fibonacci</tt></td>
    <!--<td> terminal syntax in typewriter font</td>-->
    <td> タイプライタフォントで表現された終端構文</td>
   </tr>
  </table>
  </p>
  <!--
  <p> BNF-like syntax is used throughout, with productions having the form:
   </p>
  -->
  <p>
   全体を通して BNF風の構文を使う。生成ルールは以下の形式である。
  </p>

  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> nonterm</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> alt<sub>1</sub> | alt<sub>2</sub> | ... |
     alt<sub>n</sub></td>
   </tr>
  </table>
  </p>
  <!--
  <p> There are some families of nonterminals indexed by precedence levels
   (written as a superscript). Similarly, the nonterminals <i>op</i>,
   <i>varop</i>, and <i>conop</i> may have a double index: a letter
   <i>l</i>, <i>r</i>, or <i>n</i> for left-, right- or nonassociativity
   and a precedence level. A precedence-level variable <i>i</i> ranges from
   0 to 9; an associativity variable <i>a</i> varies over <i>{l, r, n}</i>.
   Thus, for example</p>
  -->
  <p>
   (上付文字で書かれた)優先順位のインデックスがついた非終端記号のグルー
   プがいくつかある。同様に非終端記号 <i>op</i>、<i>varop</i> および
   <i>conop</i> には二つのインデックスがつくことがある。文字
   <i>l</i>, <i>r</i> または <i>n</i> はそれぞれ、左結合性優先度、
   右結合性優先度、非結合性優先度をあらわしています。優先度変数
   <i>i</i> の範囲は、0 から 9 で、結合性変数 <i>a</i> のとりうる範囲は
   <i>{l, r, n}</i> である。したがって、たとえば、
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> aexp</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> <tt>(</tt> exp<sup>i+1</sup> qop<sup>(a,i)</sup> <tt>)
     </tt></td>
   </tr>
  </table>
  </p>
  <!--
  <p>actually stands for 30 productions, with 10 substitutions for <i>i
   </i>and 3 for <i>a</i>.</p>
  -->
  <p>
   は 30 種類の生成結果、つまり、<i>i</i> について 10 通り、<i>a</i> に
   ついて 3 通りである。
  </p>
  <!--
  <p> In both the lexical and the context-free syntax, there are some
   ambiguities that are to be resolved by making grammatical phrases as
   long as possible, proceeding from left to right (in shift-reduce
   parsing, resolving shift/reduce conflicts by shifting). In the lexical
   syntax, this is the "maximal munch" rule. In the context-free syntax,
   this means that conditionals, let-expressions, and lambda abstractions
   extend to the right as far as possible.</p>
  -->
  <p>
   字句構文および文脈自由構文の両方において、いくつかの曖昧性が存在し、
   これらは、文法句を左から右へできるだけ伸ばすことで解決する(シフト還元
   構文解析では、シフト/還元の衝突はシフトすることで解決する)。字句構文
   において、これは「大喰らい」法である。文脈自由構文では、これは、条件
   文、let-式、λ抽象は、可能な限り右へ拡張されるということを意味する。
  </p>

  <p> <a name="sect9.2"></a></p>
  <!--<h3>9.2<tt>&nbsp;&nbsp;</tt>Lexical Syntax</h3>-->
  <h3>9.2<tt>&nbsp;&nbsp;</tt>字句構文</h3>

  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> program</td>
    <td> <tt>-&gt;</tt></td>
    <td> {lexeme | whitespace }</td>
   </tr>
   <tr>
    <td> lexeme</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvarid | qconid | qvarsym | qconsym</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> literal | special | reservedop | reservedid</td>
   </tr>
   <tr>
    <td> literal</td>
    <td> <tt>-&gt;</tt></td>
    <td> integer | float | char | string</td>
   </tr>
   <tr>
    <td> special</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>(</tt> | <tt>)</tt> | <tt>,</tt> | <tt>;</tt> | <tt>[</tt> |
     <tt>]</tt> | `| <tt>{</tt> | <tt>} </tt></td>
   </tr>
   <tr>
    <td> whitespace</td>
    <td> <tt>-&gt;</tt></td>
    <td> whitestuff {whitestuff}</td>
   </tr>
   <tr>
    <td> whitestuff</td>
    <td> <tt>-&gt;</tt></td>
    <td> whitechar | comment | ncomment</td>
   </tr>
   <tr>
    <td> whitechar</td>
    <td> <tt>-&gt;</tt></td>
    <td> newline | vertab | space | tab | uniWhite</td>
   </tr>
   <tr>
    <td> newline</td>
    <td> <tt>-&gt;</tt></td>
    <td> return linefeed | return | linefeed | formfeed</td>
   </tr>
   <tr>
    <td> return</td>
    <td> <tt>-&gt;</tt></td>
    <td> a carriage return</td>
   </tr>
   <tr>
    <td> linefeed</td>
    <td> <tt>-&gt;</tt></td>
    <td> a line feed</td>
   </tr>
   <tr>
    <td> vertab</td>
    <td> <tt>-&gt;</tt></td>
    <td> a vertical tab</td>
   </tr>
   <tr>
    <td> formfeed</td>
    <td> <tt>-&gt;</tt></td>
    <td> a form feed</td>
   </tr>
   <tr>
    <td> space</td>
    <td> <tt>-&gt;</tt></td>
    <td> a space</td>
   </tr>
   <tr>
    <td> tab</td>
    <td> <tt>-&gt;</tt></td>
    <td> a horizontal tab</td>
   </tr>
   <tr>
    <td> uniWhite</td>
    <td> <tt>-&gt;</tt></td>
    <td> any Unicode character defined as whitespace</td>
   </tr>
   <tr>
    <td> comment</td>
    <td> <tt>-&gt;</tt></td>
    <td> dashes [ any<sub>&lt;symbol&gt;</sub> {any}] newline</td>
   </tr>
   <tr>
    <td> dashes</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>--</tt> {<tt>-</tt>}</td>
   </tr>
   <tr>
    <td> opencom</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>{- </tt></td>
   </tr>
   <tr>
    <td> closecom</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>-} </tt></td>
   </tr>
   <tr>
    <td> ncomment</td>
    <td> <tt>-&gt;</tt></td>
    <td> opencom ANYseq {ncomment ANYseq}closecom</td>
   </tr>
   <tr>
    <td> ANYseq</td>
    <td> <tt>-&gt;</tt></td>
    <td> {ANY}<sub>&lt;{ANY}( opencom | closecom ) {ANY}&gt;</sub></td>
   </tr>
   <tr>
    <td> ANY</td>
    <td> <tt>-&gt;</tt></td>
    <td> graphic | whitechar</td>
   </tr>
   <tr>
    <td> any</td>
    <td> <tt>-&gt;</tt></td>
    <td> graphic | space | tab</td>
   </tr>
   <tr>
    <td> graphic</td>
    <td> <tt>-&gt;</tt></td>
    <td> small | large | symbol | digit | special | <tt>:</tt> | <tt>"</tt>
     | <tt>' </tt></td>
   </tr>
   <tr>
    <td> small</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascSmall | uniSmall | <tt>_ </tt></td>
   </tr>
   <tr>
    <td> ascSmall</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>a</tt> | <tt>b</tt> | ... | <tt>z </tt></td>
   </tr>
   <tr>
    <td> uniSmall</td>
    <td> <tt>-&gt;</tt></td>
    <td> any Unicode lowercase letter</td>
   </tr>
   <tr>
    <td> large</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascLarge | uniLarge</td>
   </tr>
   <tr>
    <td> ascLarge</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>A</tt> | <tt>B</tt> | ... | <tt>Z </tt></td>
   </tr>
   <tr>
    <td> uniLarge</td>
    <td> <tt>-&gt;</tt></td>
    <td> any uppercase or titlecase Unicode letter</td>
   </tr>
   <tr>
    <td> symbol</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascSymbol | uniSymbol<sub>&lt;special | <tt>_</tt> | <tt>:</tt> |
     <tt>"</tt> | <tt>'</tt>&gt;</sub></td>
   </tr>
   <tr>
    <td> ascSymbol</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>!</tt> | <tt>#</tt> | <tt>$</tt> | <tt>%</tt> | <tt>&amp;</tt>
     | <tt>*</tt> | <tt>+</tt> | <tt>.</tt> | <tt>/</tt> | <tt>&lt;</tt> |
     <tt>=</tt> | <tt>&gt;</tt> | <tt>?</tt> | @</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>\</tt> | <tt>^</tt> | <tt>|</tt> | <tt>-</tt> | <tt>~ </tt></td>
   </tr>
   <tr>
    <td> uniSymbol</td>
    <td> <tt>-&gt;</tt></td>
    <td> any Unicode symbol or punctuation</td>
   </tr>
   <tr>
    <td> digit</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascDigit | uniDigit</td>
   </tr>
   <tr>
    <td> ascDigit</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>0</tt> | <tt>1</tt> | ... | <tt>9 </tt></td>
   </tr>
   <tr>
    <td> uniDigit</td>
    <td> <tt>-&gt;</tt></td>
    <td> any Unicode decimal digit</td>
   </tr>
   <tr>
    <td> octit</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>0</tt> | <tt>1</tt> | ... | <tt>7 </tt></td>
   </tr>
   <tr>
    <td> hexit</td>
    <td> <tt>-&gt;</tt></td>
    <td> digit | <tt>A</tt> | ... | <tt>F</tt> | <tt>a</tt> | ... | <tt>f
     </tt></td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> varid</td>
    <td> <tt>-&gt;</tt></td>
    <td> (small {small | large | digit | <tt>'</tt>
     })<sub>&lt;reservedid&gt;</sub></td>
   </tr>
   <tr>
    <td> conid</td>
    <td> <tt>-&gt;</tt></td>
    <td> large {small | large | digit | <tt>'</tt> }</td>
   </tr>
   <tr>
    <td> reservedid</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>case</tt> | <tt>class</tt> | <tt>data</tt> | <tt>default</tt>
     | <tt>deriving</tt> | <tt>do</tt> | <tt>else </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>if</tt> | <tt>import</tt> | <tt>in</tt> | <tt>infix</tt> |
     <tt>infixl</tt> | <tt>infixr</tt> | <tt>instance </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>let</tt> | <tt>module</tt> | <tt>newtype</tt> | <tt>of</tt> |
     <tt>then</tt> | <tt>type</tt> | <tt>where</tt> | <tt>_ </tt></td>
   </tr>
   <tr>
    <td> varsym</td>
    <td> <tt>-&gt;</tt></td>
    <td> ( symbol {symbol | <tt>:</tt>})<sub>&lt;reservedop |
     dashes&gt;</sub></td>
   </tr>
   <tr>
    <td> consym</td>
    <td> <tt>-&gt;</tt></td>
    <td> (<tt>:</tt> {symbol | <tt>:</tt>})<sub>&lt;reservedop&gt;</sub></td>
   </tr>
   <tr>
    <td> reservedop</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>..</tt> | <tt>:</tt> | <tt>::</tt> | <tt>=</tt> | <tt>\</tt> |
     <tt>|</tt> | <tt>&lt;-</tt> | <tt>-&gt;</tt> | <tt>@</tt> | <tt>~</tt>
     | <tt>=&gt; </tt></td>
   </tr>
   <tr>
    <td> varid</td>
    <td></td>
    <td></td>
    <td> (variables)</td>
   </tr>
   <tr>
    <td> conid</td>
    <td></td>
    <td></td>
    <td> (constructors)</td>
   </tr>
   <tr>
    <td> tyvar</td>
    <td> <tt>-&gt;</tt></td>
    <td> varid</td>
    <td> (type variables)</td>
   </tr>
   <tr>
    <td> tycon</td>
    <td> <tt>-&gt;</tt></td>
    <td> conid</td>
    <td> (type constructors)</td>
   </tr>
   <tr>
    <td> tycls</td>
    <td> <tt>-&gt;</tt></td>
    <td> conid</td>
    <td> (type classes)</td>
   </tr>
   <tr>
    <td> modid</td>
    <td> <tt>-&gt;</tt></td>
    <td> conid</td>
    <td> (modules)</td>
   </tr>
   <tr>
    <td> qvarid</td>
    <td> <tt>-&gt;</tt></td>
    <td> [ modid <tt>.</tt> ] varid</td>
   </tr>
   <tr>
    <td> qconid</td>
    <td> <tt>-&gt;</tt></td>
    <td> [ modid <tt>.</tt> ] conid</td>
   </tr>
   <tr>
    <td> qtycon</td>
    <td> <tt>-&gt;</tt></td>
    <td> [ modid <tt>.</tt> ] tycon</td>
   </tr>
   <tr>
    <td> qtycls</td>
    <td> <tt>-&gt;</tt></td>
    <td> [ modid <tt>.</tt> ] tycls</td>
   </tr>
   <tr>
    <td> qvarsym</td>
    <td> <tt>-&gt;</tt></td>
    <td> [ modid <tt>.</tt> ] varsym</td>
   </tr>
   <tr>
    <td> qconsym</td>
    <td> <tt>-&gt;</tt></td>
    <td> [ modid <tt>.</tt> ] consym</td>
   </tr>
   <tr>
    <td> decimal</td>
    <td> <tt>-&gt;</tt></td>
    <td> digit{digit}</td>
   </tr>
   <tr>
    <td> octal</td>
    <td> <tt>-&gt;</tt></td>
    <td> octit{octit}</td>
   </tr>
   <tr>
    <td> hexadecimal</td>
    <td> <tt>-&gt;</tt></td>
    <td> hexit{hexit}</td>
   </tr>
   <tr>
    <td> integer</td>
    <td> <tt>-&gt;</tt></td>
    <td> decimal</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>0o</tt> octal | <tt>0O</tt> octal</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>0x</tt> hexadecimal | <tt>0X</tt> hexadecimal</td>
   </tr>
   <tr>
    <td> float</td>
    <td> <tt>-&gt;</tt></td>
    <td> decimal <tt>.</tt> decimal [exponent]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> decimal exponent</td>
   </tr>
   <tr>
    <td> exponent</td>
    <td> <tt>-&gt;</tt></td>
    <td> (<tt>e</tt> | <tt>E</tt>) [<tt>+</tt> | <tt>-</tt>] decimal</td>
   </tr>
   <tr>
    <td> char</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>'</tt> (graphic<sub>&lt;<tt>'</tt> | <tt>\</tt>&gt;</sub> |
     space | escape<sub>&lt;<tt>\&amp;</tt>&gt;</sub>) <tt>' </tt></td>
   </tr>
   <tr>
    <td> string</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>"</tt> {graphic<sub>&lt;<tt>"</tt> | <tt>\</tt>&gt;</sub> |
     space | escape | gap}<tt>" </tt></td>
   </tr>
   <tr>
    <td> escape</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>\</tt> ( charesc | ascii | decimal | <tt>o</tt> octal |
     <tt>x</tt> hexadecimal )</td>
   </tr>
   <tr>
    <td> charesc</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>a</tt> | <tt>b</tt> | <tt>f</tt> | <tt>n</tt> | <tt>r</tt> |
     <tt>t</tt> | <tt>v</tt> | <tt>\</tt> | <tt>"</tt> | <tt>'</tt> |
     <tt>&amp; </tt></td>
   </tr>
   <tr>
    <td> ascii</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>^</tt>cntrl | <tt>NUL</tt> | <tt>SOH</tt> | <tt>STX</tt> |
     <tt>ETX</tt> | <tt>EOT</tt> | <tt>ENQ</tt> | <tt>ACK</tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>BEL</tt> | <tt>BS</tt> | <tt>HT</tt> | <tt>LF</tt> |
     <tt>VT</tt> | <tt>FF</tt> | <tt>CR</tt> | <tt>SO</tt> | <tt>SI</tt> |
     <tt>DLE</tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>DC1</tt> | <tt>DC2</tt> | <tt>DC3</tt> | <tt>DC4</tt> |
     <tt>NAK</tt> | <tt>SYN</tt> | <tt>ETB</tt> | <tt>CAN</tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>EM</tt> | <tt>SUB</tt> | <tt>ESC</tt> | <tt>FS</tt> |
     <tt>GS</tt> | <tt>RS</tt> | <tt>US</tt> | <tt>SP</tt> | <tt>DEL </tt></td>
   </tr>
   <tr>
    <td> cntrl</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascLarge | @ | <tt>[</tt> | <tt>\</tt> | <tt>]</tt> | <tt>^</tt> |
     <tt>_ </tt></td>
   </tr>
   <tr>
    <td> gap</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>\</tt> whitechar {whitechar}<tt>\ </tt></td>
   </tr>
  </table>
  </p>

  <p><a name="layout"></a></p>
  <p><a name="sect9.3"></a></p>
  <!--<h3>9.3<tt>&nbsp;&nbsp;</tt>Layout</h3>-->
  <h3>9.3<tt>&nbsp;&nbsp;</tt>レイアウト</h3>
  <!--
  <p> Section <a href="lexemes.html#lexemes-layout">2.7</a> gives an
   informal discussion of the layout rule. This section defines it more
   precisely.</p>
  -->
  <p>
   <a href="lexemes.html#lexemes-layout">2.7</a> 節ではレイアウト規則に
   ついて非形式的に議論した。この節では、それをもう少し正確に定義する。
  </p>
  <!--
  <p> The meaning of a Haskell program may depend on its <i>layout</i>. The
   effect of layout on its meaning can be completely described by adding
   braces and semicolons in places determined by the layout. The meaning of
   this augmented program is now layout insensitive.</p>
  -->
  <p>
   Haskell のプログラムの意味はその<em>レイアウト</em>に依存することがあ
   る。意味に影響を与えるレイアウトは、そのレイアウトによって決定される
   場所にブレースとセミコロンを付け加えることによって、完全に記述するこ
   とができる。こうして補足されたプログラムは今度は、レイアウトには影響
   されない。
  </p>
  <!--
  <p> The effect of layout is specified in this section by describing how
   to add braces and semicolons to a laid-out program. The specification
   takes the form of a function <i>L</i> that performs the translation. The
   input to <i>L</i> is:</p>
  -->
  <p>
   レイアウトの影響は、この節では、レイアウトを用いているプログラムに、
   どのようにして、ブレースとセミコロンを追加するかを記述することによっ
   て指定する。この仕様は、変換を行う関数 <i>L</i> の形をとる。<i>L</i>
   への入力は
  </p>
  <p>
  <ul>
   <li>
    <!--<p> A stream of lexemes as specified by the lexical syntax in the
    Haskell report, with the following additional tokens:
    </p>-->
    <p>
     この Haskell レポートの字句構文で指定されたような字句の並びで、以下
     のような追加トークンがついているもの。
    </p>
    <p>
    <ul>
     <!--<li>If a <tt>let</tt>, <tt>where</tt>, <tt>do</tt>, or <tt>of</tt>
      keyword is not followed by the lexeme <tt>{</tt>, the token
      <i>{n}</i> is inserted after the keyword, where <i>n</i> is the
      indentation of the next lexeme if there is one, or <i>0</i> if the
      end of file has been reached.</li>-->
     <li>
      キーワード <tt>let</tt>、<tt>where</tt>、<tt>do</tt> あるいは
      <tt>of</tt> のあとに字句 <tt>{</tt> が続かない場合、トークン
      <i>{n}</i> をキーワードの後に挿入する。ここで <i>n</i> は、もし
      次の字句があればそれのインデント、または、ファイルの終端に到達して
      いれば <i>0</i> である。
     </li>
     <!--<li>If the first lexeme of a module is not <tt>{</tt> or
      <tt>module</tt>, then it is preceded by <i>{n}</i> where <i>n</i> is
      the indentation of the lexeme.</li>-->
     <li>
      モジュールの最初の字句が <tt>{</tt> あるいは <tt>module</tt> では
      ないとき、その字句の前に <i>{n}</i> を置く。ここで、<i>n</i> はそ
      の字句のインデントである。
     </li>
     <!--<li>Where the start of a lexeme is preceded only by white space on the
      same line, this lexeme is preceded by <i>&lt;n&gt;</i> where <i>n
      </i> is the indentation of the lexeme, provided that it is not, as a
      consequence of the first two rules, preceded by <i>{n}</i>. (NB: a
      string literal may span multiple lines -- Section <a
      href="lexemes.html#lexemes-char">2.6</a>. So in the fragment
      <tt><br />
      <br />
      &nbsp;&nbsp;f&nbsp;=&nbsp;("Hello&nbsp;\<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\Bill",&nbsp;"Jake")<br />
      <br />
      </tt>There is no <i>&lt;n&gt;</i> inserted before the <tt>\Bill</tt>,
      because it is not the beginning of a complete lexeme; nor before the
      <tt>,</tt>, because it is not preceded only by white space.)</li>-->
      <li>
       同一行で、字句の開始の前には白空白しかないとき、この字句の前に
       <i>&lt;n&gt;</i> を置く。ここで <i>n</i> はこの字句のインデントで、
       前の二つの規則の結果、その前には <i>{n}</i> が置かれていない。
       (注意: 文字列リテラルは複数行にまたがることがある --
       <a href="lexemes.html#lexemes-char">2.6</a> 節。したがって、
       <tt><br />
       <br />
       &nbsp;&nbsp;f&nbsp;=&nbsp;("Hello&nbsp;\<br />
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\Bill",&nbsp;"Jake")<br />
      <br />
      </tt>
      では、<tt>\Bill</tt> の前に <i>&lt;n&gt;</i> は挿入されることはな
      い。なぜなら、完全な字句の開始場所ではないからだ。また、<tt>,</tt>
      の前にも <i>&lt;n&gt;</i> は置かれることはない。なぜなら、その前に
      白空白以外のものがあるからだ。)
      </li>
    </ul>
    </p>
   </li>
   <li>
    <!--
    <p>A stack of "layout contexts", in which each element is either:</p>
    -->
    <p>
     「レイアウト文脈」のスタックのそれぞれの要素は以下のどれかである。
    </p>
    <p>
    <!--
    <ul>
     <li>Zero, indicating that the enclosing context is explicit (i.e. the
      programmer supplied the opening brace. If the innermost context is 0,
      then no layout tokens will be inserted until either the enclosing
      context ends or a new context is pushed.</li>
     <li>A positive integer, which is the indentation column of the
      enclosing layout context.</li>
    </ul>
    -->
    <ul>
     <li>
      ゼロ、これは文脈を明示的に囲うこと(たとえばプログラマが開ブレース
      を用意した場合)を示す。もし最も内側の文脈が 0 なら、囲まれた文脈が
      終了するか、新しい文脈がプッシュされるまで、レイアウトトークンは挿
      入されない。
     </li> 
     <li>
      正の整数、これは囲まれたレイアウト文脈のインデントカラム数
     </li>
    </ul>
    </p>
   </li>
  </ul>
  <p>
  </p>
  <!--
  <p> The "indentation" of a lexeme is the column number of the first
   character of that lexeme; the indentation of a line is the indentation
   of its leftmost lexeme. To determine the column number, assume a
   fixed-width font with the following conventions:</p>
  -->
  <p>
   字句の「インデント」は字句の最初の文字のカラム数である。ひとつの行の
   インデントとは最も左にある字句のインデントを表す。このカラム数を決定
   するために以下のような規約をもつ固定幅のフォントを仮定する。
  </p>
  <p>
  <!--
  <ul>
   <li>The characters <i>newline</i>, <i>return</i>, <i>linefeed</i>, and
    <i>formfeed</i>, all start a new line.</li>
   <li>The first column is designated column 1, not 0.</li>
   <li>Tab stops are 8 characters apart.</li>
   <li>A tab character causes the insertion of enough spaces to align the
    current position with the next tab stop.</li>
  </ul>
  -->
  <ul>
   <li><em>改行</em>、<em>リターン</em>、<em>ラインフィード</em>および
    <em>フォームフィード</em>文字はすべて新しい行を開始する</li>
   <li>最初のコラムは 0 ではなく 1 である</li>
   <li>タブストップは8文字文ずつの位置にある</li>
   <li>タブ文字は現在位置から次のタブストップ位置までそろえるのに必要な
	だけの空白を挿入する。</li>
  </ul>
  </p>
  <!--
  <p>For the purposes of the layout rule, Unicode characters in a source
   program are considered to be of the same, fixed, width as an ASCII
   character. However, to avoid visual confusion, programmers should avoid
   writing programs in which the meaning of implicit layout depends on the
   width of non-space characters.</p>
  -->
  <p>
   レイアウトルールにあわせるために、ソースプログラム中の Unicode 文字は
   ASCII 文字と同じ幅の固定幅であると看倣す。しかしながら、見た目との混
   乱を避けるためプログラマは暗黙のレイアウトの意味が非空白文字の幅に依
   存するようなプログラムを書かないようにすべきである。
  </p>

  <!--<p> The application</p>-->
  <p>適用</p>
  <p> L tokens []</p>
  <!--
  <p> delivers a layout-insensitive translation of <i>tokens</i>, where
   <i>tokens </i>is the result of lexically analysing a module and adding
   column-number indicators to it as described above. The definition of
   <i>L</i> is as follows, where we use "<i>:</i>" as a stream construction
   operator, and "<i>[]</i>" for the empty stream.</p>
  -->
  <p>
   は、<i>tokens</i> のレイアウトに関知しない変換をもたらす。ここで、
   <i>tokens</i> はモジュールの字句解析および上述のようにカラム数表示子
   を追加した結果である。<i>L</i> の定義は以下のとおり、ここでは
   「<i>:</i>」をストリーム構築操作子として使い、「<i>[]</i>」は空のスト
   リームである。
  </p>
  <p>
  <div align="center">
   <p>
   <table>
    <tr>
     <td> L (&lt;n&gt;:ts) (m:ms)</td>
     <td align="center"> =</td>
     <td> <tt>;</tt> : (L ts (m:ms))</td>
     <td>if m = n</td>
    </tr>
    <tr>
     <td></td>
     <td align="center"> =</td>
     <td> <tt>}</tt> : (L (&lt;n&gt;:ts) ms)</td>
     <td> if n &lt; m</td>
    </tr>
    <tr>
     <td>L (&lt;n&gt;:ts) ms</td>
     <td align="center"> =</td>
     <td> L ts ms</td>
    </tr>
    <tr></tr>
    <tr>
     <td>L ({n}:ts) (m:ms)</td>
     <td align="center"> =</td>
     <td> <tt>{</tt> : (L ts (n:m:ms))</td>
     <td> if n &gt; m (Note 1)</td>
    </tr>
    <tr>
     <td>L ({n}:ts) []</td>
     <td align="center"> =</td>
     <td> <tt>{</tt> : (L ts [n])</td>
     <td> if n &gt; 0 (Note 1)</td>
    </tr>
    <tr>
     <td>L ({n}:ts) ms</td>
     <td align="center"> =</td>
     <td> <tt>{</tt> : <tt>}</tt> : (L (&lt;n&gt;:ts) ms)</td>
     <td> (Note 2)</td>
    </tr>
    <tr></tr>
    <tr>
     <td>L (<tt>}</tt>:ts) (0:ms)</td>
     <td align="center"> =</td>
     <td> <tt>}</tt> : (L ts ms)</td>
     <td> (Note 3)</td>
    </tr>
    <tr>
     <td>L (<tt>}</tt>:ts) ms</td>
     <td align="center"> =</td>
     <td> parse-error</td>
     <td> (Note 3)</td>
    </tr>
    <tr></tr>
    <tr>
     <td>L (<tt>{</tt>:ts) ms</td>
     <td align="center"> =</td>
     <td> <tt>{</tt> : (L ts (0:ms))</td>
     <td> (Note 4)</td>
    </tr>
    <tr></tr>
    <tr>
     <td>L (t:ts) (m:ms)</td>
     <td align="center"> =</td>
     <td> <tt>}</tt> : (L (t:ts) ms)</td>
     <td> if m /= 0 and parse-error(t)</td>
    </tr>
    <tr>
     <td></td>
     <td align="center"></td>
     <td></td>
     <td> (Note 5)</td>
    </tr>
    <tr>
     <td>L (t:ts) ms</td>
     <td align="center"> =</td>
     <td> t : (L ts ms)</td>
    </tr>
    <tr></tr>
    <tr>
     <td>L [] []</td>
     <td align="center"> =</td>
     <td> []</td>
    </tr>
    <tr>
     <td>L [] (m:ms)</td>
     <td align="center"> =</td>
     <td> <tt>}</tt> : L [] ms</td>
     <td> if m /=0 (Note 6)</td>
    </tr>
   </table>
   </p>
  </div>
  </p>
  <p>
  <dl>
   <dt> Note 1.</dt>
  </dl>
  </p>
  <!--  
  <p> A nested context must be further indented than the enclosing context
   (<i>n&gt;m</i>). If not, <i>L</i> fails, and the compiler should
   indicate a layout error. An example is: <tt><br />
   <br />
   &nbsp;&nbsp;f&nbsp;x&nbsp;=&nbsp;let<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;y&nbsp;=&nbsp;let<br />
   &nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;z&nbsp;=&nbsp;z<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;p<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;h<br />
   <br />
   </tt>Here, the definition of <tt>p</tt> is indented less than the
   indentation of the enclosing context, which is set in this case by the
   definition of <tt>h</tt>.</p>
  -->
  <p>
   入れ子になった文脈は、囲まれた文脈 (n>m) よりも深くインデ ントされて
   いなければならない。さもなければ、L は失敗し、また、 コンパイラはレイ
   アウトエラーを表示しなければならない。たとえば、
   <tt><br />
   <br />
   &nbsp;&nbsp;f&nbsp;x&nbsp;=&nbsp;let<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;y&nbsp;=&nbsp;let<br />
   &nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;z&nbsp;=&nbsp;z<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;p<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;h<br />
   <br />
   </tt>
   ここで、<tt>p</tt> の定義は囲まれた文脈のインデントよりも浅いインデン
   トである。この場合、<tt>h</tt> の定義によって設定される。
  </p>
  <p>
  <dl>
   <dt> Note 2.</dt>
  </dl>
  </p>
  <!--
  <p> If the first token after a <tt>where</tt> (say) is not indented more
   than the enclosing layout context, then the block must be empty, so
   empty braces are inserted. The {n} token is replaced by &lt;n&gt;, to
   mimic the situation if the empty braces had been explicit.</p>
  -->
  <p>
   <tt>where</tt> の後の最初のトークンが、たとえば、囲まれた文脈よりもイ
   ンデントされているのでなければ、そのブロックは空でなければならない。
   だから、空のブレースが挿入される。トークン {n} は &lt;n&gt; に置き換
   えられ、空のブレースが明示的になっていた場合の状況を模倣する。
  </p>
  <p>
  <dl>
   <dt> Note 3.</dt>
  </dl>
  </p>
  <!--
  <p> By matching against 0 for the current layout context, we ensure that
   an explicit close brace can only match an explicit open brace. A parse
   error results if an explicit close brace matches an implicit open brace.</p>
  -->
  <p>
   現在のレイアウト文脈について 0 に対して照合することで、明示的な閉ブ
   レースが明示的な開ブレースにのみ対応することを確かめる。もし、明示的
   な閉ブレースが暗黙の開ブレースに対応している場合には構文解析エラーと
   なる。
  </p>
  <p>
  <dl>
   <dt> Note 4.</dt>
  </dl>
  </p>
  <!--
  <p> This clause means that all brace pairs are treated as explicit layout
   contexts, including labelled construction and update (Section <a
   href="exps.html#field-ops">3.15</a>). This is a difference between this
   formulation and Haskell 1.4.</p>
  -->
  <p>
   これは、すべてのブレースの対は明示的なレイアウト文脈として扱われる こ
   とを意味し、ラベル付のデータ構築および更新
   (<a href="exps.html#field-ops">3.15</a> 節)を含む。ここにこの形式化と
   Haskell 1.4 での 違いがある。
  </p>
  <p>
  <dl>
   <dt> Note 5.</dt>
  </dl>
  </p>
  <!--
  <p> The side condition <i>parse-error(t)</i> is to be interpreted as
   follows: if the tokens generated so far by <i>L</i> together with the
   next token <i>t</i> represent an invalid prefix of the Haskell grammar,
   and the tokens generated so far by <i>L</i> followed by the token
   "<tt>}</tt>" represent a valid prefix of the Haskell grammar, then
   <i>parse-error(t)</i> is true.</p>
  -->
  <p>
   副次的な条件 <i>parse-error(t)</i> は次のように解釈される。もし、次の
   トークンが <i>t</i> であるような <i>L</i> によっ て生成されたトークン
   が Haskell の文法の不正な接頭辞を表わしている場合、および、
   「<tt>}</tt>」トークンが続く <i>L</i> によって生成さたトー クンの
   Haskell 文法の正しい接頭辞である場合、<i>parse-error(t)</i> は真とな
   る。
  </p>
  <!--
  <p> The test m /= 0 checks that an implicitly-added closing brace would
   match an implicit open brace.</p>
  -->
  <p>
   m /= 0 のチェックは、暗黙に追加された閉ブレースが、暗黙の開ブレースに
   対応することをたしかめる。
  </p>
  <p>
  <dl>
   <dt> Note 6.</dt>
  </dl>
  </p>
  <!--
  <p> At the end of the input, any pending close-braces are inserted. It is
   an error at this point to be within a non-layout context (i.e. <i>m =
   0</i>).</p>
  -->
  <p>
   入力の終端において、保留された閉ブレースがすべて挿入される。この時点
   でレイアウト文脈のなかにある(すなわち、<i>m = 0</i> である)とエラーとなる。
  </p>
  <!-- 
  <p> If none of the rules given above matches, then the algorithm fails.
   It can fail for instance when the end of the input is reached, and a
   non-layout context is active, since the close brace is missing. Some
   error conditions are not detected by the algorithm, although they could
   be: for example <tt>let&nbsp;}</tt>.</p>
  -->
  <p>
   上のような照合になんの規則もなければ、アルゴリズムは失敗する。入力の
   終端に達すると直ちに失敗し、非レイアウト文脈がアクティブになる。それ
   は閉ブレースが欠けているからである。おこり得るにもかかわらず、このア
   ルゴリズムでは検出できないエラー状態がある。たとえば、 let } である。
  </p>
  <!--
  <p> Note 1 implements the feature that layout processing can be stopped
   prematurely by a parse error. For example <tt><br />
   <br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;e;&nbsp;y&nbsp;=&nbsp;x&nbsp;in&nbsp;e'<br />
   <br />
   </tt>is valid, because it translates to <tt><br />
   <br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;{&nbsp;x&nbsp;=&nbsp;e;&nbsp;y&nbsp;=&nbsp;x&nbsp;}&nbsp;in&nbsp;e'<br />
   <br />
   </tt>The close brace is inserted due to the parse error rule above. The
   parse-error rule is hard to implement in its full generality, because
   doing so involves fixities. For example, the expression <tt><br />
   <br />
   &nbsp;&nbsp;do&nbsp;a&nbsp;==&nbsp;b&nbsp;==&nbsp;c<br />
   <br />
   </tt>has a single unambiguous (albeit probably type-incorrect) parse,
   namely <tt><br />
   <br />
   &nbsp;&nbsp;(do&nbsp;{&nbsp;a&nbsp;==&nbsp;b&nbsp;})&nbsp;==&nbsp;c<br />
   <br />
   </tt>because <tt>(==)</tt> is non-associative. Programmers are therefore
   advised to avoid writing code that requires the parser to insert a
   closing brace in such situations.</p>
  -->
  <p>
   Note 1 は、レイアウト処理はパーズエラーにより相互に停止するという性質
   を実現したものである。たとえば、
   <tt><br />
   <br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;e;&nbsp;y&nbsp;=&nbsp;x&nbsp;in&nbsp;e'<br />
   <br />
   </tt>
   は正しい構文である。なぜなら、
   <tt><br />
   <br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;{&nbsp;x&nbsp;=&nbsp;e;&nbsp;y&nbsp;=&nbsp;x&nbsp;}&nbsp;in&nbsp;e'<br />
   <br />
   </tt>
   に変換されるからである。閉ブレースは上のパーズエラールールにより挿入
   される。このパーズエラールールは、これがもつ一般性を実装するのは困難
   である。それは、演算子位置の問題を含んでいるからである。たとえば、次
   の式
   <tt><br />
   <br />
   &nbsp;&nbsp;do&nbsp;a&nbsp;==&nbsp;b&nbsp;==&nbsp;c<br />
   <br />
   </tt>は、(型としては正しくないかもしれないが)一つの明白な構文解析結果
   をもつ。すなわち、
   <tt><br />
   <br />
   &nbsp;&nbsp;(do&nbsp;{&nbsp;a&nbsp;==&nbsp;b&nbsp;})&nbsp;==&nbsp;c<br />
   <br />
   </tt>
   である。なぜなら、<tt>(==)</tt> には結合性がないからである。ゆえに、
   プログラマは、パーザがこのような場合に閉ブレースを挿入しなければなら
   ないようなコードを書かないようにするべきなのである。
  </p>

  <p> <a name="literate"></a></p>
  <p> <a name="sect9.4"></a></p>

  <!--<h3>9.4<tt>&nbsp;&nbsp;</tt>Literate comments</h3>-->
  <h3>9.4<tt>&nbsp;&nbsp;</tt>文芸的コメント</h3>
  <!--
  <p> The "literate comment" convention, first developed by Richard Bird
   and Philip Wadler for Orwell, and inspired in turn by Donald Knuth's
   "literate programming", is an alternative style for encoding Haskell
   source code. The literate style encourages comments by making them the
   default. A line in which "<tt>&gt;</tt>" is the first character is
   treated as part of the program; all other lines are comment.</p>
  -->
  <p>
   「文芸的コメント」の規約は、最初 Richard Bird と Philip Wadler が、
   Donald Knuth の「文芸的プログラミング」に触発されて、Orwell 用に開発
   したのであるが、Haskell のソースコードを書くときのもうひとつのスタイ
   ルでもある。文芸的スタイルは、デフォルトでコメントである。行頭が、「>」
   である行がプログラムの一部としてあつかわれる。それ以外のすべての行は
   コメントである。
  </p>
  <!--
  <p> The program text is recovered by taking only those lines beginning
   with "<tt>&gt;</tt>", and replacing the leading "<tt>&gt;</tt>" with a
   space. Layout and comments apply exactly as described in Chapter <a
   href="syntax-iso.html#syntax">9</a> in the resulting text.</p>
  -->
  <p>
   プログラム本文は「&gt;」で始まる行のみから再構成され、各行の先頭の
   「&gt;」は空白に置き換えられる。レイアウトとコメントはその結果のテキ
   ストに対して <a href="syntax-iso.html#syntax">9</a> 章で解説されたよ
   うに厳密に適用される。
  </p>
  <!--
  <p> To capture some cases where one omits an "<tt>&gt;</tt>" by mistake,
   it is an error for a program line to appear adjacent to a non-blank
   comment line, where a line is taken as blank if it consists only of
   whitespace.</p>
  -->
  <p>
   あやまって、「&gt;」を忘れたことを捕捉するために、プログラムラインが空
   ではないコメント行に隣接した場合、エラーになる。このとき、空白だけか
   ら構成される行は空白行と解釈される。
  </p>
  <!--
  <p> By convention, the style of comment is indicated by the file
   extension, with "<tt>.hs</tt>" indicating a usual Haskell file and
   "<tt>.lhs</tt>" indicating a literate Haskell file. Using this style, a
   simple factorial program would be: <tt><br />
   <br />
   &nbsp;&nbsp;&nbsp;This&nbsp;literate&nbsp;program&nbsp;prompts&nbsp;the&nbsp;user&nbsp;for&nbsp;a&nbsp;number<br />
   &nbsp;&nbsp;&nbsp;and&nbsp;prints&nbsp;the&nbsp;factorial&nbsp;of&nbsp;that&nbsp;number:<br />
   <br />
   &gt;&nbsp;main&nbsp;::&nbsp;IO&nbsp;()<br />
   <br />
   &gt;&nbsp;main&nbsp;=&nbsp;do&nbsp;putStr&nbsp;"Enter&nbsp;a&nbsp;number:&nbsp;"<br />
   &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;&lt;-&nbsp;readLine<br />
   &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;"n!=&nbsp;"<br />
   &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;(fact&nbsp;(read&nbsp;l))<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;This&nbsp;is&nbsp;the&nbsp;factorial&nbsp;function.<br />
   <br />
   &gt;&nbsp;fact&nbsp;::&nbsp;Integer&nbsp;-&gt;&nbsp;Integer<br />
   &gt;&nbsp;fact&nbsp;0&nbsp;=&nbsp;1<br />
   &gt;&nbsp;fact&nbsp;n&nbsp;=&nbsp;n&nbsp;*&nbsp;fact&nbsp;(n-1)<br />
   <br />
   </tt></p>
  -->
  <p>
   規約として、コメントのスタイルはそのファイルの拡張子によって表示され
   る。拡張子が「.hs」であるときこれは通常の Haskell のファイルであるこ
   とを示している。「.lhs」は文芸的 Haskell のファイルであることを示して
   いる。このスタイルを使うと、単純な階乗のプログラムは次のようになる。
   <tt><br />
   <br />
   &nbsp;&nbsp;&nbsp;This&nbsp;literate&nbsp;program&nbsp;prompts&nbsp;the&nbsp;user&nbsp;for&nbsp;a&nbsp;number<br />
   &nbsp;&nbsp;&nbsp;and&nbsp;prints&nbsp;the&nbsp;factorial&nbsp;of&nbsp;that&nbsp;number:<br />
   <br />
   &gt;&nbsp;main&nbsp;::&nbsp;IO&nbsp;()<br />
   <br />
   &gt;&nbsp;main&nbsp;=&nbsp;do&nbsp;putStr&nbsp;"Enter&nbsp;a&nbsp;number:&nbsp;"<br />
   &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;&lt;-&nbsp;readLine<br />
   &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;"n!=&nbsp;"<br />
   &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;(fact&nbsp;(read&nbsp;l))<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;This&nbsp;is&nbsp;the&nbsp;factorial&nbsp;function.<br />
   <br />
   &gt;&nbsp;fact&nbsp;::&nbsp;Integer&nbsp;-&gt;&nbsp;Integer<br />
   &gt;&nbsp;fact&nbsp;0&nbsp;=&nbsp;1<br />
   &gt;&nbsp;fact&nbsp;n&nbsp;=&nbsp;n&nbsp;*&nbsp;fact&nbsp;(n-1)<br />
   <br />
   </tt>
  </p>
  <!--
  <p> An alternative style of literate programming is particularly suitable
   for use with the LaTeX text processing system. In this convention, only
   those parts of the literate program that are entirely enclosed between
   <tt>\begin{code}</tt>...<tt>\end{code}</tt> delimiters are treated as
   program text; all other lines are comment. More precisely:</p>
  -->
  <p>
   文芸的プログラミングには特に LaTeX のテキスト処理に適したもうひとつの
   スタイルがある。この規約では、
   <tt>\begin{code}</tt>...<tt>\end{code}</tt> 区切り子で囲まれている文
   芸的プログラムの部分だけが、プログラムテキストとして扱われる。それ以
   外の行はすべてコメントである。より正確には、 
  </p>
  <!--
  <p>
  <ul>
   <li>Program code begins on the first line following a line that begins
    <tt>\begin{code}</tt>.</li>

   <li>Program code ends just before a subsequent line that begins
    <tt>\end{code}</tt> (ignoring string literals, of course).</li>
  </ul>
  </p>
  -->
  <p>
   <ul>
    <li>プログラムのコードは <tt>\begin{code}</tt> ではじまる行の次の行
	から始まる。</li>
    <li>プログラムのコードは、<tt>\end{code}</tt>ではじまる行(もちろん、
	 文字列リテラルは無視する)の直前で終る。</li>
   </ul>
  </p>
  <!--
  <p>It is not necessary to insert additional blank lines before or after
   these delimiters, though it may be stylistically desirable. For example,
   <tt><br />
   <br />
   \documentstyle{article}<br />
   <br />
   \begin{document}<br />
   <br />
   \section{Introduction}<br />
   <br />
   This&nbsp;is&nbsp;a&nbsp;trivial&nbsp;program&nbsp;that&nbsp;prints&nbsp;the&nbsp;first&nbsp;20&nbsp;factorials.<br />
   <br />
   \begin{code}<br />
   main&nbsp;::&nbsp;IO&nbsp;()<br />
   main&nbsp;=&nbsp;&nbsp;print&nbsp;[&nbsp;(n,&nbsp;product&nbsp;[1..n])&nbsp;|&nbsp;n&nbsp;&lt;-&nbsp;[1..20]]<br />
   \end{code}<br />
   <br />
   \end{document}<br />
   <br />
   </tt>This style uses the same file extension. It is not advisable to mix
   these two styles in the same file.</p>
  -->
  <p>
   スタイルとしてそうすることが望ましいが、この区切り子の前後には余分な
   空白行を挿入する必要はない。例をあげると、
   <tt><br />
   <br />
   \documentstyle{article}<br />
   <br />
   \begin{document}<br />
   <br />
   \section{Introduction}<br />
   <br />
   This&nbsp;is&nbsp;a&nbsp;trivial&nbsp;program&nbsp;that&nbsp;prints&nbsp;the&nbsp;first&nbsp;20&nbsp;factorials.<br />
   <br />
   \begin{code}<br />
   main&nbsp;::&nbsp;IO&nbsp;()<br />
   main&nbsp;=&nbsp;&nbsp;print&nbsp;[&nbsp;(n,&nbsp;product&nbsp;[1..n])&nbsp;|&nbsp;n&nbsp;&lt;-&nbsp;[1..20]]<br />
   \end{code}<br />
   <br />
   \end{document}<br />
   <br />
   </tt>
  </p>

  <p><a name="bnf"></a></p>
  <p><a name="sect9.5"></a></p>
  <!--<h3>9.5<tt>&nbsp;&nbsp;</tt>Context-Free Syntax</h3>-->
  <h3>9.5<tt>&nbsp;&nbsp;</tt>文脈自由構文</h3>

  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> module</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>module</tt> modid [exports] <tt>where</tt> body</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> body</td>
   </tr>
   <tr>
    <td> body</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>{</tt> impdecls <tt>;</tt> topdecls <tt>} </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>{</tt> impdecls <tt>} </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>{</tt> topdecls <tt>} </tt></td>
   </tr>
   <tr>
    <td> impdecls</td>
    <td> <tt>-&gt;</tt></td>
    <td> impdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> impdecl<sub>n</sub></td>
    <td> (n&gt;=1)</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> exports</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>(</tt> export<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     export<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> export</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvar</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> qtycon [<tt>(..)</tt> | <tt>(</tt> cname<sub>1</sub> <tt>,</tt>
     ... <tt>,</tt> cname<sub>n</sub> <tt>)</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> qtycls [<tt>(..)</tt> | <tt>(</tt> qvar<sub>1</sub> <tt>,</tt> ...
     <tt>,</tt> qvar<sub>n</sub> <tt>)</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>module</tt> modid</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr></tr>
   <tr>
    <td> impdecl</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>import</tt> [<tt>qualified</tt>] modid [<tt>as</tt> modid]
     [impspec]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td></td>
    <td> (empty declaration)</td>
   </tr>
   <tr>
    <td> impspec</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>(</tt> import<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     import<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>hiding</tt> <tt>(</tt> import<sub>1</sub> <tt>,</tt> ...
     <tt>,</tt> import<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> import</td>
    <td> <tt>-&gt;</tt></td>
    <td> var</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> tycon [ <tt>(..)</tt> | <tt>(</tt> cname<sub>1</sub> <tt>,</tt>
     ... <tt>,</tt> cname<sub>n</sub> <tt>)</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> tycls [<tt>(..)</tt> | <tt>(</tt> var<sub>1</sub> <tt>,</tt> ...
     <tt>,</tt> var<sub>n</sub> <tt>)</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> cname</td>
    <td> <tt>-&gt;</tt></td>
    <td> var | con</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> topdecls</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> topdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt>
     topdecl<sub>n</sub></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> topdecl</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>type</tt> simpletype <tt>=</tt> type</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>data</tt> [context <tt>=&gt;</tt>] simpletype <tt>=</tt>
     constrs [deriving]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>newtype</tt> [context <tt>=&gt;</tt>] simpletype <tt>=</tt>
     newconstr [deriving]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>class</tt> [scontext <tt>=&gt;</tt>] tycls tyvar
     [<tt>where</tt> cdecls]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>instance</tt> [scontext <tt>=&gt;</tt>] qtycls inst
     [<tt>where</tt> idecls]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>default</tt> <tt>(</tt>type<sub>1</sub> <tt>,</tt> ...
     <tt>,</tt> type<sub>n</sub><tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> decl</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr></tr>
   <tr></tr>
   <tr></tr>
   <tr>
    <td> decls</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>{</tt> decl<sub>1</sub> <tt>;</tt> ... <tt>;</tt>
     decl<sub>n</sub> <tt>}</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> decl</td>
    <td> <tt>-&gt;</tt></td>
    <td> gendecl</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> (funlhs | pat<sup>0</sup>) rhs</td>
   </tr>
   <tr>
    <td> cdecls</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>{</tt> cdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt>
     cdecl<sub>n</sub> <tt>}</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> cdecl</td>
    <td> <tt>-&gt;</tt></td>
    <td> gendecl</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> (funlhs | var) rhs</td>
   </tr>
   <tr>
    <td> idecls</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>{</tt> idecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt>
     idecl<sub>n</sub> <tt>}</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> idecl</td>
    <td> <tt>-&gt;</tt></td>
    <td> (funlhs | var) rhs</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td></td>
    <td> (empty)</td>
   </tr>
   <tr>
    <td> gendecl</td>
    <td> <tt>-&gt;</tt></td>
    <td> vars <tt>::</tt> [context <tt>=&gt;</tt>] type</td>
    <td> (type signature)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> fixity [integer] ops</td>
    <td> (fixity declaration)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td></td>
    <td> (empty declaration)</td>
   </tr>
   <tr>
    <td> ops</td>
    <td> <tt>-&gt;</tt></td>
    <td> op<sub>1</sub> <tt>,</tt> ... <tt>,</tt> op<sub>n</sub></td>
    <td> (n&gt;=1)</td>
   </tr>
   <tr>
    <td> vars</td>
    <td> <tt>-&gt;</tt></td>
    <td> var<sub>1</sub> <tt>,</tt> ...<tt>,</tt> var<sub>n</sub></td>
    <td> (n&gt;=1)</td>
   </tr>
   <tr>
    <td> fixity</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>infixl</tt> | <tt>infixr</tt> | <tt>infix </tt></td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr></tr>
   <tr></tr>
   <tr></tr>
   <tr>
    <td> type</td>
    <td> <tt>-&gt;</tt></td>
    <td> btype [<tt>-&gt;</tt> type]</td>
    <td> (function type)</td>
   </tr>
   <tr>
    <td> btype</td>
    <td> <tt>-&gt;</tt></td>
    <td> [btype] atype</td>
    <td> (type application)</td>
   </tr>
   <tr>
    <td> atype</td>
    <td> <tt>-&gt;</tt></td>
    <td> gtycon</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> tyvar</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> type<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     type<sub>k</sub> <tt>)</tt></td>
    <td> (tuple type, k&gt;=2)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>[</tt> type <tt>]</tt></td>
    <td> (list type)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> type <tt>)</tt></td>
    <td> (parenthesized constructor)</td>
   </tr>
   <tr>
    <td> gtycon</td>
    <td> <tt>-&gt;</tt></td>
    <td> qtycon</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>()</tt></td>
    <td> (unit type)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>[]</tt></td>
    <td> (list constructor)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(-&gt;)</tt></td>
    <td> (function constructor)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(,</tt>{<tt>,</tt>}<tt>)</tt></td>
    <td> (tupling constructors)</td>
   </tr>
   <tr>
    <td> context</td>
    <td> <tt>-&gt;</tt></td>
    <td> class</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> class<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     class<sub>n</sub> <tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> class</td>
    <td> <tt>-&gt;</tt></td>
    <td> qtycls tyvar</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> qtycls <tt>(</tt> tyvar atype<sub>1</sub> ... atype<sub>n</sub>
     <tt>)</tt></td>
    <td> (n&gt;=1)</td>
   </tr>
   <tr>
    <td> scontext</td>
    <td> <tt>-&gt;</tt></td>
    <td> simpleclass</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> simpleclass<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     simpleclass<sub>n</sub> <tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> simpleclass</td>
    <td> <tt>-&gt;</tt></td>
    <td> qtycls tyvar</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> simpletype</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> tycon tyvar<sub>1</sub> ... tyvar<sub>k</sub></td>
    <td> (k&gt;=0)</td>
   </tr>
   <tr>
    <td> constrs</td>
    <td> <tt>-&gt;</tt></td>
    <td> constr<sub>1</sub> <tt>|</tt> ... <tt>|</tt> constr<sub>n</sub></td>
    <td> (n&gt;=1)</td>
   </tr>
   <tr>
    <td> constr</td>
    <td> <tt>-&gt;</tt></td>
    <td> con [<tt>!</tt>] atype<sub>1</sub> ... [<tt>!</tt>]
     atype<sub>k</sub></td>
    <td> (arity con = k, k&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> (btype | <tt>!</tt> atype) conop (btype | <tt>!</tt> atype)</td>
    <td> (infix conop)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> con <tt>{</tt> fielddecl<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     fielddecl<sub>n</sub> <tt>}</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> newconstr</td>
    <td> <tt>-&gt;</tt></td>
    <td> con atype</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> con <tt>{</tt> var <tt>::</tt> type <tt>}</tt></td>
   </tr>
   <tr>
    <td> fielddecl</td>
    <td> <tt>-&gt;</tt></td>
    <td> vars <tt>::</tt> (type | <tt>!</tt> atype)</td>
   </tr>
   <tr>
    <td> deriving</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>deriving</tt> (dclass | <tt>(</tt>dclass<sub>1</sub><tt>,</tt>
     ... <tt>,</tt> dclass<sub>n</sub><tt>)</tt>)</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> dclass</td>
    <td> <tt>-&gt;</tt></td>
    <td> qtycls</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> inst</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> gtycon</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> gtycon tyvar<sub>1</sub> ... tyvar<sub>k</sub>
     <tt>)</tt></td>
    <td> (k&gt;=0, tyvars distinct)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> tyvar<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     tyvar<sub>k</sub> <tt>)</tt></td>
    <td> (k&gt;=2, tyvars distinct)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>[</tt> tyvar <tt>] </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> tyvar<sub>1</sub> <tt>-&gt;</tt> tyvar<sub>2</sub>
     <tt>)</tt></td>
    <td> tyvar<sub>1</sub> and tyvar<sub>2</sub> distinct</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr></tr>
   <tr></tr>
   <tr>
    <td> funlhs</td>
    <td> <tt>-&gt;</tt></td>
    <td> var apat {apat }</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> pat<sup>i+1</sup> varop<sup>(a,i)</sup> pat<sup>i+1</sup></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> lpat<sup>i</sup> varop<sup>(l,i)</sup> pat<sup>i+1</sup></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> pat<sup>i+1</sup> varop<sup>(r,i)</sup> rpat<sup>i</sup></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> funlhs <tt>)</tt> apat {apat }</td>
   </tr>
   <tr>
    <td> rhs</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>=</tt> exp [<tt>where</tt> decls]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> gdrhs [<tt>where</tt> decls]</td>
   </tr>
   <tr>
    <td> gdrhs</td>
    <td> <tt>-&gt;</tt></td>
    <td> gd <tt>=</tt> exp [gdrhs]</td>
   </tr>
   <tr>
    <td> gd</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>|</tt> exp<sup>0</sup></td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> exp</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> exp<sup>0</sup> <tt>::</tt> [context <tt>=&gt;</tt>]
     type</td>
    <td> (expression type signature)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> exp<sup>0</sup></td>
   </tr>
   <tr>
    <td> exp<sup>i</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> exp<sup>i+1</sup> [qop<sup>(n,i)</sup> exp<sup>i+1</sup>]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> lexp<sup>i</sup></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> rexp<sup>i</sup></td>
   </tr>
   <tr>
    <td> lexp<sup>i</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> (lexp<sup>i</sup> | exp<sup>i+1</sup>) qop<sup>(l,i)</sup>
     exp<sup>i+1</sup></td>
   </tr>
   <tr>
    <td> lexp<sup>6</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>-</tt> exp<sup>7</sup></td>
   </tr>
   <tr>
    <td> rexp<sup>i</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> exp<sup>i+1</sup> qop<sup>(r,i)</sup> (rexp<sup>i</sup> |
     exp<sup>i+1</sup>)</td>
   </tr>
   <tr>
    <td> exp<sup>10</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>\</tt> apat<sub>1</sub> ... apat<sub>n</sub> <tt>-&gt;</tt>
     exp</td>
    <td> (lambda abstraction, n&gt;=1)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>let</tt> decls <tt>in</tt> exp</td>
    <td> (let expression)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>if</tt> exp <tt>then</tt> exp <tt>else</tt> exp</td>
    <td> (conditional)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>case</tt> exp <tt>of</tt> <tt>{</tt> alts <tt>}</tt></td>
    <td> (case expression)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>do</tt> <tt>{</tt> stmts <tt>}</tt></td>
    <td> (do expression)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> fexp</td>
   </tr>
   <tr>
    <td> fexp</td>
    <td> <tt>-&gt;</tt></td>
    <td> [fexp] aexp</td>
    <td> (function application)</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> aexp</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> qvar</td>
    <td> (variable)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> gcon</td>
    <td> (general constructor)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> literal</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> exp <tt>)</tt></td>
    <td> (parenthesized expression)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> exp<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     exp<sub>k</sub> <tt>)</tt></td>
    <td> (tuple, k&gt;=2)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>[</tt> exp<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     exp<sub>k</sub> <tt>]</tt></td>
    <td> (list, k&gt;=1)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>[</tt> exp<sub>1</sub> [<tt>,</tt> exp<sub>2</sub>]
     <tt>..</tt> [exp<sub>3</sub>] <tt>]</tt></td>
    <td> (arithmetic sequence)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>[</tt> exp <tt>|</tt> qual<sub>1</sub> <tt>,</tt> ...
     <tt>,</tt> qual<sub>n</sub> <tt>]</tt></td>
    <td> (list comprehension, n&gt;=1)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> exp<sup>i+1</sup> qop<sup>(a,i)</sup> <tt>)</tt></td>
    <td> (left section)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> lexp<sup>i</sup> qop<sup>(l,i)</sup> <tt>)</tt></td>
    <td> (left section)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> qop<sup>(a,i)</sup><sub>&lt;<tt>-</tt>&gt;</sub>
     exp<sup>i+1</sup> <tt>)</tt></td>
    <td> (right section)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> qop<sup>(r,i)</sup><sub>&lt;<tt>-</tt>&gt;</sub>
     rexp<sup>i</sup> <tt>)</tt></td>
    <td> (right section)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> qcon <tt>{</tt> fbind<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     fbind<sub>n</sub> <tt>}</tt></td>
    <td> (labeled construction, n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> aexp<sub>&lt;qcon&gt;</sub> <tt>{</tt> fbind<sub>1</sub>
     <tt>,</tt> ... <tt>,</tt> fbind<sub>n</sub> <tt>}</tt></td>
    <td> (labeled update, n &gt;= 1)</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr></tr>
   <tr></tr>
   <tr></tr>
   <tr>
    <td> qual</td>
    <td> <tt>-&gt;</tt></td>
    <td> pat <tt>&lt;-</tt> exp</td>
    <td> (generator)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>let</tt> decls</td>
    <td> (local declaration)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> exp</td>
    <td> (guard)</td>
   </tr>
   <tr>
    <td> alts</td>
    <td> <tt>-&gt;</tt></td>
    <td> alt<sub>1</sub> <tt>;</tt> ... <tt>;</tt> alt<sub>n</sub></td>
    <td> (n&gt;=1)</td>
   </tr>
   <tr>
    <td> alt</td>
    <td> <tt>-&gt;</tt></td>
    <td> pat <tt>-&gt;</tt> exp [<tt>where</tt> decls]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> pat gdpat [<tt>where</tt> decls]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td></td>
    <td> (empty alternative)</td>
   </tr>
   <tr>
    <td> gdpat</td>
    <td> <tt>-&gt;</tt></td>
    <td> gd <tt>-&gt;</tt> exp [ gdpat ]</td>
   </tr>
   <tr>
    <td> stmts</td>
    <td> <tt>-&gt;</tt></td>
    <td> stmt<sub>1</sub> ... stmt<sub>n</sub> exp [<tt>;</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> stmt</td>
    <td> <tt>-&gt;</tt></td>
    <td> exp <tt>; </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> pat <tt>&lt;-</tt> exp <tt>; </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>let</tt> decls <tt>; </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>;</tt></td>
    <td> (empty statement)</td>
   </tr>
   <tr>
    <td> fbind</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvar <tt>=</tt> exp</td>
   </tr>
   <tr>
    <td></td>
    <td></td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> pat</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> var <tt>+</tt> integer</td>
    <td> (successor pattern)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> pat<sup>0</sup></td>
   </tr>
   <tr>
    <td> pat<sup>i</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> pat<sup>i+1</sup> [qconop<sup>(n,i)</sup> pat<sup>i+1</sup>]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> lpat<sup>i</sup></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> rpat<sup>i</sup></td>
   </tr>
   <tr>
    <td> lpat<sup>i</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> (lpat<sup>i</sup> | pat<sup>i+1</sup>) qconop<sup>(l,i)</sup>
     pat<sup>i+1</sup></td>
   </tr>
   <tr>
    <td> lpat<sup>6</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>-</tt> (integer | float)</td>
    <td> (negative literal)</td>
   </tr>
   <tr>
    <td> rpat<sup>i</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> pat<sup>i+1</sup> qconop<sup>(r,i)</sup> (rpat<sup>i</sup> |
     pat<sup>i+1</sup>)</td>
   </tr>
   <tr>
    <td> pat<sup>10</sup></td>
    <td> <tt>-&gt;</tt></td>
    <td> apat</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> gcon apat<sub>1</sub> ... apat<sub>k</sub></td>
    <td> (arity gcon = k, k&gt;=1)</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> apat</td>
    <td> <tt>-&gt;</tt></td>
    <td> var [<tt>@</tt> apat]</td>
    <td> (as pattern)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> gcon</td>
    <td> (arity gcon = 0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> qcon <tt>{</tt> fpat<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     fpat<sub>k</sub> <tt>}</tt></td>
    <td> (labeled pattern, k&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> literal</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>_</tt></td>
    <td> (wildcard)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> pat <tt>)</tt></td>
    <td> (parenthesized pattern)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(</tt> pat<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     pat<sub>k</sub> <tt>)</tt></td>
    <td> (tuple pattern, k&gt;=2)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>[</tt> pat<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     pat<sub>k</sub> <tt>]</tt></td>
    <td> (list pattern, k&gt;=1)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>~</tt> apat</td>
    <td> (irrefutable pattern)</td>
   </tr>
   <tr>
    <td> fpat</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvar <tt>=</tt> pat</td>
   </tr>
  </table>
  </p>
  <p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> gcon</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>() </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>[] </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>(,</tt>{<tt>,</tt>}<tt>) </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> qcon</td>
   </tr>
   <tr>
    <td> var</td>
    <td> <tt>-&gt;</tt></td>
    <td> varid | <tt>(</tt> varsym <tt>)</tt></td>
    <td> (variable)</td>
   </tr>
   <tr>
    <td> qvar</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvarid | <tt>(</tt> qvarsym <tt>)</tt></td>
    <td> (qualified variable)</td>
   </tr>
   <tr>
    <td> con</td>
    <td> <tt>-&gt;</tt></td>
    <td> conid | <tt>(</tt> consym <tt>)</tt></td>
    <td> (constructor)</td>
   </tr>
   <tr>
    <td> qcon</td>
    <td> <tt>-&gt;</tt></td>
    <td> qconid | <tt>(</tt> gconsym <tt>)</tt></td>
    <td> (qualified constructor)</td>
   </tr>
   <tr>
    <td> varop</td>
    <td> <tt>-&gt;</tt></td>
    <td> varsym | `varid `</td>
    <td> (variable operator)</td>
   </tr>
   <tr>
    <td> qvarop</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvarsym | `qvarid `</td>
    <td> (qualified variable operator)</td>
   </tr>
   <tr>
    <td> conop</td>
    <td> <tt>-&gt;</tt></td>
    <td> consym | `conid `</td>
    <td> (constructor operator)</td>
   </tr>
   <tr>
    <td> qconop</td>
    <td> <tt>-&gt;</tt></td>
    <td> gconsym | `qconid `</td>
    <td> (qualified constructor operator)</td>
   </tr>
   <tr>
    <td> op</td>
    <td> <tt>-&gt;</tt></td>
    <td> varop | conop</td>
    <td> (operator)</td>
   </tr>
   <tr>
    <td> qop</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvarop | qconop</td>
    <td> (qualified operator)</td>
   </tr>
   <tr>
    <td> gconsym</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>:</tt> | qconsym</td>
   </tr>
  </table>
  </p>
  <hr />
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="standard-prelude.html">back</a>
   | <a href="literate.html">next</a> | <a href="index98.html">contents</a>
   | <a href="prelude-index.html">function index</a> <br />
   <font size="2">December 2002</font></p>
 </body>
</html>
