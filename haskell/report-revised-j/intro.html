
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=EUC-JP">
  <!--<title>The Haskell 98 Report: Introduction</title>-->
  <title>Haskell 98 レポート: イントロダクション</title>
 </head>

 <body bgcolor="#ffffff">
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="preface-jfp.html">back</a> | <a
   href="lexemes.html">next</a> | <a href="index98.html">contents</a> | <a
   href="prelude-index.html">function index</a> <br />
  </p>
  <hr />

  <p><a name="introduction"></a><a name="sect1"></a></p>
  <!--<h2>1<tt>&nbsp;&nbsp;</tt>Introduction</h2>-->
  <h2>1<tt>&nbsp;&nbsp;</tt>イントロダクション</h2>

  <!--
  <p> Haskell is a general purpose, purely functional programming language
   incorporating many recent innovations in programming language design.
   Haskell provides higher-order functions, non-strict semantics, static
   polymorphic typing, user-defined algebraic datatypes, pattern-matching,
   list comprehensions, a module system, a monadic I/O system, and a rich
   set of primitive datatypes, including lists, arrays, arbitrary and fixed
   precision integers, and floating-point numbers. Haskell is both the
   culmination and solidification of many years of research on non-strict
   functional languages.</p>
  -->
  <p>Haskell は汎用の純粋関数型プログラミング言語で、プログラミング言語
   設計の分野での最近の革新の多くが取入れられている。Haskell が提供する
   のは、高階関数、非正格の意味論、静的多相型付け、利用者定義の代数的デー
   タ型、パターン照合、リストの内包表記、モジュールシステム、モナド I/O
   システムである。また、さらに次のような豊かなプリミティブデータ型が用
   意されている。リスト、配列、任意倍長整数、固定倍長整数、浮動小数点数。
   Haskell は遅延評価型関数型言語に関する長年の研究を凝縮したものであり、
   また、その頂点にたつものである。 
  </p>
  <!--
  <p> This report defines the syntax for Haskell programs and an informal
   abstract semantics for the meaning of such programs. We leave as
   implementation dependent the ways in which Haskell programs are to be
   manipulated, interpreted, compiled, etc. This includes such issues as
   the nature of programming environments and the error messages returned
   for undefined programs (i.e. programs that formally evaluate to _|_).<a
   name="programs"></a></p>
  -->
  <p>このレポートは Haskell で書かれたプログラムの構文とそのプログラムの
   意味に対する非形式的抽象意味論を定義するものである。Haskell のプログ
   ラムがどのように処理され、解釈され、コンパイルされるかなどといった部
   分に依存する実装の問題には触れない。ここではとりあげない問題にはプロ
   グラミング環境の性質や未定義(すなわち、形式的には _|_ と評価される)プ
   ログラムに関するエラーメッセージも含まれる。
  </p>

  <p><a name="sect1.1"></a></p>
  <!--<h3>1.1<tt>&nbsp;&nbsp;</tt>Program Structure</h3>-->
  <h3>1.1<tt>&nbsp;&nbsp;</tt>プログラムの構造</h3>
  <!--
  <p> In this section, we describe the abstract syntactic and semantic
   structure of Haskell , as well as how it relates to the organization of
   the rest of the report.</p>
  -->
  <p>この節では、Haskell の抽象構文構造と抽象意味論構造について説明する。
   またこのレポートの他の部分の組立てとの関係についても説明する。</p>
  <ol>
   <!--
   <li>At the topmost level a Haskell program is a set of <i>modules</i>,
    described in Chapter <a href="modules.html#modules">5</a>. Modules
    provide a way to control namespaces and to re-use software in large
    programs.
    <p></p>
   </li>
   -->
   <li>最トップレベルでは Haskell プログラムとは<em>モジュール</em>の集
    まりである。モジュールについては
    <a href="modules.html#modules">5</a>章で説明している。モジュールは名
    前空間の制御と大規模プログラムにおけるソフトウェアの再利用の手段を提
    供している。
    <p></p>
   </li> 
   <!--
   <li>The top level of a module consists of a collection of
    <i>declarations</i>, of which there are several kinds, all described in
    Chapter <a href="decls.html#declarations">4</a>. Declarations define
    things such as ordinary values, datatypes, type classes, and fixity
    information.
    <p></p>
   </li>
   -->
   <li>モジュールのトップレベルは、<em>宣言</em>の集まりである。宣言には
    いくつかの種類があるが、そのすべてについて
    <a href="decls.html#declarations">4</a> 章で説明している。宣言は通常
    の値、データ型、型クラス、結合性情報などを定義する。
    <p></p>
   </li>
   <!--
   <li>At the next lower level are <i>expressions</i>, described in Chapter
    <a href="exps.html#expressions">3</a>. An expression denotes a <i>value
    </i>and has a <i>static type</i>; expressions are at the heart of
    Haskell programming "in the small."
    <p></p>
   </li>
   -->
   <li>その下のレベルは<em>式</em>である。これについては 
    <a href="exps.html#expressions">3</a> 章にて説明している。式はひとつ
     の<em>値</em>を表示するものであり、<em>静的な型</em>を持つ。式は
     Haskell でのプログラミングの中心であり、「小さい Haskell プログラム
     そのもの」である。
     <p></p>
   </li>
   <!--
   <li>At the bottom level is Haskell 's <i>lexical structure</i>, defined
    in Chapter <a href="lexemes.html#lexical-structure">2</a>. The lexical
    structure captures the concrete representation of Haskell programs in
    text files.
    <p></p>
   </li>
   -->
   <li>最下位レベルにあるのは Haskell の<em>字句構造</em>である。これに
    ついては <a href="lexemes.html#lexical-structure">2</a> 章にて定義し
    ている。字句構造はテキストファイル中の Haskell プログラムの具体的な
    表現を捉えるものである。
   </li>
  </ol>
  <!--
  <p>This report proceeds bottom-up with respect to Haskell 's syntactic
   structure.</p>
  -->
  <p>このレポートは Haskell の構文構造をボトムアップに説明を進める。</p>
  <!--
  <p> The chapters not mentioned above are Chapter <a
   href="basic.html#basic-types-and-classes">6</a>, which describes the
   standard built-in datatypes and classes in Haskell , and Chapter <a
   href="io-13.html#io">7</a>, which discusses the I/O facility in Haskell
   (i.e. how Haskell programs communicate with the outside world). Also,
   there are several chapters describing the Prelude, the concrete syntax,
   literate programming, the specification of derived instances, and
   pragmas supported by most Haskell compilers.</p>
  -->
  <p>上では言及しなかったが、
   <a href="basic.html#basic-types-and-classes">6</a> 章では Haskell に
   標準で組み込まれている型と型クラスについて、
   <a href="io-13.html#io">7</a> 章では Haskell の I/O (すなわち、
   Haskell のプログラムはどのようにして外の世界と通信するか)について議論
   する。また、いくつかの章では、プレリュード、具象構文、文芸的プログラ
   ミング、導出インスタンスの仕様、殆んどの Haskell コンパイラでサポート
   されているプラグマについて説明する。
  </p>
  <!--
  <p> Examples of Haskell program fragments in running text are given in
   typewriter font: <tt><br />
   <br />
   &nbsp;let&nbsp;x&nbsp;=&nbsp;1<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;=&nbsp;x+y<br />
   &nbsp;in&nbsp;&nbsp;z+1<br />
   <br />
   </tt>"Holes" in program fragments representing arbitrary pieces of
   Haskell code are written in italics, as in <tt>if</tt><i>
   e</i><sub><i>1</i></sub><i> </i><tt>then</tt><i>
   e</i><sub><i>2</i></sub><i> </i><tt>else</tt><i>
   e</i><sub><i>3</i></sub>. Generally the italicized names are mnemonic,
   such as <i>e</i> for expressions, <i>d</i> for declarations, <i>t</i>
   for types, etc.<a name="intro-kernel"></a></p>
  -->
  <p>このテキストでは Haskell のプログラムの断片は、タイプライタフォント
   で示す。<tt><br />
   <br />
   &nbsp;let&nbsp;x&nbsp;=&nbsp;1<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;=&nbsp;x+y<br />
   &nbsp;in&nbsp;&nbsp;z+1<br />
   <br />
   </tt>Haskell のコードの任意の部分を表現するプログラム断片の「穴」は
   <tt>if</tt><i>  e</i><sub><i>1</i></sub><i> </i><tt>then</tt>
   <i>  e</i><sub><i>2</i></sub><i> </i><tt>else</tt>
   <i>  e</i><sub><i>3</i></sub> のようにイタリックで書く。
   一般的には、イタリックの名前はニーモニックになっていて、<i>e</i> は式
   を、<i>d</i> は宣言を、<i>t</i> は型を表わす。
  </p>

  <p><a name="sect1.2"></a></p>
  <!--<h3>1.2<tt>&nbsp;&nbsp;</tt>The Haskell Kernel</h3>-->
  <h3>1.2<tt>&nbsp;&nbsp;</tt>Haskell のカーネル</h3>
  <!--
  <p> Haskell has adopted many of the convenient syntactic structures that
   have become popular in functional programming. In this Report, the
   meaning of such syntactic sugar is given by translation into simpler
   constructs. If these translations are applied exhaustively, the result
   is a program written in a small subset of Haskell that we call the
   Haskell <i>kernel</i>.</p>
  -->
  <p>Haskell は関数プログラミングの世界で人気になった多くの便利な構文構
   造を採用した。このレポートでは、そういった糖衣構文の意味をより単純な
  構成に変換することで与える。もし、これらの変換がどの場合にも、過不足な
  く適用されれば、結果は Haskell の<em>カーネル</em>と呼ぶ Haskell の小
  さいサブセットで書かれたプログラムになる。</p> 
  <!--
  <p> Although the kernel is not formally specified, it is essentially a
   slightly sugared variant of the lambda calculus with a straightforward
   denotational semantics. The translation of each syntactic structure into
   the kernel is given as the syntax is introduced. This modular design
   facilitates reasoning about Haskell programs and provides useful
   guidelines for implementors of the language.<a name="errors"></a></p>
  -->
  <p>このカーネルは形式的に仕様化されてはいないが、本質的には、直接的な
   表示的意味論をもつラムダ計算に少し糖衣構文をつけくわえたものである。
   それぞれの構文構造のカーネルへの変換は、その構文を導入した時に与える。
   </p>

  <p><a name="sect1.3"></a></p>
  <!--<h3>1.3<tt>&nbsp;&nbsp;</tt>Values and Types</h3>-->
  <h3>1.3<tt>&nbsp;&nbsp;</tt>値と型</h3>
  <!--
  <p> An expression evaluates to a <i>value</i> and has a static
   <i>type</i>. Values and types are not mixed in Haskell . However, the
   type system allows user-defined datatypes of various sorts, and permits
   not only parametric polymorphism (using a traditional Hindley-Milner
   type structure) but also <i>ad hoc</i> polymorphism, or
   <i>overloading</i> (using <i>type classes</i>).</p>
  -->
  <p>一つの式は評価されると一つの<em>値</em>となり、一つの式は一つの静的
   な<em>型</em>を持つ。Haskell では値と型がまぜこぜになることはない。し
   かしながら、型システムではいくつもの種類の利用者定義のデータ型を許し
   ている。また、(伝統的な Hindley-Milner の型構造を使用した)パラメータ
   多相性ばかりではなく、<em>アドホック</em>多相性あるいは(型クラスを使
   用した)<em>多重定義</em>も許されている。</p>
  <!--
  <p> Errors in Haskell are semantically equivalent to _|_. Technically,
   they are not distinguishable from nontermination, so the language
   includes no mechanism for detecting or acting upon errors. However,
   implementations will probably try to provide useful information about
   errors. See Section <a href="exps.html#basic-errors">3.1</a>.
  </p>
  -->
  <p>Haskell におけるエラーは意味論的には _|_ と同等である。技術的にはエ
   ラーは非停止と区別がつかないので、Haskell ではエラー検出あるいはエラー
   発生時の動作についての機構は言語には含まない。もちろん、実装ではエラー
   に関して有用な情報を提供しようとすることになろう。</p>

  <p><a name="namespaces"></a></p>
  <p><a name="sect1.4"></a></p>
  <!--<h3>1.4<tt>&nbsp;&nbsp;</tt>Namespaces</h3>-->
  <h3>1.4<tt>&nbsp;&nbsp;</tt>名前空間</h3>
  <!--
  <p> There are six kinds of names in Haskell : those for <i>variables</i>
   and <i>constructors</i> denote values; those for <i>type variables</i>,
   <i>type constructors</i>, and <i>type classes</i> refer to entities
   related to the type system; and <i>module names</i> refer to modules.
   There are two constraints on naming:</p>
  -->
  <p>Haskell には 6 種類の名前がある。<em>変数名</em>、<em>構成子名</em>
   は値を表し、<em>型変数名</em>、<em>型構成子名</em>、<em>型クラス名</em>
   は型システムに関わる実体への参照であり、<em>モジュール名</em>はモジュー
   ルへの参照である。名前をつけるにあたっては、以下のような制約がある。
  </p>
  <ol>
   <!--
   <li>Names for variables and type variables are identifiers beginning
    with lowercase letters or underscore; the other four kinds of names are
    identifiers beginning with uppercase letters.</li>
   -->
   <li>変数名と型変数名は小文字あるいはアンダースコアではじまる識別子であ
    る。それ以外の 4 種類の名前は大文字ではじまる識別子である。</li>
   <!--
   <li>An identifier must not be used as the name of a type constructor and
    a class in the same scope.</li>
   -->
   <li>ひとつの識別子は同じ有効範囲では型構成子名およびクラス名として使用
    してはならない。</li> 
  </ol>
  <!--
  <p>These are the only constraints; for example, <tt>Int</tt> may
   simultaneously be the name of a module, class, and constructor within a
   single scope.</p>
  -->
  <p>この 2 つだけが制約である。たとえば、<tt>Int</tt> は一つの有効範囲
   のなかで同時にモジュール名、クラス名、構成子名になることができる。
  </p> 

  <hr />

  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="preface-jfp.html">back</a> | <a
   href="lexemes.html">next</a> | <a href="index98.html">contents</a> | <a
   href="prelude-index.html">function index</a> <br />
   <font size="2">December 2002</font></p>
 </body>
</html>
