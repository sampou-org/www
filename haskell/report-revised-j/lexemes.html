
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=EUC-JP">
  <!--<title>Haskell 98 Lexical Structure</title>-->
  <title>Haskell 98 字句構造</title>
 </head>

 <body bgcolor="#ffffff">
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="intro.html">back</a> | <a
   href="exps.html">next</a> | <a href="index98.html">contents</a> | <a
   href="prelude-index.html">function index</a> <br />
  </p>

  <hr />

  <p><a name="lexical-structure"></a><a name="sect2"></a></p>
  <!--<h2>2<tt>&nbsp;&nbsp;</tt>Lexical Structure</h2>-->
  <h2>2<tt>&nbsp;&nbsp;</tt>字句構造</h2>
  <!--
  <p> In this chapter, we describe the low-level lexical structure of
   Haskell . Most of the details may be skipped in a first reading of the
   report.</p>
  -->
  <p>この章では、Haskell の下位レベルの字句構造について説明する。
   このレポートを初めて読む場合には、詳細のほとんどは飛ばしてかまわない。
  </p>

  <p><a name="notational-conventions"></a></p>
  <p> <a name="sect2.1"></a></p>
  <!--<h3>2.1<tt>&nbsp;&nbsp;</tt>Notational Conventions</h3>-->
  <h3>2.1<tt>&nbsp;&nbsp;</tt>表記規約</h3>

  <!--
  <p> These notational conventions are used for presenting syntax:</p>
  -->
  <p>次にあげる表記規約は構文を表現するために用いる。</p>
  <p></p>
  <p></p>
  <table>
   <tr>
    <td align="center"> <i>[pattern]</i></td>
    <!--<td> optional</td>-->
    <td> オプション</td>
   </tr>
   <tr>
    <td align="center"><i>{pattern}</i></td>
    <!--<td> zero or more repetitions</td>-->
    <td> 0回またはそれ以上の繰り返し</td>
   </tr>
   <tr>
    <td align="center"><i>(pattern)</i></td>
    <!--<td> grouping</td>-->
    <td> グループ化</td>
   </tr>
   <tr>
    <td align="center"><i>pat</i><sub><i>1</i></sub><i> |
     pat</i><sub><i>2</i></sub></td>
    <!--<td> choice</td>-->
    <td> 選択</td>
   </tr>
   <tr>
    <td align="center"><i>pat</i><sub><i>&lt;pat'&gt;</i></sub></td>
    <!--<td> difference---elements generated by <i>pat</i></td>-->
    <td> 差---<i>pat</i> で生成された要素から</td>
   </tr>
   <tr>
    <td align="center"></td>
    <!--<td> except those generated by <i>pat'</i></td>-->
    <td> <i>pat'</i> で生成されたものを除いたもの</td>
   </tr>
   <tr>
    <td align="center"><tt>fibonacci</tt></td>
    <!--<td> terminal syntax in typewriter font</td>-->
    <td> 終端構文はタイプライタフォント</td>
   </tr>
  </table>
  <p></p>
  <!--
  <p> Because the syntax in this section describes <i>lexical</i> syntax,
   all whitespace is expressed explicitly; there is no implicit space
   between juxtaposed symbols. BNF-like syntax is used throughout, with
   productions having the form:</p>
  -->
  <p>
   この節では構文は<em>字句</em>構文を記述するものなので、すべての白空白
   は明示的に表現する。隣接するシンボルの間には暗黙の空白は存在しない。次
   のような生成ルールをもつ BNF 風の構文を用いる。
  </p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> nonterm</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> alt<sub>1</sub> | alt<sub>2</sub> | ... |
     alt<sub>n</sub></td>
   </tr>
  </table>
  <!--
  <p> Care must be taken in distinguishing metalogical syntax such as <i>|
   </i>and <i>[...]</i> from concrete terminal syntax (given in typewriter
   font) such as <tt>|</tt> and <tt>[...]</tt>, although usually the
   context makes the distinction clear.</p>
  -->
  <p>
   <em>|</em> や <em>[...]</em> のような超論理的構文と(タイプライタフォ
   ントで与えられた) <tt>|</tt> や <tt>[...]</tt> のような具象終端構文を
   区別しなければならない。しかし、これらの区別はふつうは文脈から明かなも
   のである。
  </p>
  <!--
  <p> Haskell uses the Unicode [<a href="haskell.html#$unicode">11</a>]
   character set. However, source programs are currently biased toward the
   ASCII character set used in earlier versions of Haskell .</p>
  -->
  <p>
   Haskell では Unicode [<a href="haskell.html#$unicode">11</a>] 文字集
   合を使う。しかしながら、ソースプログラムは現時点では Haskell の過去の
   バージョンで使用されていた ASCII 文字集合であるものに偏っている。
  </p>
  <!--
  <p> This syntax depends on properties of the Unicode characters as
   defined by the Unicode consortium. Haskell compilers are expected to
   make use of new versions of Unicode as they are made available.</p>
  -->
  <p>
  この構文は Unicode コンソーシアムが定義した Unicode 文字の性質に依存す
  る。Haskell コンパイラは利用可能な Unicode の新しいバージョンを使うこ
  とが推奨されている。
  </p>

  <p><a name="lexemes"></a></p>
  <p> <a name="sect2.2"></a></p>
  <!--<h3>2.2<tt>&nbsp;&nbsp;</tt>Lexical Program Structure</h3>-->
  <h3>2.2<tt>&nbsp;&nbsp;</tt>字句上のプログラム構造</h3>

  <p><a name="whitespace"></a></p>
  <p></p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> program</td>
    <td> <tt>-&gt;</tt></td>
    <td> {lexeme | whitespace }</td>
   </tr>
   <tr>
    <td> lexeme</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvarid | qconid | qvarsym | qconsym</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> literal | special | reservedop | reservedid</td>
   </tr>
   <tr>
    <td> literal</td>
    <td> <tt>-&gt;</tt></td>
    <td> integer | float | char | string</td>
   </tr>
   <tr>
    <td> special</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>(</tt> | <tt>)</tt> | <tt>,</tt> | <tt>;</tt> | <tt>[</tt> |
     <tt>]</tt> | `| <tt>{</tt> | <tt>} </tt></td>
   </tr>
   <tr>
    <td> whitespace</td>
    <td> <tt>-&gt;</tt></td>
    <td> whitestuff {whitestuff}</td>
   </tr>
   <tr>
    <td> whitestuff</td>
    <td> <tt>-&gt;</tt></td>
    <td> whitechar | comment | ncomment</td>
   </tr>
   <tr>
    <td> whitechar</td>
    <td> <tt>-&gt;</tt></td>
    <td> newline | vertab | space | tab | uniWhite</td>
   </tr>
   <tr>
    <td> newline</td>
    <td> <tt>-&gt;</tt></td>
    <td> return linefeed | return | linefeed | formfeed</td>
   </tr>
   <tr>
    <td> return</td>
    <td> <tt>-&gt;</tt></td>
    <td> a carriage return</td>
   </tr>
   <tr>
    <td> linefeed</td>
    <td> <tt>-&gt;</tt></td>
    <td> a line feed</td>
   </tr>
   <tr>
    <td> vertab</td>
    <td> <tt>-&gt;</tt></td>
    <td> a vertical tab</td>
   </tr>
   <tr>
    <td> formfeed</td>
    <td> <tt>-&gt;</tt></td>
    <td> a form feed</td>
   </tr>
   <tr>
    <td> space</td>
    <td> <tt>-&gt;</tt></td>
    <td> a space</td>
   </tr>
   <tr>
    <td> tab</td>
    <td> <tt>-&gt;</tt></td>
    <td> a horizontal tab</td>
   </tr>
   <tr>
    <td> uniWhite</td>
    <td> <tt>-&gt;</tt></td>
    <td> any Unicode character defined as whitespace</td>
   </tr>
   <tr>
    <td> comment</td>
    <td> <tt>-&gt;</tt></td>
    <td> dashes [ any<sub>&lt;symbol&gt;</sub> {any}] newline</td>
   </tr>
   <tr>
    <td> dashes</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>--</tt> {<tt>-</tt>}</td>
   </tr>
   <tr>
    <td> opencom</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>{- </tt></td>
   </tr>
   <tr>
    <td> closecom</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>-} </tt></td>
   </tr>
   <tr>
    <td> ncomment</td>
    <td> <tt>-&gt;</tt></td>
    <td> opencom ANYseq {ncomment ANYseq}closecom</td>
   </tr>
   <tr>
    <td> ANYseq</td>
    <td> <tt>-&gt;</tt></td>
    <td> {ANY}<sub>&lt;{ANY}( opencom | closecom ) {ANY}&gt;</sub></td>
   </tr>
   <tr>
    <td> ANY</td>
    <td> <tt>-&gt;</tt></td>
    <td> graphic | whitechar</td>
   </tr>
   <tr>
    <td> any</td>
    <td> <tt>-&gt;</tt></td>
    <td> graphic | space | tab</td>
   </tr>
   <tr>
    <td> graphic</td>
    <td> <tt>-&gt;</tt></td>
    <td> small | large | symbol | digit | special | <tt>:</tt> | <tt>"</tt>
     | <tt>' </tt></td>
   </tr>
   <tr>
    <td> small</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascSmall | uniSmall | <tt>_ </tt></td>
   </tr>
   <tr>
    <td> ascSmall</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>a</tt> | <tt>b</tt> | ... | <tt>z </tt></td>
   </tr>
   <tr>
    <td> uniSmall</td>
    <td> <tt>-&gt;</tt></td>
    <td> any Unicode lowercase letter</td>
   </tr>
   <tr>
    <td> large</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascLarge | uniLarge</td>
   </tr>
   <tr>
    <td> ascLarge</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>A</tt> | <tt>B</tt> | ... | <tt>Z </tt></td>
   </tr>
   <tr>
    <td> uniLarge</td>
    <td> <tt>-&gt;</tt></td>
    <td> any uppercase or titlecase Unicode letter</td>
   </tr>
   <tr>
    <td> symbol</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascSymbol | uniSymbol<sub>&lt;special | <tt>_</tt> | <tt>:</tt> |
     <tt>"</tt> | <tt>'</tt>&gt;</sub></td>
   </tr>
   <tr>
    <td> ascSymbol</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>!</tt> | <tt>#</tt> | <tt>$</tt> | <tt>%</tt> | <tt>&amp;</tt>
     | <tt>*</tt> | <tt>+</tt> | <tt>.</tt> | <tt>/</tt> | <tt>&lt;</tt> |
     <tt>=</tt> | <tt>&gt;</tt> | <tt>?</tt> | @</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>\</tt> | <tt>^</tt> | <tt>|</tt> | <tt>-</tt> | <tt>~ </tt></td>
   </tr>
   <tr>
    <td> uniSymbol</td>
    <td> <tt>-&gt;</tt></td>
    <td> any Unicode symbol or punctuation</td>
   </tr>
   <tr>
    <td> digit</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascDigit | uniDigit</td>
   </tr>
   <tr>
    <td> ascDigit</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>0</tt> | <tt>1</tt> | ... | <tt>9 </tt></td>
   </tr>
   <tr>
    <td> uniDigit</td>
    <td> <tt>-&gt;</tt></td>
    <td> any Unicode decimal digit</td>
   </tr>
   <tr>
    <td> octit</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>0</tt> | <tt>1</tt> | ... | <tt>7 </tt></td>
   </tr>
   <tr>
    <td> hexit</td>
    <td> <tt>-&gt;</tt></td>
    <td> digit | <tt>A</tt> | ... | <tt>F</tt> | <tt>a</tt> | ... | <tt>f
     </tt></td>
   </tr>
  </table>
  <!--
  <p> Lexical analysis should use the "maximal munch" rule: at each point,
   the longest possible lexeme satisfying the <i>lexeme</i> production is
   read. So, although <tt>case</tt> is a reserved word, <tt>cases</tt> is
   not. Similarly, although <tt>=</tt> is reserved, <tt>==</tt> and
   <tt>~=</tt> are not.</p>
  -->
  <p>字句解析は「極大大喰らい」ルールを利用しなければならない。それぞれ
   のポイントで<em>単語</em>生成ルールを見たす最長の単語を読み込む。
   それで、<tt>case</tt> は予約語であるが、<tt>cases</tt> は予約語ではな
   い。同様に <tt>=</tt> は予約語であるが、<tt>==</tt> や <tt>~=</tt> 
   は予約語ではない。 
  </p>
  <!--
  <p> Any kind of <i>whitespace</i> is also a proper delimiter for lexemes.</p>
  -->
  <p>あらゆる種類の<em>白空白</em>は単語の正しい区切である。</p>
  <!--
  <p> Characters not in the category <i>ANY</i> are not valid in Haskell
   programs and should result in a lexing error.</p>
  -->
  <p><em>ANY</em> の範疇にはいらない文字は Haskell プログラムでは使用で
  きない。使用した場合には字句エラーにならねばならない。</p>

  <p> <a name="sect2.3"></a></p>
  <!--<h3>2.3<tt>&nbsp;&nbsp;</tt>Comments</h3>-->
  <h3>2.3<tt>&nbsp;&nbsp;</tt>コメント</h3>
  <!--
  <p> Comments are valid whitespace.</p>
  -->
  <p>コメントは正当な白空白である。</p>
  <!--
  <p> An ordinary comment begins with a sequence of two or more consecutive
   dashes (e.g. <tt>--</tt>) and extends to the following newline. <i>The
   sequence of dashes must not form part of a legal lexeme. </i>For
   example, "<tt>--&gt;</tt>" or "<tt>|--</tt>" do <i>not</i> begin a
   comment, because both of these are legal lexemes; however
   "<tt>--foo</tt>" does start a comment.</p>
  -->
  <p>通常のコメントは二つ以上の連続したダッシュ(つまり <tt>--</tt>) で構
   成される字句で始まり、次の改行までである。<em>一連のダッシュは正しい
   字句の一部を構成してはならない</em>。たとえば、"<tt>--&gt;</tt>" や
   "<tt>|--</tt>" ではコメントを開始<em>しない</em>。これらの字句が、ダッ
   シュのみで構成されているわけではないからである。しかしながら、
   "<tt>--foo</tt>"はコメントを開始する。</p> 
  <!--
  <p> A nested comment begins with "<tt>{-</tt>" and ends with
   "<tt>-}</tt>". No legal lexeme starts with "<tt>{-</tt>"; hence, for
   example, "<tt>{---</tt>" starts a nested comment despite the trailing
   dashes.</p>
  -->
  <p>ネストしたコメントは字句 "<tt>{-</tt>" ではじまり、"<tt>-}</tt>" で
   終る。正しい字句で、"<tt>{-</tt>" ではじまるものはない。それゆえ、
   たとえば、"<tt>{---</tt>" は余分なダッシュは付いているが、ネストした
   コメントを開始する。</p> 
  <!--
  <p> The comment itself is not lexically analysed. Instead, the first
   unmatched occurrence of the string "<tt>-}</tt>" terminates the nested
   comment. Nested comments may be nested to any depth: any occurrence of
   the string "<tt>{-</tt>" within the nested comment starts a new nested
   comment, terminated by "<tt>-}</tt>". Within a nested comment, each
   "<tt>{-</tt>" is matched by a corresponding occurrence of "<tt>-}</tt>".</p>
  -->
  <p>コメントそれ自身は字句解析されることはない。最初の未対応
   "<tt>-}</tt>"によって、そのネストしたコメントは終了する。ネストしたコ
   メントは何段にもネストすることが可能で、"<tt>{-</tt>" があらわれるた
   びに新しいネストしたコメントが開始され、それは "<tt>-}</tt>" で終了す
   る。ネストしたコメント内の各 "<tt>{-</tt>" はそれぞれに対する
   "<tt>-}</tt>" で対応させる。</p>
  <!--
  <p> In an ordinary comment, the character sequences "<tt>{-</tt>" and
   "<tt>-}</tt>" have no special significance, and, in a nested comment, a
   sequence of dashes has no special significance.</p>
  -->
  <p>通常のコメント内では文字のならび "<tt>{-</tt>" や "<tt>-}</tt>" は
   特別な意味を持たない。ネストしたコメント内では連続したダッシュは特別
   な意味を持たない。</p>
  <!--
  <p> Nested comments are also used for compiler pragmas, as explained in
   Chapter <a href="pragmas.html#pragmas">11</a>.</p>
  -->
  <p>ネストしたコメントはコンパイラに対するプラグマとしても用いられる。
  これに関しては <a href="pragmas.html#pragmas">11</a> で説明する。</p>
  <!--
  <p> If some code is commented out using a nested comment, then any
   occurrence of <tt>{-</tt> or <tt>-}</tt> within a string or within an
   end-of-line comment in that code will interfere with the nested
   comments.</p>
  -->
  <p>コードがネストしたコメントによってコメントアウトされている場合、文
   字列内あるいは行末までのコメント内に <tt>{-</tt> や <tt>-}</tt> があ
   ると当該のネストしたコメントに影響する。</p>

  <p><a name="ids"></a></p>
  <p> <a name="sect2.4"></a></p>
  <!--<h3>2.4<tt>&nbsp;&nbsp;</tt>Identifiers and Operators</h3>-->
  <h3>2.4<tt>&nbsp;&nbsp;</tt>識別子と演算子</h3>

  <p></p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> varid</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> (small {small | large | digit | <tt>'</tt>
     })<sub>&lt;reservedid&gt;</sub></td>
   </tr>
   <tr>
    <td> conid</td>
    <td> <tt>-&gt;</tt></td>
    <td> large {small | large | digit | <tt>'</tt> }</td>
   </tr>
   <tr>
    <td> reservedid</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>case</tt> | <tt>class</tt> | <tt>data</tt> | <tt>default</tt>
     | <tt>deriving</tt> | <tt>do</tt> | <tt>else </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>if</tt> | <tt>import</tt> | <tt>in</tt> | <tt>infix</tt> |
     <tt>infixl</tt> | <tt>infixr</tt> | <tt>instance </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>let</tt> | <tt>module</tt> | <tt>newtype</tt> | <tt>of</tt> |
     <tt>then</tt> | <tt>type</tt> | <tt>where</tt> | <tt>_ </tt></td>
   </tr>
  </table>
  <!--
  <p> An identifier consists of a letter followed by zero or more letters,
   digits, underscores, and single quotes. Identifiers are lexically
   distinguished into two namespaces (Section <a
   href="intro.html#namespaces">1.4</a>): those that begin with a
   lower-case letter (variable identifiers) and those that begin with an
   upper-case letter (constructor identifiers). Identifiers are case
   sensitive: <tt>name</tt>, <tt>naMe</tt>, and <tt>Name</tt> are three
   distinct identifiers (the first two are variable identifiers, the last
   is a constructor identifier).</p>
  -->
  <p>識別子は英字ではじまり、英字、数字、アンダースコア、シングルクウォー
   トが0 個ないしそれ以上つづく。識別子は字句としては 2 つの名前空間
   (<a href="intro.html#namespaces">1.4</a> 節)に分けられ区別される。
   小文字で始まる識別子(変数識別子)と、大文字で始まる識別子(構成子識
   別子)である。識別子では、大文字、小文字は区別される。<tt>name</tt>、
   <tt>naMe</tt>、<tt>Name</tt> はそれぞれ別の識別子である。(最初の 2 つ
   は変数識別子、最後のものは構成子識別子である。)</p> 
  <!--
  <p> Underscore, "<tt>_</tt>", is treated as a lower-case letter, and can
   occur wherever a lower-case letter can. However, "<tt>_</tt>" all by
   itself is a reserved identifier, used as wild card in patterns.
   Compilers that offer warnings for unused identifiers are encouraged to
   suppress such warnings for identifiers beginning with underscore. This
   allows programmers to use "<tt>_foo</tt>" for a parameter that they
   expect to be unused.</p>
  -->
  <p>アンダースコア "<tt>_</tt>" は小文字と看倣され、小文字が出現可能な
   場所で使用することができる。しかし、"<tt>_</tt>" はそれ自身は予約済の
   識別子であり、パターンにおいてワイルドカードとして使用する。未使用の
   識別子に対して警告を出すコンパイラではアンダースコアで始まる識別子に
   対する警告は抑制することを推奨されている。それ故、プログラマは不使用
   を期待されているような "<tt>_foo</tt>" をパラメータとして使用すること
   も可能である。</p>

  <p></p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> varsym</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> ( symbol {symbol | <tt>:</tt>})<sub>&lt;reservedop |
     dashes&gt;</sub></td>
   </tr>
   <tr>
    <td> consym</td>
    <td> <tt>-&gt;</tt></td>
    <td> (<tt>:</tt> {symbol | <tt>:</tt>})<sub>&lt;reservedop&gt;</sub></td>
   </tr>
   <tr>
    <td> reservedop</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>..</tt> | <tt>:</tt> | <tt>::</tt> | <tt>=</tt> | <tt>\</tt> |
     <tt>|</tt> | <tt>&lt;-</tt> | <tt>-&gt;</tt> | <tt>@</tt> | <tt>~</tt>
     | <tt>=&gt; </tt></td>
   </tr>
  </table>
  <!--
  <p> <i>Operator symbols</i> are formed from one or more symbol
   characters, as defined above, and are lexically distinguished into two
   namespaces (Section <a href="intro.html#namespaces">1.4</a>):</p>
  -->
  <p>演算子シンボルは 1 つ以上のシンボル文字で、上記のように構成される。
   また、字句としては 2 つの名前空間
   (<a href="intro.html#namespaces">1.4</a> 節)に分けられ区別される。</p>

  <ul>
   <!--<li>An operator symbol starting with a colon is a constructor.
   </li>-->
   <li>コロンで始まる演算子シンボルは構成子である。</li>
   <!--<li>An operator symbol starting with an other character is 
    an ordinary identifier.</li>-->
   <li>それ以外の文字ではじまる演算子シンボルは通常の識別子である。</li>
  </ul>
  <!--
  <p>Notice that a colon by itself, "<tt>:</tt>", is reserved solely for
   use as the Haskell list constructor; this makes its treatment uniform
   with other parts of list syntax, such as "<tt>[]</tt>" and
   "<tt>[a,b]</tt>".</p>
  -->
  <p>コロンそのもの "<tt>:</tt>" は Haskell のリスト構成子専用に予約され
   ていることに注意すること。この扱いは、他のリスト構文、"<tt>[]</tt>"
   や "[a,b]" などと同じ扱いになっている。</p>
  <!--
  <p> Other than the special syntax for prefix negation, all operators are
   infix, although each infix operator can be used in a <i>section</i> to
   yield partially applied operators (see Section <a
   href="exps.html#sections">3.5</a>). All of the standard infix operators
   are just predefined symbols and may be rebound.</p>
  -->
  <p>前置の符号反転の特別な構文を以外はすべての演算子は中置である。
   しかし、おのおのは、<em>セクション</em>で部分適用演算子
   (<a href="exps.html#sections">3.5</a>節を参照)として使用することができる。
   標準の中置演算子はすべてあらかじめ定義済のシンボルである。これは再定
   義可能である。</p>
  <!--
  <p> In the remainder of the report six different kinds of names will be
   used:</p>
  -->
  <p>このレポートの残りの部分では 6 種類の名前を使いわける。</p>

  <p></p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> varid</td>
    <td width="20"></td>
    <td width="250"></td>
    <td> (variables)</td>
   </tr>
   <tr>
    <td> conid</td>
    <td></td>
    <td></td>
    <td> (constructors)</td>
   </tr>
   <tr>
    <td> tyvar</td>
    <td> <tt>-&gt;</tt></td>
    <td> varid</td>
    <td> (type variables)</td>
   </tr>
   <tr>
    <td> tycon</td>
    <td> <tt>-&gt;</tt></td>
    <td> conid</td>
    <td> (type constructors)</td>
   </tr>
   <tr>
    <td> tycls</td>
    <td> <tt>-&gt;</tt></td>
    <td> conid</td>
    <td> (type classes)</td>
   </tr>
   <tr>
    <td> modid</td>
    <td> <tt>-&gt;</tt></td>
    <td> conid</td>
    <td> (modules)</td>
   </tr>
  </table>
  <!--
  <p> Variables and type variables are represented by identifiers beginning
   with small letters, and the other four by identifiers beginning with
   capitals; also, variables and constructors have infix forms, the other
   four do not. Namespaces are also discussed in Section <a
   href="intro.html#namespaces">1.4</a>.</p>
  -->
  <p>変数と型変数は小文字で始まる識別子で表現され、それ以外の 4 つは大文
   字で始まる識別子で表現される。また、変数と構成子は中置形式をもち、そ
   れ以外の 4 つは中置形式はもたない。名前空間については
   <a href="intro.html#namespaces">1.4</a> 節で議論している。</p>
  <!--
  <p> A name may optionally be <i>qualified</i> in certain circumstances by
   prepending them with a module identifier. This applies to variable,
   constructor, type constructor and type class names, but not type
   variables or module names. Qualified names are discussed in detail in
   Chapter <a href="modules.html#modules">5</a>.</p>
  -->
  <p>外部名は場合によりモジュール名の<em>修飾子</em>が付けられる。
   この修飾子の付加は、変数、構成子、型構成子、型クラスに対して行われ、
   型変数、モジュール名に対しては行われない。被修飾名についての詳細な議
   論は <a href="modules.html#modules">5</a> 章で行う。</p>

  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> qvarid</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> [modid <tt>.</tt>] varid</td>
   </tr>
   <tr>
    <td> qconid</td>
    <td> <tt>-&gt;</tt></td>
    <td> [modid <tt>.</tt>] conid</td>
   </tr>
   <tr>
    <td> qtycon</td>
    <td> <tt>-&gt;</tt></td>
    <td> [modid <tt>.</tt>] tycon</td>
   </tr>
   <tr>
    <td> qtycls</td>
    <td> <tt>-&gt;</tt></td>
    <td> [modid <tt>.</tt>] tycls</td>
   </tr>
   <tr>
    <td> qvarsym</td>
    <td> <tt>-&gt;</tt></td>
    <td> [modid <tt>.</tt>] varsym</td>
   </tr>
   <tr>
    <td> qconsym</td>
    <td> <tt>-&gt;</tt></td>
    <td> [modid <tt>.</tt>] consym</td>
   </tr>
  </table>
  <!--
  <p>Since a qualified name is a lexeme, no spaces are allowed between the
   qualifier and the name. Sample lexical analyses are shown below.</p>
  -->
  <p>ひとつ被修飾名は、ひとつの字句であるので、修飾子と名前の間に空白を
   置くことは許されない。字句解析の例を以下に示す。</p>
  <p></p>
  <table border="2">
   <tr>
    <td> これは</td>
    <td> このように字句解析される</td>
   </tr>
   <tr>
    <td> <tt>f.g</tt></td>
    <td> <tt>f&nbsp;.&nbsp;g</tt> (three tokens)</td>
   </tr>
   <tr>
    <td><tt>F.g</tt></td>
    <td> <tt>F.g</tt> (qualified `g')</td>
   </tr>
   <tr>
    <td><tt>f..</tt></td>
    <td> <tt>f&nbsp;..</tt> (two tokens)</td>
   </tr>
   <tr>
    <td><tt>F..</tt></td>
    <td> <tt>F..</tt> (qualified `.')</td>
   </tr>
   <tr>
    <td><tt>F.</tt></td>
    <td> <tt>F&nbsp;.</tt> (two tokens)</td>
   </tr>
  </table>
  <!--
  <p> The qualifier does not change the syntactic treatment of a name; for
   example, <tt>Prelude.+</tt> is an infix operator with the same fixity as
   the definition of <tt>+</tt> in the Prelude (Section <a
   href="decls.html#fixity">4.4.2</a>).</p>
  -->
  <p> 修飾子が名前の構文的扱いを変更することはない。たとえば、
   <tt>Prelude.+</tt> は中置オペレータでありプレリュード中で定義された
   <tt>+</tt> と同じ結合性(<a href="decls.html#fixity">4.4.2</a>節)をもつ。
  </p>

  <p><a name="lexemes-numeric"></a></p>
  <p> <a name="sect2.5"></a></p>
  <!--<h3>2.5<tt>&nbsp;&nbsp;</tt>Numeric Literals</h3>-->
  <h3>2.5<tt>&nbsp;&nbsp;</tt>数値リテラル</h3>
  <p></p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> decimal</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> digit{digit}</td>
   </tr>
   <tr>
    <td> octal</td>
    <td> <tt>-&gt;</tt></td>
    <td> octit{octit}</td>
   </tr>
   <tr>
    <td> hexadecimal</td>
    <td> <tt>-&gt;</tt></td>
    <td> hexit{hexit}</td>
   </tr>
  </table>

  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr></tr>
   <tr>
    <td> integer</td>
    <td> <tt>-&gt;</tt></td>
    <td> decimal</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>0o</tt> octal | <tt>0O</tt> octal</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>0x</tt> hexadecimal | <tt>0X</tt> hexadecimal</td>
   </tr>
   <tr>
    <td> float</td>
    <td> <tt>-&gt;</tt></td>
    <td> decimal <tt>.</tt> decimal [exponent]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> decimal exponent</td>
   </tr>
   <tr>
    <td> exponent</td>
    <td> <tt>-&gt;</tt></td>
    <td> (<tt>e</tt> | <tt>E</tt>) [<tt>+</tt> | <tt>-</tt>] decimal</td>
   </tr>
  </table>
  <!--
  <p>There are two distinct kinds of numeric literals: integer and
   floating. Integer literals may be given in decimal (the default), octal
   (prefixed by <tt>0o</tt> or <tt>0O</tt>) or hexadecimal notation
   (prefixed by <tt>0x</tt> or <tt>0X</tt>). Floating literals are always
   decimal. A floating literal must contain digits both before and after
   the decimal point; this ensures that a decimal point cannot be mistaken
   for another use of the dot character. Negative numeric literals are
   discussed in Section <a href="exps.html#operators">3.4</a>. The typing
   of numeric literals is discussed in Section <a
   href="basic.html#numeric-literals">6.4.1</a>.<p>
  -->
  <p>数値リテラルには 2 種類ある。整数と浮動小数である。整数リテラルは
   10 進(デフォルト)、8 進( 0o あるいは 0O を接頭辞とする)あるいは 16 進
   ( 0x あるいは 0X を接頭辞とする)で表現される。浮動小数は常に 10 進で
   表現される。浮動小数リテラルは小数点の前と後の両方に数字を含んでいな
   ければならない。このようになっているのは小数点と別のドット文字の使用
   法とが混同されないためである。負の数値リテラルについては
   <a href="exps.html#operators">3.4</a> 節で議論する。数値リテラルの型
   付けについては、<a href="basic.html#numeric-literals">6.4.1</a> 節で
   議論する。</p>

  <p> <a name="lexemes-char"></a></p>
  <p> <a name="sect2.6"></a></p>
  <!--<h3>2.6<tt>&nbsp;&nbsp;</tt>Character and String Literals</h3>-->
  <h3>2.6<tt>&nbsp;&nbsp;</tt>文字リテラルと文字列リテラル</h3>
  <p></p>

  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"> char</td>
    <td width="20"> <tt>-&gt;</tt></td>
    <td width="250"> <tt>'</tt> (graphic<sub>&lt;<tt>'</tt> |
     <tt>\</tt>&gt;</sub> | space |
     escape<sub>&lt;<tt>\&amp;</tt>&gt;</sub>) <tt>' </tt></td>
   </tr>
   <tr>
    <td> string</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>"</tt> {graphic<sub>&lt;<tt>"</tt> | <tt>\</tt>&gt;</sub> |
     space | escape | gap}<tt>" </tt></td>
   </tr>
   <tr>
    <td> escape</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>\</tt> ( charesc | ascii | decimal | <tt>o</tt> octal |
     <tt>x</tt> hexadecimal )</td>
   </tr>
   <tr>
    <td> charesc</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>a</tt> | <tt>b</tt> | <tt>f</tt> | <tt>n</tt> | <tt>r</tt> |
     <tt>t</tt> | <tt>v</tt> | <tt>\</tt> | <tt>"</tt> | <tt>'</tt> |
     <tt>&amp; </tt></td>
   </tr>
   <tr>
    <td> ascii</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>^</tt>cntrl | <tt>NUL</tt> | <tt>SOH</tt> | <tt>STX</tt> |
     <tt>ETX</tt> | <tt>EOT</tt> | <tt>ENQ</tt> | <tt>ACK</tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>BEL</tt> | <tt>BS</tt> | <tt>HT</tt> | <tt>LF</tt> |
     <tt>VT</tt> | <tt>FF</tt> | <tt>CR</tt> | <tt>SO</tt> | <tt>SI</tt> |
     <tt>DLE</tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>DC1</tt> | <tt>DC2</tt> | <tt>DC3</tt> | <tt>DC4</tt> |
     <tt>NAK</tt> | <tt>SYN</tt> | <tt>ETB</tt> | <tt>CAN</tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>EM</tt> | <tt>SUB</tt> | <tt>ESC</tt> | <tt>FS</tt> |
     <tt>GS</tt> | <tt>RS</tt> | <tt>US</tt> | <tt>SP</tt> | <tt>DEL </tt></td>
   </tr>
   <tr>
    <td> cntrl</td>
    <td> <tt>-&gt;</tt></td>
    <td> ascLarge | @ | <tt>[</tt> | <tt>\</tt> | <tt>]</tt> | <tt>^</tt> |
     <tt>_ </tt></td>
   </tr>
   <tr>
    <td> gap</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>\</tt> whitechar {whitechar}<tt>\ </tt></td>
   </tr>
  </table>
  <!--
  <p> Character literals are written between single quotes, as in
   <tt>'a'</tt>, and strings between double quotes, as in <tt>"Hello"</tt>.</p>
  -->
  <p>文字リテラルは単一引用符の間に書く。たとえば、<tt>'a'</tt>。文字列
   リテラルは二重引用符の間に書く。たとえば、<tt>"Hello"</tt> </p> 
  <!--
  <p> Escape codes may be used in characters and strings to represent
   special characters. Note that a single quote <tt>'</tt> may be used in a
   string, but must be escaped in a character; similarly, a double quote
   <tt>"</tt> may be used in a character, but must be escaped in a string.
   <tt>\</tt> must always be escaped. The category <i>charesc</i> also
   includes portable representations for the characters "alert"
   (<tt>\a</tt>), "backspace" (<tt>\b</tt>), "form feed" (<tt>\f</tt>),
   "new line" (<tt>\n</tt>), "carriage return" (<tt>\r</tt>), "horizontal
   tab" (<tt>\t</tt>), and "vertical tab" (<tt>\v</tt>).</p>
  -->
  <p>エスケープコードは文字あるいは文字列の中で用いられ特別な文字を表現
   する。単一引用符 <tt>'</tt> は文字として文字列の中で使われることがあ
   る。しかし、文字で表現する場合は必ず、エスケープされていなければなら
   ないことに注意すること。同様に二重引用符を文字のとして使うことがある
   が、文字列の中にあるときは必ずエスケープされていなければならない。
   <tt>\</tt> は常にエスケープされなければならない。
   <em>charesc</em> カテゴリーには以下のような移植性の
   ある特別な文字表現が含まれる。「アラート(<tt>\a</tt>)、「バックスペー
   ス」(<tt>\b</tt>)、「フォームフィード」(<tt>\f</tt>)、「改行」
   (<tt>\n</tt>)、「キャリッジリターン」(<tt>\r</tt>)、「水平タブ」
   (<tt>\t</tt>)、「垂直タブ」(<tt>\v</tt>)。</p> 
  <!--
  <p> Escape characters for the Unicode character set, including control
   characters such as <tt>\^X</tt>, are also provided. Numeric escapes such
   as <tt>\137</tt> are used to designate the character with decimal
   representation 137; octal (e.g. <tt>\o137</tt>) and hexadecimal (e.g.
   <tt>\x37</tt>) representations are also allowed.</p>
  -->
  <p>ユニコード文字集合用の <tt>\^X</tt> のような制御文字を含む、エスケー
   プ文字が供給されている。<tt>\137</tt> のような数値エスケープは十進で
   文字を指定するのに使用する。また、8 進( <tt>\o137</tt> )や 16 進(
   <tt>\x37</tt>)の表現も許されている。</p> 
  <!--
  <p> Consistent with the "maximal munch" rule, numeric escape characters
   in strings consist of all consecutive digits and may be of arbitrary
   length. Similarly, the one ambiguous ASCII escape code, <tt>"\SOH"</tt>,
   is parsed as a string of length 1. The escape character <tt>\&amp;</tt>
   is provided as a "null character" to allow strings such as
   <tt>"\137\&amp;9"</tt> and <tt>"\SO\&amp;H"</tt> to be constructed (both
   of length two). Thus <tt>"\&amp;"</tt> is equivalent to <tt>""</tt> and
   the character <tt>'\&amp;'</tt> is disallowed. Further equivalences of
   characters are defined in Section 
   <a href="basic.html#characters">6.1.2</a>.</p>
  -->
  <p>「極大大喰らい」ルールにより、文字列中の数値エスケープ文字は連続し
   た数字で構成され、その長さは任意である。同様にして曖昧なアスキーエス
   ケープコード <tt>"\SOH"</tt> は長さ 1 の文字列と看倣される。エスケー
   プ文字<tt>\&amp;</tt> は「ナル文字」として供給され、
   <tt>"\137\&amp;9"</tt> あるいは  <tt>"\SO\&amp;H"</tt> というような文
   字列を構成することができる(これらの文字列長はともに 2)。それゆえ
   <tt>"\&amp;"</tt> は <tt>""</tt>と同等であり、<tt>'\&amp;'</tt> は許
   されていない。文字の同等性について詳しくは  <a
   href="basic.html#characters">6.1.2</a> 節に定義されている。</p> 
  <!--
  <p> A string may include a "gap"---two backslants enclosing white
   characters---which is ignored. This allows one to write long strings on
   more than one line by writing a backslant at the end of one line and at
   the start of the next. For example, <tt><br />
   <br />
   "Here&nbsp;is&nbsp;a&nbsp;backslant&nbsp;\\&nbsp;as&nbsp;well&nbsp;as&nbsp;\137,&nbsp;\<br />
   &nbsp;&nbsp;&nbsp;&nbsp;\a&nbsp;numeric&nbsp;escape&nbsp;character,&nbsp;and&nbsp;\^X,&nbsp;a&nbsp;control&nbsp;character."<br />
   </tt></p>
  -->
  <p>文字列は「隙間」-- ふたつのバックスラッシュにはさまれた空白文字 --
   を含むことができ、これは無視される。これにより、行末および次の行頭に
   バックスラッシュを置くことで、1 行をこえる文字列を表現することができ
   る。たとえば、<tt><br />
   <br />
   "Here&nbsp;is&nbsp;a&nbsp;backslant&nbsp;\\&nbsp;as&nbsp;well&nbsp;as&nbsp;\137,&nbsp;\<br />
   &nbsp;&nbsp;&nbsp;&nbsp;\a&nbsp;numeric&nbsp;escape&nbsp;character,&nbsp;and&nbsp;\^X,&nbsp;a&nbsp;control&nbsp;character."<br />
   </tt>
  </p>
  <!--
  <p> String literals are actually abbreviations for lists of characters
   (see Section <a href="exps.html#lists">3.7</a>).</p>
  -->
  <p>文字列リテラルは実際には文字のリストの簡略表現である。
   (<a href="exps.html#lists">3.7</a> 節参照)</p>

  <p><a name="lexemes-layout"></a></p>
  <p> <a name="sect2.7"></a></p>

  <!--<h3>2.7<tt>&nbsp;&nbsp;</tt>Layout</h3>-->
  <h3>2.7<tt>&nbsp;&nbsp;</tt>レイアウト</h3>
  <!--
  <p> Haskell permits the omission of the braces and semicolons used in
   several grammar productions, by using <i>layout</i> to convey the same
   information. This allows both layout-sensitive and layout-insensitive
   styles of coding, which can be freely mixed within one program. Because
   layout is not required, Haskell programs can be straightforwardly
   produced by other programs.</p>
  -->
  <p>Haskell では<em>レイアウト</em>を使うことで、同じ種類の情報をもつブ
   レースやセミコロンを省略することが許されている。つまり、レイアウトを
   考慮するコーディングスタイルも、レイアウトを無視するコーディングスタ
   イルも可能で、ひとつのプログラム内で自由に組合せることができる。レイ
   アウトは必須ではないので、Haskell のプログラムは他のプログラムから直
   接に生成することができる。</p>
  <!--
  <p> The effect of layout on the meaning of a Haskell program can be
   completely specified by adding braces and semicolons in places
   determined by the layout. The meaning of this augmented program is now
   layout insensitive.</p>
  -->
  <p>レイアウトが Haskell プログラムの意味にあたえる効果は、レイアウトに
   より決定する位置にブレースとセミコロンを加えることにより完全に指定す
   ることが可能である。このように補強されたプログラムの意味は、レイアウ
   トを無視したものになる。</p> 
  <!--
  <p> Informally stated, the braces and semicolons are inserted as follows.
   The layout (or "off-side") rule takes effect whenever the open brace is
   omitted after the keyword <tt>where</tt>, <tt>let</tt>, <tt>do</tt>, or
   <tt>of</tt>. When this happens, the indentation of the next lexeme
   (whether or not on a new line) is remembered and the omitted open brace
   is inserted (the whitespace preceding the lexeme may include comments).
   For each subsequent line, if it contains only whitespace or is indented
   more, then the previous item is continued (nothing is inserted); if it
   is indented the same amount, then a new item begins (a semicolon is
   inserted); and if it is indented less, then the layout list ends (a
   close brace is inserted). If the indentation of the non-brace lexeme
   immediately following a <tt>where</tt>, <tt>let</tt>, <tt>do</tt> or
   <tt>of</tt> is less than or equal to the current indentation level, then
   instead of starting a layout, an empty list "<tt>{}</tt>" is inserted,
   and layout processing occurs for the current level (i.e. insert a
   semicolon or close brace). A close brace is also inserted whenever the
   syntactic category containing the layout list ends; that is, if an
   illegal lexeme is encountered at a point where a close brace would be
   legal, a close brace is inserted. The layout rule matches only those
   open braces that it has inserted; an explicit open brace must be matched
   by an explicit close brace. Within these explicit open braces, <i>no</i>
   layout processing is performed for constructs outside the braces, even
   if a line is indented to the left of an earlier implicit open brace.</p>
  -->
  <p>非公式ないいかたをすると、ブレースとセミコロンは以下のように挿入さ
   れる。レイアウト(あるいはオフサイド)規則は、キーワード <tt>where</tt>、
   <tt>let</tt>、<tt>do</tt>、<tt>of</tt>の後で開ブレースを省略する効果
   がある。このキーワードの後で、(改行があるなしにかかわらず)次の字句の
   字下げが想起され、省略せされていた開ブレースが挿入される。(この字句に
   先だつ空白はコメントも含まれる。) その後に続く各行については、もし、
   その行が空白のみの行であるか、あるいは、字下げがより深ければ、直前の
   アイテムは(なにも挿入されることなく)継続される。もし、インデントが同
   じ深さなら、(セミコロンが挿入され)新しいアイテムが開始される。もし、
   インデントが浅ければ、(閉ブレースが挿入され)レイアウトリストは終了す
   る。もし、<tt>where</tt>、<tt>let</tt>、<tt>do</tt> あるいは
   <tt>of</tt> の直後のブレースではない字句のインデントが<em>現在の</em>
   インデントレベルと等しいかそれより小さい場合、レイアウトは開始されず、
   かわりに空のリスト"<tt>{}</tt>"が挿入され、レイアウト処理は現在のイン
   デントレベルに対して行われる(すなわち、セミコロンあるいは閉ブレース
   が挿入される)。閉ブレースはレイアウトリストを含む構文範疇が終了すると
   ころにも必ず挿入される。不正な字句に遭遇したとき、その場所に閉ブレー
   スがあってもよい場合には、閉ブレースが挿入される。レイアウト規則は、
   挿入されたばかりの開ブレースにのみ対応する。明示的な開ブレースは、明
   示的な閉ブレースとのみ対応づけられなければならない。明示的な開ブレー
   スの中では、<em>いかなる</em>レイアウトも行われず、たとえ、行が前方の
   暗黙の開ブレースより左に字下げされようとも、ブレースの外になにもつく
   ることはない。</p>
  <!--
  <p> Section <a href="syntax-iso.html#layout">9.3</a> gives a more precise
   definition of the layout rules.</p>
  -->
  <p><a href="syntax-iso.html#layout">B.3</a> 節ではレイアウト規則につい
  てより正確な定義をしている。</p>
  <!--
  <p> Given these rules, a single newline may actually terminate several
   layout lists. Also, these rules permit: 
  -->
  <p>これらのルールにより、ひとつの改行が複数のレイアウトリストを終了さ
   せうる。また、これらのルールにより以下の
   <tt><br />
   <br />
   f&nbsp;x&nbsp;=&nbsp;let&nbsp;a&nbsp;=&nbsp;1;&nbsp;b&nbsp;=&nbsp;2&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;y&nbsp;=&nbsp;exp2<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;exp1<br />
   <br />
   </tt>
  <!--
   making <tt>a</tt>, <tt>b</tt> and <tt>g</tt> all part of the same
   layout list.</p>
  -->
   <tt>a</tt>、<tt>b</tt> および <tt>g</tt> はどれも同じレイアウトリスト
   の一部である。</p>
  <!--
  <p> As an example, Figure <a href="lexemes.html#layout-before">2.1</a>
   shows a (somewhat contrived) module and Figure <a
   href="lexemes.html#layout-after">2.2</a> shows the result of applying
   the layout rule to it. Note in particular: (a) the line beginning
   <tt>}};pop</tt>, where the termination of the previous line invokes
   three applications of the layout rule, corresponding to the depth (3) of
   the nested <tt>where</tt> clauses, (b) the close braces in the
   <tt>where</tt> clause nested within the tuple and <tt>case</tt>
   expression, inserted because the end of the tuple was detected, and (c)
   the close brace at the very end, inserted because of the column 0
   indentation of the end-of-file token.</p>
  -->
  </p>例をあげるなら、図 <a href="lexemes.html#layout-before">1</a> はひ
   とつのモジュール(いくぶん自明だが)を示しており、図 <a
   href="lexemes.html#layout-after">2</a> はそれにレイアウト規則を適用し
   たものを示している。特に、以下の点に注目されたい：(a) <tt>}};pop</tt>
   ではじまる行では、前の行の終端が、入れ子になった <tt>where</tt> 節の
   深さ(3) に対応して、3度のレイアウト規則の適用を起こしていること。(b)
   タプルの中と <tt>case</tt> 式の中でネストしている <tt>where</tt> 節の
   なかに、タプルの終端が検出されたが故に閉ブレースが挿入されていること。
   (c) 最後の最後にある閉ブレースはファイル終端トークンの 0 カラム字下げ
   によるものであること。</p>
  <p></p>
  <table border="2" cellpadding="3">
   <tr>
    <td>
     <div align="center">
      <table border="2" cellpadding="3">
       <tr>
        <td> <tt><br />
         module&nbsp;AStack(&nbsp;Stack,&nbsp;push,&nbsp;pop,&nbsp;top,&nbsp;size&nbsp;)&nbsp;where<br />
         data&nbsp;Stack&nbsp;a&nbsp;=&nbsp;Empty&nbsp;<br />
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;MkStack&nbsp;a&nbsp;(Stack&nbsp;a)<br />
         <br />
         push&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a<br />
         push&nbsp;x&nbsp;s&nbsp;=&nbsp;MkStack&nbsp;x&nbsp;s<br />
         <br />
         size&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Int<br />
         size&nbsp;s&nbsp;=&nbsp;length&nbsp;(stkToLst&nbsp;s)&nbsp;&nbsp;where<br />
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stkToLst&nbsp;&nbsp;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br />
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stkToLst&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;&nbsp;=&nbsp;x:xs&nbsp;where&nbsp;xs&nbsp;=&nbsp;stkToLst&nbsp;s<br />
         <br />
         pop&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;(a,&nbsp;Stack&nbsp;a)<br />
         pop&nbsp;(MkStack&nbsp;x&nbsp;s)<br />
         &nbsp;&nbsp;=&nbsp;(x,&nbsp;case&nbsp;s&nbsp;of&nbsp;r&nbsp;-&gt;&nbsp;i&nbsp;r&nbsp;where&nbsp;i&nbsp;x&nbsp;=&nbsp;x)&nbsp;--&nbsp;(pop&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br />
         <br />
         top&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;a<br />
         top&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(top&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br />
         </tt></td>
       </tr>
      </table>
     </div>

     <div align="center">
      <!--<h4>Figure 1</h4>-->
      <h4>図 1</h4>
     </div>

     <div align="center">
      <!--<h3>A sample program</h3>-->
      <h3>プログラム例</h3>
     <a name="layout-before"></a>
     <div align="center">
      <table border="2" cellpadding="3">
       <tr>
        <td> <tt><br />
         module&nbsp;AStack(&nbsp;Stack,&nbsp;push,&nbsp;pop,&nbsp;top,&nbsp;size&nbsp;)&nbsp;where<br />
         {data&nbsp;Stack&nbsp;a&nbsp;=&nbsp;Empty&nbsp;<br />
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;MkStack&nbsp;a&nbsp;(Stack&nbsp;a)<br />
         <br />
         ;push&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a<br />
         ;push&nbsp;x&nbsp;s&nbsp;=&nbsp;MkStack&nbsp;x&nbsp;s<br />
         <br />
         ;size&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Int<br />
         ;size&nbsp;s&nbsp;=&nbsp;length&nbsp;(stkToLst&nbsp;s)&nbsp;&nbsp;where<br />
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{stkToLst&nbsp;&nbsp;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br />
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;stkToLst&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;&nbsp;=&nbsp;x:xs&nbsp;where&nbsp;{xs&nbsp;=&nbsp;stkToLst&nbsp;s<br />
         <br />
         }};pop&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;(a,&nbsp;Stack&nbsp;a)<br />
         ;pop&nbsp;(MkStack&nbsp;x&nbsp;s)<br />
         &nbsp;&nbsp;=&nbsp;(x,&nbsp;case&nbsp;s&nbsp;of&nbsp;{r&nbsp;-&gt;&nbsp;i&nbsp;r&nbsp;where&nbsp;{i&nbsp;x&nbsp;=&nbsp;x}})&nbsp;--&nbsp;(pop&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br />
         <br />
         ;top&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;a<br />
         ;top&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(top&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br />
         }<br />
         </tt></td>
       </tr>
      </table>
     </div>

     <div align="center">
      <!--<h4>Figure 2</h4>-->
      <h4>図 2</h4>
     </div>

     <div align="center">
      <!--<h3>Sample program with layout expanded</h3>-->
      <h3>レイアウト展開したプログラム例</h3>
     </div>
     <a name="layout-after"></a>
     <p></p>
    </td>
   </tr>
  </table>
  <p></p>
  <hr />
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="intro.html">back</a> | <a
   href="exps.html">next</a> | <a href="index98.html">contents</a> | <a
   href="prelude-index.html">function index</a> <br />
   <font size="2">December 2002</font></p>
  <p></p>
 </body>
</html>
