<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=EUC-JP">
  <title>The Haskell 98 Library Report: Input/Output</title>
 </head>
 <body bgcolor="#ffffff">
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="monad.html">back</a> | <a
   href="directory.html">next</a> | <a href="index98.html">contents</a> |
   <a href="prelude-index.html">function index</a> <br />
  </p>
  <hr />
  <p><a name="IO"></a><a name="sect21"></a></p>
  <!--<h2>21<tt>&nbsp;&nbsp;</tt>Input/Output</h2>-->
  <h2>21<tt>&nbsp;&nbsp;</tt>入出力</h2>

  <p>
  <table border="2" cellpadding="3">
   <tr>
    <td> <tt><br />
     module&nbsp;IO&nbsp;(<br />
     &nbsp;&nbsp;&nbsp;&nbsp;Handle,&nbsp;HandlePosn,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),<br />
     &nbsp;&nbsp;&nbsp;&nbsp;BufferMode(NoBuffering,LineBuffering,BlockBuffering),<br />
     &nbsp;&nbsp;&nbsp;&nbsp;SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),<br />
     &nbsp;&nbsp;&nbsp;&nbsp;stdin,&nbsp;stdout,&nbsp;stderr,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;openFile,&nbsp;hClose,&nbsp;hFileSize,&nbsp;hIsEOF,&nbsp;isEOF,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hSetBuffering,&nbsp;hGetBuffering,&nbsp;hFlush,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hGetPosn,&nbsp;hSetPosn,&nbsp;hSeek,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hWaitForInput,&nbsp;hReady,&nbsp;hGetChar,&nbsp;hGetLine,&nbsp;hLookAhead,&nbsp;hGetContents,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hPutChar,&nbsp;hPutStr,&nbsp;hPutStrLn,&nbsp;hPrint,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hIsOpen,&nbsp;hIsClosed,&nbsp;hIsReadable,&nbsp;hIsWritable,&nbsp;hIsSeekable,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;isAlreadyExistsError,&nbsp;isDoesNotExistError,&nbsp;isAlreadyInUseError,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;isFullError,&nbsp;isEOFError,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;isIllegalOperation,&nbsp;isPermissionError,&nbsp;isUserError,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;ioeGetErrorString,&nbsp;ioeGetHandle,&nbsp;ioeGetFileName,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;try,&nbsp;bracket,&nbsp;bracket_,<br />
     <br />
     &nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;...and&nbsp;what&nbsp;the&nbsp;Prelude&nbsp;exports<br />
     &nbsp;&nbsp;&nbsp;&nbsp;IO,&nbsp;FilePath,&nbsp;IOError,&nbsp;ioError,&nbsp;userError,&nbsp;catch,&nbsp;interact,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;putChar,&nbsp;putStr,&nbsp;putStrLn,&nbsp;print,&nbsp;getChar,&nbsp;getLine,&nbsp;getContents,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;readFile,&nbsp;writeFile,&nbsp;appendFile,&nbsp;readIO,&nbsp;readLn<br />
     &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;where<br />
     <br />
     import&nbsp;Ix(Ix)<br />
     <br />
     data&nbsp;Handle&nbsp;=&nbsp;...
     --&nbsp;implementation-dependent<br />
     instance&nbsp;Eq&nbsp;Handle&nbsp;where&nbsp;...<br />
     instance&nbsp;Show&nbsp;Handle&nbsp;where&nbsp;..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;implementation-dependent<br />
     <br />
     data&nbsp;HandlePosn&nbsp;=&nbsp;...
     --&nbsp;implementation-dependent<br />
     instance&nbsp;Eq&nbsp;HandlePosn&nbsp;where&nbsp;...<br />
     instance&nbsp;Show&nbsp;HandlePosn&nbsp;where&nbsp;---&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;implementation-dependent<br />
     <br />
     <br />
     data&nbsp;IOMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;ReadMode&nbsp;|&nbsp;WriteMode&nbsp;|&nbsp;AppendMode&nbsp;|&nbsp;ReadWriteMode<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deriving&nbsp;(Eq,&nbsp;Ord,&nbsp;Ix,&nbsp;Bounded,&nbsp;Enum,&nbsp;Read,&nbsp;Show)<br />
     data&nbsp;BufferMode&nbsp;&nbsp;=&nbsp;&nbsp;NoBuffering&nbsp;|&nbsp;LineBuffering&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;BlockBuffering&nbsp;(Maybe&nbsp;Int)<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deriving&nbsp;(Eq,&nbsp;Ord,&nbsp;Read,&nbsp;Show)<br />
     data&nbsp;SeekMode&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;AbsoluteSeek&nbsp;|&nbsp;RelativeSeek&nbsp;|&nbsp;SeekFromEnd<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deriving&nbsp;(Eq,&nbsp;Ord,&nbsp;Ix,&nbsp;Bounded,&nbsp;Enum,&nbsp;Read,&nbsp;Show)<br />
     <br />
     stdin,&nbsp;stdout,&nbsp;stderr&nbsp;::&nbsp;Handle<br />
     <br />
     openFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;FilePath&nbsp;-&gt;&nbsp;IOMode&nbsp;-&gt;&nbsp;IO&nbsp;Handle<br />
     hClose&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     </tt></td>
   </tr>
  </table>
  </p>
  <p>
  <table border="2" cellpadding="3">
   <tr>
    <td> <tt><br />
     hFileSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Integer<br />
     hIsEOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     isEOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;Bool<br />
     isEOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;hIsEOF&nbsp;stdin<br />
     <br />
     hSetBuffering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;&nbsp;-&gt;&nbsp;BufferMode&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     hGetBuffering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;&nbsp;-&gt;&nbsp;IO&nbsp;BufferMode<br />
     hFlush&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;()&nbsp;<br />
     hGetPosn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;HandlePosn<br />
     hSetPosn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;HandlePosn&nbsp;-&gt;&nbsp;IO&nbsp;()&nbsp;<br />
     hSeek&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;SeekMode&nbsp;-&gt;&nbsp;Integer&nbsp;-&gt;&nbsp;IO&nbsp;()&nbsp;<br />
     <br />
     hWaitForInput
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;Int&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hReady&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool&nbsp;<br />
     hReady&nbsp;h
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;hWaitForInput&nbsp;h&nbsp;0<br />
     hGetChar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Char<br />
     hGetLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;String<br />
     hLookAhead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Char<br />
     hGetContents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;String<br />
     hPutChar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;Char&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     hPutStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;String&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     hPutStrLn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;String&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     hPrint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Show&nbsp;a&nbsp;=&gt;&nbsp;Handle&nbsp;-&gt;&nbsp;a&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     <br />
     hIsOpen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hIsClosed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hIsReadable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hIsWritable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hIsSeekable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     <br />
     isAlreadyExistsError&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isDoesNotExistError&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isAlreadyInUseError&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isFullError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isEOFError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isIllegalOperation&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isPermissionError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isUserError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     <br />
     ioeGetErrorString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;String<br />
     ioeGetHandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Maybe&nbsp;Handle<br />
     ioeGetFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Maybe&nbsp;FilePath<br />
     <br />
     try&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;IO&nbsp;(Either&nbsp;IOError&nbsp;a)<br />
     bracket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;c)&nbsp;-&gt;&nbsp;IO&nbsp;c<br />
     bracket_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;IO&nbsp;c&nbsp;-&gt;&nbsp;IO&nbsp;c<br />
     </tt></td>
   </tr>
  </table>
  </p>
  <!--
  <p> The monadic I/O system used in Haskell is described by the Haskell
   language report. Commonly used I/O functions such as <tt>print</tt> are
   part of the standard prelude and need not be explicitly imported. This
   library contain more advanced I/O features. Some related operations on
   file systems are contained in the <tt>Directory</tt> library.</p>
  -->
  <p>
   Haskell において用いられるモナド I/O システムについては、Haskell
   言語レポートで記述されている。<tt>print</tt> のように一般によく
   使われている I/O 関数は標準 Prelude の一部になっており、明示的に
   インポートする必要はない。このライブラリはより高度な I/O を
   含んでいる。ファイルシステム上の関連操作のいくつかは
   <tt>Directory</tt> ライブラリに含まれている。
  </p>

  <p><a name="IOError"></a></p>
  <p> <a name="sect21.1"></a></p>
  <!--<h3>21.1<tt>&nbsp;&nbsp;</tt>I/O Errors</h3>-->
  <h3>21.1<tt>&nbsp;&nbsp;</tt>I/O エラー</h3>
  <!--
  <p>Errors of type <tt>IOError</tt> are used by the I/O monad. This is an
   abstract type; the library provides functions to interrogate and
   construct values in <tt>IOError</tt>:</p>
  -->
  <p>
   型 <tt>IOError</tt> のエラーは I/O モナドで使われる。
   これは抽象型である。このライブラリでは <tt>IOError</tt> のなかの値を
   探ったり、そのなかに値を構築したりするための関数が供給されている。
  </p>
  <!--
  <ul>
   <li> <tt>isAlreadyExistsError </tt> -- the operation failed because one
    of its arguments already exists.</li>
   <li> <tt>isDoesNotExistError </tt> -- the operation failed because one
    of its arguments does not exist.</li>
   <li> <tt>isAlreadyInUseError </tt> -- the operation failed because one
    of its arguments is a single-use resource, which is already being used
    (for example, opening the same file twice for writing might give this
    error).</li>
   <li> <tt>isFullError </tt> -- the operation failed because the device is
    full.</li>
   <li> <tt>isEOFError </tt> -- the operation failed because the end of
    file has been reached.</li>
   <li> <tt>isIllegalOperation </tt> -- the operation is not possible.</li>
   <li> <tt>isPermissionError </tt> -- the operation failed because the
    user does not have sufficient operating system privilege to perform
    that operation.</li>
   <li> <tt>isUserError </tt> -- a programmer-defined error value has been
    raised using <tt>fail</tt>.</li>
  </ul>
  -->
  <p>
   <ul>
     <li><tt>isAlreadyExistsError</tt> -- 引数の一つがすでに存在していたので、
     この操作が失敗した。</li>
    <li><tt>isDoesNotExistError</tt> -- 引数の一つが存在していなかったので、
     この操作が失敗した。</li>
    <li><tt>isAlreadyInUseError</tt> -- 引数のひとつが一度だけ使えるリソー
     スでかつ、すでに使われていたので、操作が失敗した。(たとえば、同じファ
     イルを書きこみのために2度オープンしようとするとこのエラーになる。)
     </li>
    <li><tt>isFullError</tt> -- デバイスが満杯であったので、操作が失敗した。
     </li>
    <li><tt>isEOFError</tt> -- ファイルの最後に到達していたので、操作が失敗
     した。</li>
    <li><tt>isIllegalOperation</tt> -- この操作は不可能。
    <li><tt>isPermissionError</tt> -- 利用者がこの操作を実行するためのオペ
     レーティングシステム上の権限を持っていないので、操作が失敗した。
     </li>
    <li><tt>isUserError</tt> -- <tt>fail</tt> を使用したプログラマが定義し
     たエラーが起った。</li>
   </ul>
  </p>
  <!--
  <p>All these functions return a <tt>Bool</tt>, which is <tt>True</tt> if
   its argument is the corresponding kind of error, and <tt>False
   </tt>otherwise.</p>
  -->
  <p>
   これらの関数はどれも <tt>Bool</tt> 値を返す。その引数が対応する
   エラーであった場合には <tt>True</tt> を、さもなければ、
   <tt>False</tt> を返す。
  </p>
  <!--
  <p> Any computation which returns an <tt>IO</tt> result may fail with
   <tt>isIllegalOperation</tt>. Additional errors which could be raised by
   an implementation are listed after the corresponding operation. In some
   cases, an implementation will not be able to distinguish between the
   possible error causes. In this case it should return
   <tt>isIllegalOperation</tt>.</p>
  -->
  <p>
   <tt>IO</tt> 型の結果を返す計算はどれも <tt>isIllegalOperationError</tt> 
   で失敗する可能性がある。実装によって引き起こされうるエラーは
   対応する操作の後にリストアップしてある。場合によっては、実装が
   どのエラーが起ったかを判別できないこともある。その場合には 
   <tt>isIllegalOperationError</tt> のものを返さなければならない。
  </p>
  <!--
  <p> Three additional functions are provided to obtain information about
   an error value. These are <tt>ioeGetHandle</tt> which returns
   <tt>Just</tt> <i>hdl</i> if the error value refers to handle <i>hdl</i>
   and <tt>Nothing</tt> otherwise; <tt>ioeGetFileName</tt> which returns
   <tt>Just</tt> <i>name</i> if the error value refers to file <i>name</i>,
   and <tt>Nothing</tt> otherwise; and <tt>ioeGetErrorString</tt> which
   returns a string. For "user" errors (those which are raised using
   <tt>fail</tt>), the string returned by <tt>ioeGetErrorString</tt> is the
   argument that was passed to <tt>fail</tt>; for all other errors, the
   string is implementation-dependent.</p>
  -->
  <p>
   さらに、エラー値に関する情報を得るための関数が3つ用意されている。
   <tt>ioeGetHandle</tt> はエラー値がハンドル <I>hdl</I> を
   参照していれば、<tt>Just</tt> <I>hdl</I> を返し、さもなければ、
   <tt>Nothing</tt> を返す。<tt>ioeGetFileName</tt> はエラー値が
   ファイル <i>name</i> を参照していれば、<tt>Just</tt> <I>name</I>
   を返し、さもなければ、<tt>Nothing</tt> を返す。
   <tt>ioeGetErrorString</tt> は文字列を返す。(<tt>fail</tt> を用いて
   引き起こされた)利用者定義のエラーについては、
   <tt>ioeGetErrorString</tt> によって返される文字列が、<tt>fail</tt> 
   に渡された引数である。その他のエラーについての文字列は実装依存である。
  </p>
  <!--
  <p> The <tt>try</tt> function returns an error in a computation
   explicitly using the <tt>Either</tt> type.</p>
  -->
  <p>
   <tt>try</tt> 関数は計算のなかで明示的に <tt>Either</tt> 型を使って、
   エラーを返す。
  </p>
  <!--
  <p> The <tt>bracket</tt> function captures a common allocate, compute,
   deallocate idiom in which the deallocation step must occur even in the
   case of an error during computation. This is similar to
   try-catch-finally in Java.</p>
  -->
  <p>
   <tt>bracket</tt> 関数は、計算途中のエラーの場合でも、メモリ解放が
   必要になるような、よくあるメモリ確保、計算、メモリ解放の定型句を
   捕捉する。これは Java の try-catch-finally の機構に類似している。
  </p>

  <p> <a name="sect21.2"></a></p>
  <!--<h3>21.2<tt>&nbsp;&nbsp;</tt>Files and Handles</h3>-->
  <h3>21.2<tt>&nbsp;&nbsp;</tt>ファイルとハンドル</h3>
  <!--
  <p>Haskell interfaces to the external world through an abstract <i>file
   system</i>. This file system is a collection of named <i>file system
   objects</i>, which may be organised in <i>directories</i> (see
   <tt>Directory</tt>). In some implementations, directories may themselves
   be file system objects and could be entries in other directories. For
   simplicity, any non-directory file system object is termed a
   <i>file</i>, although it could in fact be a communication channel, or
   any other object recognised by the operating system. <i>Physical
   files</i> are persistent, ordered files, and normally reside on disk.</p>
  -->
  <p>
   Haskell の外界とのインタフェースは抽象的な<em>ファイルシステム</em>
   である。ここでいうファイルシステムとは名前の付いた
   <em>ファイルシステムオブジェクト</em>の集りであり、それらは、
   <em>ディレクトリ</em>にまとめられるものである
   (<tt>Directory</tt> を見よ)。実装によってはディレクトリ自身が
   ファイルシステムオブジェクトであり、また、別のディレクトリの
   エントリである場合もある。単純化するために、すべてのディレクトリでは
   ないファイルシステムオブジェクトを<em>ファイル</em>呼ぶことにしよう。
   実際には通信チャネルであったり、オペレーティングシステム上では
   別のものとして認識されることはあるけれども。<em>物理ファイル</em>
   は永続的で、順序付けられたファイルのことで、一般にはディスク上に
   置かれている。
  </p>
  <!--
  <p> File and directory names are values of type <tt>String</tt>, whose
   precise meaning is operating system dependent. Files can be opened,
   yielding a handle which can then be used to operate on the contents of
   that file.</p>
  -->
  <p>
   ファイルとディレクトリの名前は <tt>String</tt> 型の値である。
   その正確な意味はオペレーティングシステムに依存する。ファイルは
   オープンすることが可能で、その結果はハンドルであり、
   これを使ってファイルの内容を操作することができる。
  </p>
  <p><a name="Handles"></a></p>
  <!--
  <p> Haskell defines operations to read and write characters from and to
   files, represented by values of type <tt>Handle</tt>. Each value of this
   type is a <i>handle</i>: a record used by the Haskell run-time system to
   <i>manage</i> I/O with file system objects. A handle has at least the
   following properties:</p>
  -->
  <p>
   Haskell ではファイルからの文字の読み出し、ファイルへの
   文字の書き込み操作が定義されており、これは <tt>Handle</tt> 型の値で
   あらわされる。この型のそれぞれの値は<em>ハンドル</em>、
   すなわち Haskell の実行時システムがファイルシステムオブジェクトの
   入出力を<em>管理</em>するために使うものである。ハンドルは少なくとも
   以下の特性をもつ。
  </p>
  <!--
  <p>
  <ul>
   <li> whether it manages input or output or both;</li>
   <li> whether it is <i>open</i>, <i>closed</i> or <i>semi-closed</i>;</li>
   <li> whether the object is seekable;</li>
   <li> whether buffering is disabled, or enabled on a line or block basis;
    </li>
   <li> a buffer (whose length may be zero).</li>
  </ul>
  </p>
  -->
  <p>
   <ul>
    <li>入力あるいは出力あるいはその両方を管理し、</li>
    <li>オープンあるいはクローズあるいは半クローズの状態であり、</li>
    <li>シーク可能で</li>
    <li>行あるいはブロック単位で、バッファリング不可あるいは可能で</li>
    <li>バッファ(長さがゼロの場合もある)をもつ</li>
   </ul>
  </p>
  <!--
  <p> Most handles will also have a current I/O position indicating where
   the next input or output operation will occur. A handle is
   <i>readable</i> if it manages only input or both input and output;
   likewise, it is <i>writable</i> if it manages only output or both input
   and output. A handle is <i>open</i> when first allocated. Once it is
   closed it can no longer be used for either input or output, though an
   implementation cannot re-use its storage while references remain to it.
   Handles are in the <tt>Show</tt> and <tt>Eq</tt> classes. The string
   produced by showing a handle is system dependent; it should include
   enough information to identify the handle for debugging. A handle is
   equal according to <tt>==</tt> only to itself; no attempt is made to
   compare the internal state of different handles for equality.</p>
  -->
  <p>
   ほとんどの場合ハンドルは次の入出力操作がどこで起こるかを示す
   現在の入出力位置というものをもつ。ハンドルはもし入力だけ、あるいは
   入出力の両方を管理できるのであれば<em>読み込み可能</em>である。
   同様に、もし出力だけあるいは入出力の両方が管理できるのであれば
   <em>書きこみ可能</em>である。ハンドルは最初にアロケートされたときに
   オープンされている。一旦クローズされるとそれ移行、入力、出力ともに
   使えなくなる。これは、ハンドルへのリファレンスがたとえ残っていても、
   実装はそのストーレジを再利用できないということである。
   ハンドルは <tt>Show</tt> および <tt>Eq</tt> クラスである。
   ハンドル表示のための文字列はシステム依存である。その文字列には
   デバッグ用にハンドルを識別するのに十分な情報を含んでいる。
   ハンドルは、<tt>==</tt> に関して、自分自身でとのみ等しい。
   同値性に関して、別のハンドルと内部状態を比較するようなことはない。
  </p>

  <p><a name="StandardHandles"></a></p>
  <p> <a name="sect21.2.1"></a></p>
  <!--<h4>21.2.1<tt>&nbsp;&nbsp;</tt>Standard Handles</h4>-->
  <h4>21.2.1<tt>&nbsp;&nbsp;</tt>標準ハンドル</h4>
  <!--
  <p> Three handles are allocated during program initialisation. The first
   two (<tt>stdin</tt> and <tt>stdout</tt>) manage input or output from the
   Haskell program's standard input or output channel respectively. The
   third (<tt>stderr</tt>) manages output to the standard error channel.
   These handles are initially open.</p>
  -->
  <p>
   3 つのハンドルがプログラムの初期化中にアロケートされる。最初の二つ
   (<tt>stdin</tt> と <tt>stdout</tt>)はそれぞれ Haskell のプログラム
   での標準入力チャネルと標準出力チャネルを管理するものである。
   3 つめのもの(<tt>stderr</tt>)は標準エラーチャネルを管理するものである。
   この 3 つのハンドルは最初からオープンされている。
  </p>

  <a name="SemiClosed"></a>
  <p> <a name="sect21.2.2"></a></p>
  <!--<h4>21.2.2<tt>&nbsp;&nbsp;</tt>Semi-Closed Handles</h4>-->
  <h4>21.2.2<tt>&nbsp;&nbsp;</tt>ハンドルのセミクローズ</h4>
  <!--
  <p> The operation <tt>hGetContents</tt><i> hdl</i> (Section <a
   href="io.html#hGetContents">21.9.4</a>) puts a handle <i>hdl</i> into an
   intermediate state, <i>semi-closed</i>. In this state, <i>hdl</i> is
   effectively closed, but items are read from <i>hdl</i> on demand and
   accumulated in a special list returned by <tt>hGetContents</tt>
   <i>hdl</i>.</p>
  -->
  <p>
   操作 <tt>hGetContents</tt><i> hdl</i> 
   (<a href="io.html#hGetContents">21.9.4</a> 節)はハンドル <i>hdl</i>
   を中間状態<em>セミクローズ</em>状態にする。この状態では、<i>hdl</i> 
   は実質的にはクローズ状態であるが、<tt>hdl</tt> から必要に応じて
   読み込みをおこない、<tt>hGetContents</tt> <i>hdl</i> によって
   返される特別なリストに読み込んだものが蓄積される。
  </p>
  <!--
  <p> Any operation that fails because a handle is closed, also fails if a
   handle is semi-closed. The only exception is <tt>hClose</tt>. A
   semi-closed handle becomes closed:</p>
  -->
  <p>
   すべての操作はハンドルがクローズされていると失敗する。同様に
   ハンドルがセミクローズされていても失敗する。唯一の例外は、
   <tt>hClose</tt> である。セミクローズされたハンドルは以下の場合に
   クローズされる。
  </p>
  <!--
  <ul>
   <li> if <tt>hClose</tt> is applied to it;</li>
   <li> if an I/O error occurs when reading an item from the handle;</li>
   <li> or once the entire contents of the handle has been read.</li>
  </ul>
  -->
  <p>
   <ul>
    <li>そのハンドルに <tt>hClose</tt> が適用された場合<li>
    <li>そのハンドルからのデータを読み込み中に I/O エラーが起きた場合</li>
    <li>ハンドルから全内容が読み込まれたあと</li>
   </ul>
  </p>
  <!--
  <p> Once a semi-closed handle becomes closed, the contents of the
   associated list becomes fixed. The contents of this final list is only
   partially specified: it will contain at least all the items of the
   stream that were evaluated prior to the handle becoming closed.</p>
  -->
  <p>
  <p>
   セミクローズ状態のハンドルが一旦クローズされてしまうと、対応する
   リストの内容は固定される。この最終的なリストの内容は部分的に規定
   されているにすぎない。少くとも、ハンドルがクローズされるに先だって
   評価されたストリームのデータを含むことになる。
  </p>
  <!--
  <p> Any I/O errors encountered while a handle is semi-closed are simply
   discarded. </p>
  -->
  <p>
   ハンドルがセミクローズ状態にある場合に起きたあらゆる I/O エラー
   は単純に廃棄される。
  </p>
   
  <p><a name="sect21.2.3"></a></p>
  <!--<h4>21.2.3<tt>&nbsp;&nbsp;</tt>File locking</h4>-->
  <h4>21.2.3<tt>&nbsp;&nbsp;</tt>ファイルのロック</h4>
  <!--
  <p> Implementations should enforce as far as possible, at least locally
   to the Haskell process, multiple-reader single-writer locking on files.
   That is, <i>there may either be many handles on the same file which
   manage input, or just one handle on the file which manages output</i>.
   If any open or semi-closed handle is managing a file for output, no new
   handle can be allocated for that file. If any open or semi-closed handle
   is managing a file for input, new handles can only be allocated if they
   do not manage output. Whether two files are the same is
   implementation-dependent, but they should normally be the same if they
   have the same absolute path name and neither has been renamed, for
   example.</p>
  -->
  <p>
   実装ではできうるかぎり、Haskell のプロセス内では、ファイルに対しては
   読み込み多重、書きこみは 1 つだけというロック機構を実現しなければ
   ならない。したがって、<em>同じファイルに対して入力管理用に複数の
   ハンドルが存在する可能性があり、出力管理用には一つのファイルには
   一つのハンドルしか存在しない</em>。もし、出力用にハンドルがオープン
   された状態あるいはセミクローズの状態である場合には、そのファイルに
   対してはハンドルをアロケートすることだけはできるが、
   そのハンドルで出力を管理することはできない。二つのファイルが同じで
   あるかどうかは実装依存であるが、たとえば、ふつう、同じ絶対パス名を
   もち、リネームされていなければ、同じであるべきである。
  </p>
  <!--
  <p> <i>Warning</i>: the <tt>readFile</tt> operation (Section <a
   href="io-13.html#standard-io-functions">7.1</a>) holds a semi-closed
   handle on the file until the entire contents of the file have been
   consumed. It follows that an attempt to write to a file (using
   <tt>writeFile</tt>, for example) that was earlier opened by
   <tt>readFile</tt> will usually result in failure with
   <tt>isAlreadyInUseError</tt>.</p>
  -->
  <p>
   <em>警告：</em> <tt>readFile</tt> 操作
   (<a href="io-13.html#standard-io-functions">7.1</a> 節)は、
   当該ファイルのすべてのコンテンツが消費されてしまわないうちは
   セミクローズされたハンドルを保持する。その結果として、先に
   <tt>readFile</tt> でオープンされたファイルに(たとえば、
   <tt>writeFile</tt> を使って)書き込もうとすると通常、
   <tt>isAlreadyInUseError</tt> となって失敗することになるだろ。
  </p>

  <p><a name="OpeningClosing"></a></p>
  <p> <a name="sect21.3"></a></p>
  <!--<h3>21.3<tt>&nbsp;&nbsp;</tt>Opening and Closing Files</h3>-->
  <h3>21.3<tt>&nbsp;&nbsp;</tt>ファイルのオープンとクローズ</h3>
  <p><a name="Opening"></a></p>
  <p> <a name="sect21.3.1"></a></p>

  <!--<h4>21.3.1<tt>&nbsp;&nbsp;</tt>Opening Files</h4>-->
  <h4>21.3.1<tt>&nbsp;&nbsp;</tt>ファイルのオープン</h4>
  <!--
  <p> Computation <tt>openFile</tt> <i>file</i> <i>mode</i> allocates and
   returns a new, open handle to manage the file <i>file</i>. It manages
   input if <i>mode</i> is <tt>ReadMode</tt>, output if <i>mode</i> is
   <tt>WriteMode</tt> or <tt>AppendMode</tt>, and both input and output if
   mode is <tt>ReadWriteMode</tt>.</p>
  -->
  <p>
   計算 <tt>openFile</tt> <I>file</I> <I>mode</I> はファイル <i>file</i>
   を管理するための新しいオープンされたハンドルをアロケートしそれを返す。
   このハンドルは <i>mode</i> が <tt>ReadMode</tt> であれば入力用であり、
   <i>mode</i> が <tt>WriteMode</tt> あるいは <tt>AppendMode</tt> 
   であれば出力用であり、<i>mode</i> が <tt>ReadWriteMode</tt> ならば
   入出力両用である。
  </p>
  <!--
  <p> If the file does not exist and it is opened for output, it should be
   created as a new file. If <i>mode</i> is <tt>WriteMode</tt> and the file
   already exists, then it should be truncated to zero length. Some
   operating systems delete empty files, so there is no guarantee that the
   file will exist following an <tt>openFile</tt> with <i>mode</i>
   <tt>WriteMode</tt> unless it is subsequently written to successfully.
   The handle is positioned at the end of the file if <i>mode</i> is
   <tt>AppendMode</tt>, and otherwise at the beginning (in which case its
   internal I/O position is 0). The initial buffer mode is
   implementation-dependent.</p>
  -->
  <p>
   もし、ファイルが存在せず、出力用にオープンされれば新にファイルが
   作成される。もし、<i>mode</i> が <tt>WriteMode</tt> でファイルが
   すでに存在していれば、そのファイルは長さゼロに丸められる。
   オペレーティングシステムによっては空のファイルを消去するものも
   あるので、ファイルが <i>mode</i> <tt>WriteMode</tt> で 
   <tt>openFile</tt> された後に書きこみが成功しなかった場合、
   そのファイルが相変わらず存在していることは保証されない。
   ファイルがもし、<tt>AppendMode</tt> でオープンされた場合には
   ハンドルの位置はファイルの最後にあり、それ以外の場合は先頭
   (この場合には内部的な I/O 位置が 0 )にある。初期のバッファモードは
   実装依存である。
  </p>
  <!--
  <p> If <tt>openFile</tt> fails on a file opened for output, the file may
   still have been created if it did not already exist.</p>
  -->
  <p>
   もし、<tt>openFile</tt> が出力ファイルのオープンに失敗した場合でも、
   そのファイルが存在しなければ、新たに作成される。
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>openFile</tt> computation may fail
   with <tt>isAlreadyInUseError</tt> if the file is already open and cannot
   be reopened; <tt>isDoesNotExistError</tt> if the file does not exist; or
   <tt>isPermissionError</tt> if the user does not have permission to open
   the file.</p>
  -->
  <p>
   <em>エラー報告：</em><tt>openFile</tt> の計算はもしファイルが
   既にオープンされていて再オープンできなければ、
   <tt>isAlreadyInUseError</tt> となって失敗し、ファイルが存在しなければ
   <tt>isDoesNotExistError</tt>、ファイルをオープンする権限を
   ユーザがもたなければ、<tt>isPermissionError</tt>となる。
  </p>

  <p><a name="Closing"></a></p>
  <p> <a name="sect21.3.2"></a></p>

  <!--<h4>21.3.2<tt>&nbsp;&nbsp;</tt>Closing Files</h4>-->
  <h4>21.3.2<tt>&nbsp;&nbsp;</tt>ファイルのクローズ</h4>

  <!--
  <p> Computation <tt>hClose</tt> <i>hdl</i> makes handle <i>hdl</i>
   closed. Before the computation finishes, if <i>hdl</i> is writable its
   buffer is flushed as for <tt>hFlush</tt>. Performing <tt>hClose</tt> on
   a handle that has already been closed has no effect; doing so not an
   error. All other operations on a closed handle will fail. If
   <tt>hClose</tt> fails for any reason, any further operations (apart from
   <tt>hClose</tt>) on the handle will still fail as if <i>hdl</i> had been
   successfully closed.</p>
  -->
  <p>
   <tt>hClose</tt> <i>hdl</i> という計算はハンドル <i>hdl</i> を
   クローズする。この計算が終了する前に、もし、<i>hdl</i> が書きこみ
   可能であれば、そのバッファは <tt>hFlush</tt> を使うのと同様に
   フラッシュされる。<tt>hClose</tt> をすでにクローズされたハンドルに
   実行しても、何もおこらず、エラーにもならない。クローズされた
   ハンドルへのそれ以外の操作は失敗する。もし、<tt>hClose</tt>が、
   なんらかの理由で失敗したら、それ以上の(<tt>hClose</tt>以外の)
   オペレーションは <i>hdl</i> が正しくクローズされた場合と同様に
   失敗する。
  </p>

  <p><a name="FileSize"></a></p>
  <p> <a name="sect21.4"></a></p>
  <!--<h3>21.4<tt>&nbsp;&nbsp;</tt>Determining the Size of a File</h3>-->
  <h3>21.4<tt>&nbsp;&nbsp;</tt>ファイルサイズの決定</h3>
  <!--
  <p> For a handle <i>hdl</i> which is attached to a physical file,
   <tt>hFileSize </tt><i>hdl</i> returns the size of that file in 8-bit
   bytes (<i>&gt;=</i> 0).</p>
  -->
  <p>
   物理的なファイルに結び付けられたハンドル <i>hdl</i> に対して、
   <tt>hFileSize</tt> <i>hdl</i> はファイルの大きさを 8-bit バイトで返す
   (<i>&gt;=</i> 0)。
  </p>
 
  <p><a name="EOF"></a></p>
  <p> <a name="sect21.5"></a></p>

  <!--<h3>21.5<tt>&nbsp;&nbsp;</tt>Detecting the End of Input</h3>-->
  <h3>21.5<tt>&nbsp;&nbsp;</tt>入力終端の検出</h3>
  <!--
  <p> For a readable handle <i>hdl</i>, computation <tt>hIsEOF</tt>
   <i>hdl</i> returns <tt>True </tt>if no further input can be taken from
   <i>hdl</i>; for a handle attached to a physical file this means that the
   current I/O position is equal to the length of the file. Otherwise, it
   returns <tt>False</tt>. The computation <tt>isEOF</tt> is identical,
   except that it works only on <tt>stdin</tt>.</p>
  -->
  <p>
   読み出し可能なハンドル <i>hdl</i> に対し、計算 <tt>hIsEOF</tt>
   <i>hdl</i> は、<i>hdl</i> からこれ以上入力を取り出せない場合には
   <tt>True</tt> を返す。このことは、物理的なファイルに結び付けられた
   ハンドルについて言えば、現在の入出力位置がそのファイルの長さに等しい
   ということである。もし、終端でなければ、<tt>False</tt> が返る。
   計算 <tt>isEOF</tt> は <tt>stdin</tt> 上でのみ動作するということを
   除けば、同一の計算である。
  </p>

  <p><a name="Buffering"></a></p>
  <p> <a name="sect21.6"></a></p>
  <!--<h3>21.6<tt>&nbsp;&nbsp;</tt>Buffering Operations</h3>-->
  <h3>21.6<tt>&nbsp;&nbsp;</tt>バッファリング操作</h3>
  <!--
  <p> Three kinds of buffering are supported: line-buffering,
   block-buffering or no-buffering. These modes have the following effects.
   For output, items are written out, or <i>flushed</i>, from the internal
   buffer according to the buffer mode:</p>
  -->
  <p>
   3 種類のバッファリングがサポートされている。行バッファリング、
   ブロックバッファリング、バッファリングなし、である。これらのモードは
   以下の効果がある。出力に関しては、項目は内部バッファからその
   バッファモードに応じて書き出されるか、あるいは<em>フラッシュされる
   </em>。
  </p>
  <!--
  <ul>
   <li> <b>line-buffering: </b>the entire buffer is flushed whenever a
    newline is output, the buffer overflows, a <tt>hFlush</tt> is issued,
    or the handle is closed.</li>

   <li> <b>block-buffering: </b>the entire buffer is written out whenever
    it overflows, a <tt>hFlush</tt> is issued, or the handle is closed.</li>

   <li> <b>no-buffering: </b>output is written immediately, and never
    stored in the buffer.</li>
  </ul>
  -->
  <p>
   <ul>
    <li>
     <b>行バッファリング：</b>次のことが起こるたびにバッファ全体が
     フラッシュされる。改行が出力された。バッファがオーバーフローした。
     <tt>hFlush</tt>が発行された。ハンドルがクローズされた。</li>
    <li>
     <b>ブロックバッファリング：</b>次のことが起こるたびにバッファ全体が
     書き出される。バッファがオーバーフローした。<tt>hFlush</tt> が
     発行された。ハンドルがクローズされた。</li>
    <li><b>バッファリングなし：</b>出力は直ちに書き出され、
     バッファに格納されることはない。</li>
   </ul>
  </p>
  <!--
  <p>An implementation is free to flush the buffer more frequently, but not
   less frequently, than specified above. The buffer is emptied as soon as
   it has been written out.</p>
  -->
  <p>
   実装は上での規定よりも頻繁にバッファをフラッシュしてもよい。しかし、
   上の規定以下の頻度にしてはならない。バッファは書き出しが済むとすぐに
   空にされる。
  </p>
  <!--
  <p> Similarly, input occurs according to the buffer mode for handle
   <i>hdl</i>.</p>
  -->
  <p>
   同様にして、入力はそのハンドル <i>hdl</i> のバッファモードに
   したがって起こる。
  </p>
  <!--
  <ul>
   <li> <b>line-buffering: </b>when the buffer for <i>hdl</i> is not empty,
    the next item is obtained from the buffer; otherwise, when the buffer
    is empty, characters are read into the buffer until the next newline
    character is encountered or the buffer is full. No characters are
    available until the newline character is available or the buffer is
    full.</li>
   <li> <b>block-buffering:</b> when the buffer for <i>hdl</i> becomes
    empty, the next block of data is read into the buffer.</li>
   <li> <b>no-buffering:</b> the next input item is read and returned. The
    <tt>hLookAhead</tt> operation (Section <a
    href="io.html#hLookAhead">21.9.3</a>) implies that even a no-buffered
    handle may require a one-character buffer.</li>
  </ul>
  -->
  <p>
   <ul>
    <li><b>行バッファリング：</b><i>hdl</i> に対応するバッファが
     空でない場合、次の項目がバッファから読み込まれる。空であった場合、
     改行文字がくるか、バッファがフルになるまで、バッファに読み込まれる。
     改行文字が有効になるか、バッファがフルになるまでは、入力文字は
     有効にならない。</li>
    <li><b>ブロックバッファリング：</b><i>hdl</i> に対応するバッファが
     空になったとき、つぎのブロックがバッファに読み込まれる。</li>
    <li><b>バッファリングなし：</b>次の入力が読み込まれ返される。
     <tt>hLookAhead</tt> 操作</li>
     (<a href="io.html#hLookAhead">21.9.3</a>節) はたとえバッファリング
     なしモードのハンドルであっても一文字分のバッファが必要であることを
     示している。
   </ul>
  </p>
  <!--
  <p> For most implementations, physical files will normally be
   block-buffered and terminals will normally be line-buffered.</p>
  -->
  <p>
   大多数の実装では、物理的なファイルはふつうブロックバッファリング
   モードで操作し、ターミナルは行バッファリングモードで操作する。
  </p>
  <!--
  <p> Computation <tt>hSetBuffering</tt> <i>hdl</i> <i>mode</i> sets the
   mode of buffering for handle <i>hdl</i> on subsequent reads and writes.</p>
  -->
  <p>
   計算 <tt>hSetBuffering</tt> <i>hdl</i> <i>mode</i> はハンドル <i>hdl</i>
   のその後の読み書きのバッファリングモードを設定する。
  </p>
  <!--
  <ul>
   <li> If <i>mode</i> is <tt>LineBuffering</tt>, line-buffering is enabled
    if possible.</li>

   <li> If <i>mode</i> is <tt>BlockBuffering</tt> <i>size</i>, then
    block-buffering is enabled if possible. The size of the buffer is
    <i>n</i> items if <i>size</i> is <tt>Just&nbsp;</tt><i>n</i> and is
    otherwise implementation-dependent.</li>

   <li> If <i>mode</i> is <tt>NoBuffering</tt>, then buffering is disabled
    if possible.</li>
  </ul>
  -->
  <p>
   <ul>
    <li>もし、<i>mode</i> が <tt>LineBuffering</tt> である場合、
    可能でなら行バッファリングが有効になる。</li>
    <li>もし、<i>mode</i> が <tt>BlockBuffering</tt> <i>size</i>
    である場合、可能ならブロックバッファリングが有効になる。
    バッファのサイズは、<i>size</i> が <tt>Just&nbsp;</tt> <i>n</i>
    である場合、 <i>n</i> 単位であり、さもなければ、実装依存である。</li>
    <li>もし、<i>mode</i> が <tt>NoBuffering</tt> である場合、可能ならば、
     バッファリングは無効になる。</li>
   </ul>
  </p>
  <!--
  <p> If the buffer mode is changed from <tt>BlockBuffering</tt> or
   <tt>LineBuffering</tt> to <tt>NoBuffering</tt>, then</p>
  -->
  <p>
   もし、バッファモードが <tt>BlockBuffering</tt> または、
   <tt>LineBuffering</tt> から <tt>NoBuffering</tt> へ変更された場合、
  </p>
  <!--
  <ul>
   <li> if <i>hdl</i> is writable, the buffer is flushed as for
    <tt>hFlush</tt>;</li>
   <li> if <i>hdl</i> is not writable, the contents of the buffer is
    discarded.</li>
  </ul>
  -->
  <p>
   <ul>
    <li><i>hdl</i> が書きこみ可能であれば、<tt>hFlush</tt> を使用する
     のと同様にバッファはフラッシュされる。</li>
    <li><i>hdl</i> が書きこみ不可であれば、バッファの内容は破棄される。</li>
   </ul>
  </p>
  <!--  
  <p> <i>Error reporting</i>: the <tt>hSetBuffering</tt> computation may
   fail with <tt>isPermissionError</tt> if the handle has already been used
   for reading or writing and the implementation does not allow the
   buffering mode to be changed.</p>
  -->
  <p>
   <em>エラー報告：</em>もし、ハンドルがすでに読み込み、あるいは
   書き出し用に使用されていて、かつ、バッファリングモードの変更を
   許さないように実装されている場合には、<tt>hSetBuffering</tt> 計算は 
   <tt>isPermissionError</tt> となり失敗する。
  </p>
  <!--
  <p> Computation <tt>hGetBuffering</tt> <i>hdl</i> returns the current
   buffering mode for <i>hdl</i>.</p>
  -->
  <p>
   計算 <tt>hGetBuffering</tt> <i>hdl</i> は <i>hdl</i> の現在の
   バッファリングモードを返す。
  </p>
  <!--
  <p> The default buffering mode when a handle is opened is
   implementation-dependent and may depend on the file system object which
   is attached to that handle.</p>
  -->
  <p>
   ハンドルがオープンされたときのデフォルトのバッファリングモードは
   実装依存であり、ハンドルが割り当てられたファイルシステムオブジェクト
   に依存する。
  </p>

  <p><a name="Flushing"></a></p>
  <p> <a name="sect21.6.1"></a></p>
  <!--<h4>21.6.1<tt>&nbsp;&nbsp;</tt>Flushing Buffers</h4>-->
  <h4>21.6.1<tt>&nbsp;&nbsp;</tt>バッファのフラッシュ</h4>
  <!--
  <p> Computation <tt>hFlush</tt> <i>hdl</i> causes any items buffered for
   output in handle <i>hdl</i> to be sent immediately to the operating
   system.</p>
  -->
  <p>
   計算 <tt>hFlush</tt> <i>hdl</i> はハンドル <i>hdl</i> の
   出力バッファの全ての内容を直ちにオペレーティングシステムへ送りこむ。
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hFlush</tt> computation may fail
   with: <tt>isFullError</tt> if the device is full;
   <tt>isPermissionError</tt> if a system resource limit would be exceeded.
   It is unspecified whether the characters in the buffer are discarded or
   retained under these circumstances.</p>
  -->
  <p>
   <em>エラー報告：</em>もし、デバイスがフルであれば <tt>hFlush</tt> 
   計算は <tt>isFullError</tt> となり、システムリソースの制限を
   超えた場合は <tt>isPermissionError</tt> となって失敗する。
   バッファ内の文字が破棄されるか、そのままの状態になるかは規定されていない。
  </p>

  <p><a name="Seeking"></a></p>
  <p> <a name="sect21.7"></a></p>
  <!--<h3>21.7<tt>&nbsp;&nbsp;</tt>Repositioning Handles</h3>-->
  <h3>21.7<tt>&nbsp;&nbsp;</tt>ハンドルの再配置</h3>

  <p> <a name="sect21.7.1"></a></p>
  <!--<h4>21.7.1<tt>&nbsp;&nbsp;</tt>Revisiting an I/O Position</h4>-->
  <h4>21.7.1<tt>&nbsp;&nbsp;</tt>I/O 位置の再訪</h4>
  <!--
  <p> Computation <tt>hGetPosn</tt> <i>hdl</i> returns the current I/O
   position of <i>hdl</i> as a value of the abstract type
   <tt>HandlePosn</tt>. If a call to <tt>hGetPosn</tt><i> h</i> returns a
   position <i>p</i>, then computation <tt>hSetPosn</tt> <i>p</i> sets the
   position of <i>h</i> to the position it held at the time of the call to
   <tt>hGetPosn</tt>.</p>
  -->
  <p>
   計算 <tt>hGetPosn</tt> <i>hdl</i> は <i>hdl</i> の現在の I/O 位置を
   抽象データ型 <tt>HandlePosn</tt> の値として返す。もし、
   <tt>hGetPosn</tt> <i>h</i> の呼び出しが位置 <i>p</i> を返したら、
   計算<tt>hSetPosn</tt> <i>p</i> は <i>h</i> の位置を
   <tt>hGetPosn</tt> が呼び出された時の位置に設定する。
  </p>  
  <!--
  <p> <i>Error reporting</i>: the <tt>hSetPosn</tt> computation may fail
   with: <tt>isPermissionError</tt> if a system resource limit would be
   exceeded.</p>
  -->
  <p>
   <em>エラー報告：</em>もし、システムリソースの制限を超えたら、計算 
   <tt>hSetPosn</tt> は <tt>isPermissionError</tt> となり失敗する。
  </p>

  <p> <a name="sect21.7.2"></a></p>
  <!--<h4>21.7.2<tt>&nbsp;&nbsp;</tt>Seeking to a new Position</h4>-->
  <h4>21.7.2<tt>&nbsp;&nbsp;</tt>新しい位置へのシーク</h4>
  <!--
  <p> Computation <tt>hSeek</tt> <i>hdl</i> <i>mode</i> <i>i</i> sets the
   position of handle <i>hdl</i> depending on <i>mode</i>. If <i>mode</i>
   is:</p>
  -->
  <p>
   計算 <tt>hSeek</tt> <i>hdl</i> <i>mode</i> <i>i</i> はハンドル 
   <i>hdl</i> の位置を <i>mode</i> にしたがって設定する。
   もし <i>mode</i> が
  </p>
  <!--
  <ul>
   <li> <tt>AbsoluteSeek</tt>: the position of <i>hdl</i> is set to
    <i>i</i>.</li>

   <li> <tt>RelativeSeek</tt>: the position of <i>hdl</i> is set to offset
    <i>i</i> from the current position.</li>

   <li> <tt>SeekFromEnd</tt>: the position of <i>hdl</i> is set to offset
    <i>i</i> from the end of the file.</li>
  </ul>
  -->
  <p>
   <ul>
    <li><tt>AbsoluteSeek</tt> : ならば、<i>hdl</i> の位置は <i>i</i> に設定
     される。</li>
    <li><tt>RelativeSeek</tt> : ならば、<i>hdl</i> の位置は現在の位置から
        オフセット <i>i</i> の位置に設定される。</li>
    <li><tt>SeekFromEnd</tt> : ならば、<i>hdl</i> の位置はファイルの終端から
	オフセット <i>i</i> の位置に設定される。</li>
   </ul>
  </p>
  <!--
  <p>The offset is given in terms of 8-bit bytes.</p>
  -->
  <p>
   オフセットは 8-bit バイトで与えられる。
  </p>
  <!--
  <p> If <i>hdl</i> is block- or line-buffered, then seeking to a position
   which is not in the current buffer will first cause any items in the
   output buffer to be written to the device, and then cause the input
   buffer to be discarded. Some handles may not be seekable (see
   <tt>hIsSeekable</tt>), or only support a subset of the possible
   positioning operations (for instance, it may only be possible to seek to
   the end of a tape, or to a positive offset from the beginning or current
   position). It is not possible to set a negative I/O position, or for a
   physical file, an I/O position beyond the current end-of-file.</p>
  -->
  <p>
   もし、<i>hdl</i> がブロックバッファリングモードあるいはライン
   バッファリングモードなら、現在のバッファ内にない位置へのシークを
   行うと、まず、出力バッファ内にあるデータをすべてデバイスに
   書き出し、そのあと、入力バッファを破棄する。一部のハンドルは
   シーク不可能な場合がある( <tt>hIsSeekable</tt>の項を見よ)。または、
   可能な位置どり操作のみをサポートする場合(たとえば、テープの最後に
   のみ位置どりをすることが可能であるとか、先頭の位置あるいは現在
   位置からのオフセットでのみ位置どりができるということ)もある。
   負のI/O位置を設定するのは不可能である。また、物理的なファイルに
   対して現在の終端を超える位置どりも不可能である。
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hSeek</tt> computation may fail with:
   <tt>isPermissionError</tt> if a system resource limit would be
   exceeded.</p>
  -->
  <p>
   <em>エラー報告：</em> <tt>hSeek</tt> 計算はシステムの資源限界を
   超えると <tt>isPerissionError</tt> で失敗する。
  </p>

  <p><a name="Query"></a></p>
  <p> <a name="sect21.8"></a></p>

  <!--  <h3>21.8<tt>&nbsp;&nbsp;</tt>Handle Properties</h3>-->
  <h3>21.8<tt>&nbsp;&nbsp;</tt>ハンドルの性質</h3>
  <!--
  <p> The functions <tt>hIsOpen</tt>, <tt>hIsClosed</tt>,
   <tt>hIsReadable</tt>, <tt>hIsWritable</tt> and <tt>hIsSeekable
   </tt>return information about the properties of a handle. Each of these
   returns <tt>True</tt> if the handle has the specified property, and
   <tt>False</tt> otherwise.</p>
  -->
  <p>
   関数
   <tt>hIsOpen</tt>、 
   <tt>hIsClosed</tt>、
   <tt>hIsReadable</tt>、
   <tt>hIsWritable</tt> および
   <tt>hIsSeekable</tt>
   はハンドルの性質に関する情報を返す。これらの関数はハンドルが、
   指定の性質をもつなら <tt>True</tt> を返し、そうでなければ、
   <tt>False</tt> を返す。
  </p>

  <p> <a name="sect21.9"></a></p>
  <!--<h3>21.9<tt>&nbsp;&nbsp;</tt>Text Input and Output</h3>-->
  <h3>21.9<tt>&nbsp;&nbsp;</tt>テキスト入出力</h3>
  <!--
  <p> Here we define a standard set of input operations for reading
   characters and strings from text files, using handles. Many of these
   functions are generalizations of Prelude functions. I/O in the Prelude
   generally uses <tt>stdin</tt> and <tt>stdout</tt>; here, handles are
   explicitly specified by the I/O operation.</p>
  -->
  <p>
   ここで、テキストファイルからハンドルを用いて文字あるいは文字列を
   読み出すための標準の入力操作群を定義する。これらの関数の多くは
   プレリュードにある関数の一般化したものである。プレリュードのI/O関数は
   ほとんどが、<tt>stdin</tt> および <tt>stdout</tt> を使うものであるが、
   ここでは、ハンドルが明示的にI/O操作によって指定されている。
  </p>
  <p><a name="hReady"></a></p>
  <p> <a name="sect21.9.1"></a></p>
  <!--<h4>21.9.1<tt>&nbsp;&nbsp;</tt>Checking for Input</h4>-->
  <h4>21.9.1<tt>&nbsp;&nbsp;</tt>入力のためのチェック</h4>
  <p><a name="hWaitForInput"></a></p>
  <!--
  <p> Computation <tt>hWaitForInput</tt> <i>hdl</i> <i>t</i> waits until
   input is available on handle <i>hdl</i>. It returns <tt>True</tt> as
   soon as input is available on <i>hdl</i>, or <tt>False</tt> if no input
   is available within <i>t</i> milliseconds.</p>
  -->
  <p>
   <tt>hWaitForInput</tt> <i>hdl</i> <i>t</i> の計算はハンドル <i>hdl</i> 
   上で入力が利用可能になるのを待ち合わせる。この関数はハンドル <i>hdl</i> 
   上で入力が利用可能になりしだい <tt>True</tt> を返す。もし <i>t</i> ミリ
   秒以内に入力が利用可能にならなければ、<tt>False</tt> を返す。
  </p>
  <!--
  <p> Computation <tt>hReady</tt> <i>hdl</i> indicates whether at least one
   item is available for input from handle <i>hdl</i>.</p>
  -->
  <p>
   <tt>hReady</tt> <i>hdl</i> の計算はすなくとも 1 つの項目がハンドル 
   <i>hdl</i> で利用可能になっているかどうかを表示する。
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hWaitForInput</tt> and
   <tt>hReady</tt> computations fail with <tt>isEOFError</tt> if the end of
   file has been reached.</p>
  -->
  <p>
   <em>エラー報告：</em> <tt>hWaitForInput</tt>、<tt>hReady</tt> の計算は、
   ファイルの終端に到達していると <tt>isEOFError</tt> で失敗する。
  </p>

  <p> <a name="sect21.9.2"></a></p>
  <!--<h4>21.9.2<tt>&nbsp;&nbsp;</tt>Reading Input</h4>-->
  <h4>21.9.2<tt>&nbsp;&nbsp;</tt>入力の読み込み</h4>
  <!--
  <p> Computation <tt>hGetChar</tt> <i>hdl</i> reads a character from the
   file or channel managed by <i>hdl</i>.</p>
  -->
  <p>
   <tt>hGetChar</tt> <i>hdl</i> 計算は <i>hdl</i> により管理されている
   ファイルあるいはチャネルから一文字読み出す。
  </p>
  <!--
  <p> Computation <tt>hGetLine</tt> <i>hdl</i> reads a line from the file
   or channel managed by <i>hdl</i>. The Prelude's <tt>getLine</tt> is a
   shorthand for <tt>hGetLine&nbsp;stdin</tt>.</p>
  -->
  <p>
   <tt>hGetLine</tt> <i>hdl</i> 計算は <i>hdl</i> により管理されている
   ファイルあるいはチャネルから一行読み出す。プレリュード中の 
   <tt>getLine</tt> は <tt>hGetLine&nbsp;stdin</tt> との省略形である。
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hGetChar</tt> computation fails with
   <tt>isEOFError</tt> if the end of file has been reached. The
   <tt>hGetLine</tt> computation fails with <tt>isEOFError</tt> if the end
   of file is encountered when reading the <i>first</i> character of the
   line. If <tt>hGetLine</tt> encounters end-of-file at any other point
   while reading in a line, it is treated as a line terminator and the
   (partial) line is returned.</p>
  -->
  <p>
   <em>エラー報告：</em> <tt>hGetContents</tt> 計算は、ファイルの終端に
   到達していれば、<tt>isEOFError</tt> で失敗する。<tt>hGetLine</tt>
   計算は、行の最初の文字を読んだときに、ファイル終端に出会えば、
   <tt>isEOFError</tt> で失敗する。<tt>hGetLine</tt> がそれ以外の
   場所でファイル終端に出会えば、それを行の終端として扱い、その
   (部分)行を返す。
  </p>
  <p><a name="hLookAhead"></a></p>
  <p> <a name="sect21.9.3"></a></p>

  <!--<h4>21.9.3<tt>&nbsp;&nbsp;</tt>Reading Ahead</h4>-->
  <h4>21.9.3<tt>&nbsp;&nbsp;</tt>先読み</h4>
  <!--
  <p> Computation <tt>hLookAhead</tt> <i>hdl</i> returns the next character
   from handle <i>hdl</i> without removing it from the input buffer,
   blocking until a character is available.</p>
  -->
  <p>
   <tt>hLookAhead</tt> <i>hdl</i> の計算はハンドル <i>hdl</i> から
   次の一文字を読み出すが、それを入力バッファから取り除かない。また、
   一文字利用可能になるまで、ブロックする。
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hLookAhead</tt> computation may fail
   with: <tt>isEOFError</tt> if the end of file has been reached.</p>
  -->
  <p>
   <em>エラー報告：</em>
   <tt>hLookahead</tt> 計算は、ファイルの終端に到達していると
   <tt>isEOFError</tt> で失敗する。
  </p>

  <p><a name="hGetContents"></a></p>
  <p> <a name="sect21.9.4"></a></p>
  <!--<h4>21.9.4<tt>&nbsp;&nbsp;</tt>Reading The Entire Input</h4>-->
  <h4>21.9.4<tt>&nbsp;&nbsp;</tt>入力全体の読み込み</h4>
  <!--
  <p> Computation <tt>hGetContents</tt> <i>hdl</i> returns the list of
   characters corresponding to the unread portion of the channel or file
   managed by <i>hdl</i>, which is made semi-closed.</p>
  -->
  <p>
   <tt>hGetContents</tt> <i>hdl</i> 計算は <i>hdl</i> により
   管理されているファイルあるいはチャネルの未読部分にある文字の
   リストを返し、ハンドルをセミクローズする。
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hGetContents</tt> computation may
   fail with: <tt>isEOFError</tt> if the end of file has been reached.</p>
  -->
  <p>
   <em>エラー報告：</em>
   <tt>hGetContents</tt> 計算は、ファイルの終端に到達していれば、
   <tt>isEOFError</tt> で失敗する。
  </p>
  <p> <a name="sect21.9.5"></a></p>
  <!--<h4>21.9.5<tt>&nbsp;&nbsp;</tt>Text Output</h4>-->
  <h4>21.9.5<tt>&nbsp;&nbsp;</tt>テキスト出力</h4>
  <!--
  <p> Computation <tt>hPutChar</tt> <i>hdl</i> <i>c</i> writes the
   character <i>c</i> to the file or channel managed by <i>hdl</i>.
   Characters may be buffered if buffering is enabled for <i>hdl</i>.</p>
  -->
  <p>
   <tt>hPutChar</tt> <i>hdl</i> <i>c</i> 計算は文字 <i>c</i> を <i>hdl</i> 
   で管理されているファイルあるいはチャネルに書き込む。<i>hdl</i> に対して
   バッファリングが可能になっていれば、文字はバッファに蓄えられる。
  </p>
  <!--
  <p> Computation <tt>hPutStr</tt> <i>hdl</i> <i>s</i> writes the string
   <i>s</i> to the file or channel managed by <i>hdl</i>.</p>
  --> 
  <p>
   <tt>hPutStr</tt> <i>hdl</i> <i>s</i> 計算は文字列 <i>s</i> を 
   <i>hdl</i> で管理されているファイルあるいはチャネルに書き込む。
  </p>
  <!--
  <p> Computation <tt>hPrint</tt> <i>hdl</i> <i>t</i> writes the string
   representation of <i>t </i>given by the <tt>shows</tt> function to the
   file or channel managed by <i>hdl</i> and appends a newline.</p>
  -->
  <p>
   <tt>hPrint</tt> <i>hdl</i> <i>t</i> 計算は <tt>shows</tt> 関数で
   あたえられる <i>t</i> を表現する文字列を<i>hdl</i> 
   で管理されているファイルあるいはチャネルに書き込み、改行を追加する。
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hPutChar</tt>, <tt>hPutStr</tt> and
   <tt>hPrint</tt> computations may fail with:
   <tt>isFull</tt>-<tt>Error</tt> if the device is full; or
   <tt>isPermissionError</tt> if another system resource limit would be
   exceeded.</p>
  -->
  <p>
   <em>エラー報告：</em>
   <tt>hPutChar</tt>、<tt>hPutStr</tt> および <tt>hPrint</tt> の
   計算はデバイスがフルであれば <tt>isFull</tt>-<tt>Error</tt> で失敗し、
   別のシステム資源の制限を超えると <tt>isPermissionError</tt> で失敗する。
  </p>

  <p> <a name="sect21.10"></a></p>
  <!--<h3>21.10<tt>&nbsp;&nbsp;</tt>Examples</h3>-->
  <h3>21.10<tt>&nbsp;&nbsp;</tt>例</h3>
  <!--
  <p> Here are some simple examples to illustrate Haskell I/O.</p>
  -->
  <p>Haskell の入出力を説明するためにいくつか例をあげよう。</p>

  <p> <a name="sect21.10.1"></a></p>
  <h4>21.10.1<tt>&nbsp;&nbsp;</tt>二つの数の和</h4>
  <!--
  <p> This program reads and sums two <tt>Integer</tt>s.
  -->
  <p> このプログラムは読み込んだ二つの <tt>Integer</tt>の和を計算する
   <tt><br />
   <br />
   import&nbsp;IO<br />
   <br />
   main&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hSetBuffering&nbsp;stdout&nbsp;NoBuffering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;&nbsp;&nbsp;"Enter&nbsp;an&nbsp;integer:&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x1&nbsp;&lt;-&nbsp;readNum&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;&nbsp;&nbsp;"Enter&nbsp;another&nbsp;integer:&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x2&nbsp;&lt;-&nbsp;readNum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;&nbsp;("Their&nbsp;sum&nbsp;is&nbsp;"&nbsp;++&nbsp;show&nbsp;(x1+x2)&nbsp;++&nbsp;"\n")<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where&nbsp;readNum&nbsp;::&nbsp;IO&nbsp;Integer<br />
   --&nbsp;Providing&nbsp;a&nbsp;type&nbsp;signature&nbsp;avoids&nbsp;reliance&nbsp;on<br />
   --&nbsp;the&nbsp;defaulting&nbsp;rule&nbsp;to&nbsp;fix&nbsp;the&nbsp;type&nbsp;of&nbsp;x1,x2<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readNum&nbsp;=&nbsp;readLn<br />
   <br />
   </tt></p>
  
  <p> <a name="sect21.10.2"></a></p>
  <!--<h4>21.10.2<tt>&nbsp;&nbsp;</tt>Copying Files</h4>-->
  <h4>21.10.2<tt>&nbsp;&nbsp;</tt>ファイルのコピー</h4>
  <!--
  <p> A simple program to create a copy of a file, with all lower-case
   characters translated to upper-case. This program will not allow a file
   to be copied to itself. This version uses character-level I/O. Note that
   exactly two arguments must be supplied to the program. 
  -->
  <p>
   ファイルの複製を作る単純なプログラムで、すべての小文字は大文字に
   変換される。このプログラムは自分自身へのコピーは許さない。
   このバージョンでは文字レベルの入出力を使う。必ず、プログラムへは
   引数を二つ与えなければならないことに注意せよ。
   <tt><br />
   <br />
   import&nbsp;IO<br />
   import&nbsp;System<br />
   import&nbsp;Char(&nbsp;toUpper&nbsp;)<br />
   <br />
   main&nbsp;=&nbsp;do&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f1,f2]&nbsp;&lt;-&nbsp;getArgs<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h1&nbsp;&lt;-&nbsp;openFile&nbsp;f1&nbsp;ReadMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h2&nbsp;&lt;-&nbsp;openFile&nbsp;f2&nbsp;WriteMode&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyFile&nbsp;h1&nbsp;h2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hClose&nbsp;h1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hClose&nbsp;h2<br />
   <br />
   copyFile&nbsp;h1&nbsp;h2&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eof&nbsp;&lt;-&nbsp;hIsEOF&nbsp;h1<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;eof&nbsp;then&nbsp;return&nbsp;()&nbsp;else<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&lt;-&nbsp;hGetChar&nbsp;h1<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hPutChar&nbsp;h2&nbsp;(toUpper&nbsp;c)&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyFile&nbsp;h1&nbsp;h2<br />
   <br />
   </tt></p>
  <!--
  <p> An equivalent but much shorter version, using string I/O is:
  -->
  <p> 文字列の入出力を用いた同等のずっと短いバージョンは以下のとおり。
   <tt><br />
   <br />
   import&nbsp;System<br />
   import&nbsp;Char(&nbsp;toUpper&nbsp;)<br />
   <br />
   main&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f1,f2]&nbsp;&lt;-&nbsp;getArgs<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;&lt;-&nbsp;readFile&nbsp;f1<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeFile&nbsp;f2&nbsp;(map&nbsp;toUpper&nbsp;s)<br />
   <br />
   </tt></p>

  <p> <a name="sect21.11"></a></p>
  <!--<h3>21.11<tt>&nbsp;&nbsp;</tt>Library <tt>IO</tt></h3>-->
  <h3>21.11<tt>&nbsp;&nbsp;</tt><tt>IO</tt> ライブラリ</h3>
  <p>
   <tt>module&nbsp;IO&nbsp;{-&nbsp;export&nbsp;list&nbsp;omitted&nbsp;-}&nbsp;where<br />
   <br />
   --&nbsp;Just&nbsp;provide&nbsp;an&nbsp;implementation&nbsp;of&nbsp;the&nbsp;system-independent<br />
   --&nbsp;actions&nbsp;that&nbsp;IO&nbsp;exports.<br />
   <br />
   try&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;IO&nbsp;(Either&nbsp;IOError&nbsp;a)<br />
   try&nbsp;f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;catch&nbsp;(do&nbsp;r&nbsp;&lt;-&nbsp;f<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(Right&nbsp;r))<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(return&nbsp;.&nbsp;Left)<br />
   <br />
   bracket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;c)&nbsp;-&gt;&nbsp;IO&nbsp;c<br />
   bracket&nbsp;before&nbsp;after&nbsp;m&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&lt;-&nbsp;before<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rs&nbsp;&lt;-&nbsp;try&nbsp;(m&nbsp;x)<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after&nbsp;x<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;rs&nbsp;of<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;r&nbsp;-&gt;&nbsp;return&nbsp;r<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;&nbsp;e&nbsp;-&gt;&nbsp;ioError&nbsp;e<br />
   <br />
   --&nbsp;variant&nbsp;of&nbsp;the&nbsp;above&nbsp;where&nbsp;middle&nbsp;computation&nbsp;doesn't&nbsp;want&nbsp;x<br />
   bracket_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;IO&nbsp;c&nbsp;-&gt;&nbsp;IO&nbsp;c<br />
   bracket_&nbsp;before&nbsp;after&nbsp;m&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&lt;-&nbsp;before<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rs&nbsp;&lt;-&nbsp;try&nbsp;m<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after&nbsp;x<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;rs&nbsp;of<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;r&nbsp;-&gt;&nbsp;return&nbsp;r<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;&nbsp;e&nbsp;-&gt;&nbsp;ioError&nbsp;e<br />
   </tt></p>

  <hr />

  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="monad.html">back</a> | <a
   href="directory.html">next</a> | <a href="index98.html">contents</a> |
   <a href="prelude-index.html">function index</a> <br />
   <font size="2">December 2002</font></p>
 </body>
</html>
