<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=EUC-JP">
  <title>The Haskell 98 Library Report: Input/Output</title>
 </head>
 <body bgcolor="#ffffff">
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="monad.html">back</a> | <a
   href="directory.html">next</a> | <a href="index98.html">contents</a> |
   <a href="prelude-index.html">function index</a> <br />
  </p>
  <hr />
  <p><a name="IO"></a><a name="sect21"></a></p>
  <!--<h2>21<tt>&nbsp;&nbsp;</tt>Input/Output</h2>-->
  <h2>21<tt>&nbsp;&nbsp;</tt>Æþ½ÐÎÏ</h2>

  <p>
  <table border="2" cellpadding="3">
   <tr>
    <td> <tt><br />
     module&nbsp;IO&nbsp;(<br />
     &nbsp;&nbsp;&nbsp;&nbsp;Handle,&nbsp;HandlePosn,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),<br />
     &nbsp;&nbsp;&nbsp;&nbsp;BufferMode(NoBuffering,LineBuffering,BlockBuffering),<br />
     &nbsp;&nbsp;&nbsp;&nbsp;SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),<br />
     &nbsp;&nbsp;&nbsp;&nbsp;stdin,&nbsp;stdout,&nbsp;stderr,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;openFile,&nbsp;hClose,&nbsp;hFileSize,&nbsp;hIsEOF,&nbsp;isEOF,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hSetBuffering,&nbsp;hGetBuffering,&nbsp;hFlush,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hGetPosn,&nbsp;hSetPosn,&nbsp;hSeek,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hWaitForInput,&nbsp;hReady,&nbsp;hGetChar,&nbsp;hGetLine,&nbsp;hLookAhead,&nbsp;hGetContents,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hPutChar,&nbsp;hPutStr,&nbsp;hPutStrLn,&nbsp;hPrint,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;hIsOpen,&nbsp;hIsClosed,&nbsp;hIsReadable,&nbsp;hIsWritable,&nbsp;hIsSeekable,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;isAlreadyExistsError,&nbsp;isDoesNotExistError,&nbsp;isAlreadyInUseError,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;isFullError,&nbsp;isEOFError,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;isIllegalOperation,&nbsp;isPermissionError,&nbsp;isUserError,&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;ioeGetErrorString,&nbsp;ioeGetHandle,&nbsp;ioeGetFileName,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;try,&nbsp;bracket,&nbsp;bracket_,<br />
     <br />
     &nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;...and&nbsp;what&nbsp;the&nbsp;Prelude&nbsp;exports<br />
     &nbsp;&nbsp;&nbsp;&nbsp;IO,&nbsp;FilePath,&nbsp;IOError,&nbsp;ioError,&nbsp;userError,&nbsp;catch,&nbsp;interact,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;putChar,&nbsp;putStr,&nbsp;putStrLn,&nbsp;print,&nbsp;getChar,&nbsp;getLine,&nbsp;getContents,<br />
     &nbsp;&nbsp;&nbsp;&nbsp;readFile,&nbsp;writeFile,&nbsp;appendFile,&nbsp;readIO,&nbsp;readLn<br />
     &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;where<br />
     <br />
     import&nbsp;Ix(Ix)<br />
     <br />
     data&nbsp;Handle&nbsp;=&nbsp;...
     --&nbsp;implementation-dependent<br />
     instance&nbsp;Eq&nbsp;Handle&nbsp;where&nbsp;...<br />
     instance&nbsp;Show&nbsp;Handle&nbsp;where&nbsp;..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;implementation-dependent<br />
     <br />
     data&nbsp;HandlePosn&nbsp;=&nbsp;...
     --&nbsp;implementation-dependent<br />
     instance&nbsp;Eq&nbsp;HandlePosn&nbsp;where&nbsp;...<br />
     instance&nbsp;Show&nbsp;HandlePosn&nbsp;where&nbsp;---&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;implementation-dependent<br />
     <br />
     <br />
     data&nbsp;IOMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;ReadMode&nbsp;|&nbsp;WriteMode&nbsp;|&nbsp;AppendMode&nbsp;|&nbsp;ReadWriteMode<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deriving&nbsp;(Eq,&nbsp;Ord,&nbsp;Ix,&nbsp;Bounded,&nbsp;Enum,&nbsp;Read,&nbsp;Show)<br />
     data&nbsp;BufferMode&nbsp;&nbsp;=&nbsp;&nbsp;NoBuffering&nbsp;|&nbsp;LineBuffering&nbsp;<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;BlockBuffering&nbsp;(Maybe&nbsp;Int)<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deriving&nbsp;(Eq,&nbsp;Ord,&nbsp;Read,&nbsp;Show)<br />
     data&nbsp;SeekMode&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;AbsoluteSeek&nbsp;|&nbsp;RelativeSeek&nbsp;|&nbsp;SeekFromEnd<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deriving&nbsp;(Eq,&nbsp;Ord,&nbsp;Ix,&nbsp;Bounded,&nbsp;Enum,&nbsp;Read,&nbsp;Show)<br />
     <br />
     stdin,&nbsp;stdout,&nbsp;stderr&nbsp;::&nbsp;Handle<br />
     <br />
     openFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;FilePath&nbsp;-&gt;&nbsp;IOMode&nbsp;-&gt;&nbsp;IO&nbsp;Handle<br />
     hClose&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     </tt></td>
   </tr>
  </table>
  </p>
  <p>
  <table border="2" cellpadding="3">
   <tr>
    <td> <tt><br />
     hFileSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Integer<br />
     hIsEOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     isEOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;Bool<br />
     isEOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;hIsEOF&nbsp;stdin<br />
     <br />
     hSetBuffering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;&nbsp;-&gt;&nbsp;BufferMode&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     hGetBuffering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;&nbsp;-&gt;&nbsp;IO&nbsp;BufferMode<br />
     hFlush&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;()&nbsp;<br />
     hGetPosn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;HandlePosn<br />
     hSetPosn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;HandlePosn&nbsp;-&gt;&nbsp;IO&nbsp;()&nbsp;<br />
     hSeek&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;SeekMode&nbsp;-&gt;&nbsp;Integer&nbsp;-&gt;&nbsp;IO&nbsp;()&nbsp;<br />
     <br />
     hWaitForInput
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;Int&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hReady&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool&nbsp;<br />
     hReady&nbsp;h
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;hWaitForInput&nbsp;h&nbsp;0<br />
     hGetChar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Char<br />
     hGetLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;String<br />
     hLookAhead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Char<br />
     hGetContents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;String<br />
     hPutChar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;Char&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     hPutStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;String&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     hPutStrLn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;String&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     hPrint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Show&nbsp;a&nbsp;=&gt;&nbsp;Handle&nbsp;-&gt;&nbsp;a&nbsp;-&gt;&nbsp;IO&nbsp;()<br />
     <br />
     hIsOpen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hIsClosed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hIsReadable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hIsWritable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     hIsSeekable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;Handle&nbsp;-&gt;&nbsp;IO&nbsp;Bool<br />
     <br />
     isAlreadyExistsError&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isDoesNotExistError&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isAlreadyInUseError&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isFullError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isEOFError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isIllegalOperation&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isPermissionError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     isUserError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Bool<br />
     <br />
     ioeGetErrorString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;String<br />
     ioeGetHandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Maybe&nbsp;Handle<br />
     ioeGetFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IOError&nbsp;-&gt;&nbsp;Maybe&nbsp;FilePath<br />
     <br />
     try&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;IO&nbsp;(Either&nbsp;IOError&nbsp;a)<br />
     bracket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;c)&nbsp;-&gt;&nbsp;IO&nbsp;c<br />
     bracket_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;IO&nbsp;c&nbsp;-&gt;&nbsp;IO&nbsp;c<br />
     </tt></td>
   </tr>
  </table>
  </p>
  <!--
  <p> The monadic I/O system used in Haskell is described by the Haskell
   language report. Commonly used I/O functions such as <tt>print</tt> are
   part of the standard prelude and need not be explicitly imported. This
   library contain more advanced I/O features. Some related operations on
   file systems are contained in the <tt>Directory</tt> library.</p>
  -->
  <p>
   Haskell ¤Ë¤ª¤¤¤ÆÍÑ¤¤¤é¤ì¤ë¥â¥Ê¥É I/O ¥·¥¹¥Æ¥à¤Ë¤Ä¤¤¤Æ¤Ï¡¢Haskell
   ¸À¸ì¥ì¥Ý¡¼¥È¤Çµ­½Ò¤µ¤ì¤Æ¤¤¤ë¡£<tt>print</tt> ¤Î¤è¤¦¤Ë°ìÈÌ¤Ë¤è¤¯
   »È¤ï¤ì¤Æ¤¤¤ë I/O ´Ø¿ô¤ÏÉ¸½à Prelude ¤Î°ìÉô¤Ë¤Ê¤Ã¤Æ¤ª¤ê¡¢ÌÀ¼¨Åª¤Ë
   ¥¤¥ó¥Ý¡¼¥È¤¹¤ëÉ¬Í×¤Ï¤Ê¤¤¡£¤³¤Î¥é¥¤¥Ö¥é¥ê¤Ï¤è¤ê¹âÅÙ¤Ê I/O ¤ò
   ´Þ¤ó¤Ç¤¤¤ë¡£¥Õ¥¡¥¤¥ë¥·¥¹¥Æ¥à¾å¤Î´ØÏ¢Áàºî¤Î¤¤¤¯¤Ä¤«¤Ï
   <tt>Directory</tt> ¥é¥¤¥Ö¥é¥ê¤Ë´Þ¤Þ¤ì¤Æ¤¤¤ë¡£
  </p>

  <p><a name="IOError"></a></p>
  <p> <a name="sect21.1"></a></p>
  <!--<h3>21.1<tt>&nbsp;&nbsp;</tt>I/O Errors</h3>-->
  <h3>21.1<tt>&nbsp;&nbsp;</tt>I/O ¥¨¥é¡¼</h3>
  <!--
  <p>Errors of type <tt>IOError</tt> are used by the I/O monad. This is an
   abstract type; the library provides functions to interrogate and
   construct values in <tt>IOError</tt>:</p>
  -->
  <p>
   ·¿ <tt>IOError</tt> ¤Î¥¨¥é¡¼¤Ï I/O ¥â¥Ê¥É¤Ç»È¤ï¤ì¤ë¡£
   ¤³¤ì¤ÏÃê¾Ý·¿¤Ç¤¢¤ë¡£¤³¤Î¥é¥¤¥Ö¥é¥ê¤Ç¤Ï <tt>IOError</tt> ¤Î¤Ê¤«¤ÎÃÍ¤ò
   Ãµ¤Ã¤¿¤ê¡¢¤½¤Î¤Ê¤«¤ËÃÍ¤ò¹½ÃÛ¤·¤¿¤ê¤¹¤ë¤¿¤á¤Î´Ø¿ô¤¬¶¡µë¤µ¤ì¤Æ¤¤¤ë¡£
  </p>
  <!--
  <ul>
   <li> <tt>isAlreadyExistsError </tt> -- the operation failed because one
    of its arguments already exists.</li>
   <li> <tt>isDoesNotExistError </tt> -- the operation failed because one
    of its arguments does not exist.</li>
   <li> <tt>isAlreadyInUseError </tt> -- the operation failed because one
    of its arguments is a single-use resource, which is already being used
    (for example, opening the same file twice for writing might give this
    error).</li>
   <li> <tt>isFullError </tt> -- the operation failed because the device is
    full.</li>
   <li> <tt>isEOFError </tt> -- the operation failed because the end of
    file has been reached.</li>
   <li> <tt>isIllegalOperation </tt> -- the operation is not possible.</li>
   <li> <tt>isPermissionError </tt> -- the operation failed because the
    user does not have sufficient operating system privilege to perform
    that operation.</li>
   <li> <tt>isUserError </tt> -- a programmer-defined error value has been
    raised using <tt>fail</tt>.</li>
  </ul>
  -->
  <p>
   <ul>
     <li><tt>isAlreadyExistsError</tt> -- °ú¿ô¤Î°ì¤Ä¤¬¤¹¤Ç¤ËÂ¸ºß¤·¤Æ¤¤¤¿¤Î¤Ç¡¢
     ¤³¤ÎÁàºî¤¬¼ºÇÔ¤·¤¿¡£</li>
    <li><tt>isDoesNotExistError</tt> -- °ú¿ô¤Î°ì¤Ä¤¬Â¸ºß¤·¤Æ¤¤¤Ê¤«¤Ã¤¿¤Î¤Ç¡¢
     ¤³¤ÎÁàºî¤¬¼ºÇÔ¤·¤¿¡£</li>
    <li><tt>isAlreadyInUseError</tt> -- °ú¿ô¤Î¤Ò¤È¤Ä¤¬°ìÅÙ¤À¤±»È¤¨¤ë¥ê¥½¡¼
     ¥¹¤Ç¤«¤Ä¡¢¤¹¤Ç¤Ë»È¤ï¤ì¤Æ¤¤¤¿¤Î¤Ç¡¢Áàºî¤¬¼ºÇÔ¤·¤¿¡£(¤¿¤È¤¨¤Ð¡¢Æ±¤¸¥Õ¥¡
     ¥¤¥ë¤ò½ñ¤­¤³¤ß¤Î¤¿¤á¤Ë2ÅÙ¥ª¡¼¥×¥ó¤·¤è¤¦¤È¤¹¤ë¤È¤³¤Î¥¨¥é¡¼¤Ë¤Ê¤ë¡£)
     </li>
    <li><tt>isFullError</tt> -- ¥Ç¥Ð¥¤¥¹¤¬ËþÇÕ¤Ç¤¢¤Ã¤¿¤Î¤Ç¡¢Áàºî¤¬¼ºÇÔ¤·¤¿¡£
     </li>
    <li><tt>isEOFError</tt> -- ¥Õ¥¡¥¤¥ë¤ÎºÇ¸å¤ËÅþÃ£¤·¤Æ¤¤¤¿¤Î¤Ç¡¢Áàºî¤¬¼ºÇÔ
     ¤·¤¿¡£</li>
    <li><tt>isIllegalOperation</tt> -- ¤³¤ÎÁàºî¤ÏÉÔ²ÄÇ½¡£
    <li><tt>isPermissionError</tt> -- ÍøÍÑ¼Ô¤¬¤³¤ÎÁàºî¤ò¼Â¹Ô¤¹¤ë¤¿¤á¤Î¥ª¥Ú
     ¥ì¡¼¥Æ¥£¥ó¥°¥·¥¹¥Æ¥à¾å¤Î¸¢¸Â¤ò»ý¤Ã¤Æ¤¤¤Ê¤¤¤Î¤Ç¡¢Áàºî¤¬¼ºÇÔ¤·¤¿¡£
     </li>
    <li><tt>isUserError</tt> -- <tt>fail</tt> ¤ò»ÈÍÑ¤·¤¿¥×¥í¥°¥é¥Þ¤¬ÄêµÁ¤·
     ¤¿¥¨¥é¡¼¤¬µ¯¤Ã¤¿¡£</li>
   </ul>
  </p>
  <!--
  <p>All these functions return a <tt>Bool</tt>, which is <tt>True</tt> if
   its argument is the corresponding kind of error, and <tt>False
   </tt>otherwise.</p>
  -->
  <p>
   ¤³¤ì¤é¤Î´Ø¿ô¤Ï¤É¤ì¤â <tt>Bool</tt> ÃÍ¤òÊÖ¤¹¡£¤½¤Î°ú¿ô¤¬ÂÐ±þ¤¹¤ë
   ¥¨¥é¡¼¤Ç¤¢¤Ã¤¿¾ì¹ç¤Ë¤Ï <tt>True</tt> ¤ò¡¢¤µ¤â¤Ê¤±¤ì¤Ð¡¢
   <tt>False</tt> ¤òÊÖ¤¹¡£
  </p>
  <!--
  <p> Any computation which returns an <tt>IO</tt> result may fail with
   <tt>isIllegalOperation</tt>. Additional errors which could be raised by
   an implementation are listed after the corresponding operation. In some
   cases, an implementation will not be able to distinguish between the
   possible error causes. In this case it should return
   <tt>isIllegalOperation</tt>.</p>
  -->
  <p>
   <tt>IO</tt> ·¿¤Î·ë²Ì¤òÊÖ¤¹·×»»¤Ï¤É¤ì¤â <tt>isIllegalOperationError</tt> 
   ¤Ç¼ºÇÔ¤¹¤ë²ÄÇ½À­¤¬¤¢¤ë¡£¼ÂÁõ¤Ë¤è¤Ã¤Æ°ú¤­µ¯¤³¤µ¤ì¤¦¤ë¥¨¥é¡¼¤Ï
   ÂÐ±þ¤¹¤ëÁàºî¤Î¸å¤Ë¥ê¥¹¥È¥¢¥Ã¥×¤·¤Æ¤¢¤ë¡£¾ì¹ç¤Ë¤è¤Ã¤Æ¤Ï¡¢¼ÂÁõ¤¬
   ¤É¤Î¥¨¥é¡¼¤¬µ¯¤Ã¤¿¤«¤òÈ½ÊÌ¤Ç¤­¤Ê¤¤¤³¤È¤â¤¢¤ë¡£¤½¤Î¾ì¹ç¤Ë¤Ï 
   <tt>isIllegalOperationError</tt> ¤Î¤â¤Î¤òÊÖ¤µ¤Ê¤±¤ì¤Ð¤Ê¤é¤Ê¤¤¡£
  </p>
  <!--
  <p> Three additional functions are provided to obtain information about
   an error value. These are <tt>ioeGetHandle</tt> which returns
   <tt>Just</tt> <i>hdl</i> if the error value refers to handle <i>hdl</i>
   and <tt>Nothing</tt> otherwise; <tt>ioeGetFileName</tt> which returns
   <tt>Just</tt> <i>name</i> if the error value refers to file <i>name</i>,
   and <tt>Nothing</tt> otherwise; and <tt>ioeGetErrorString</tt> which
   returns a string. For "user" errors (those which are raised using
   <tt>fail</tt>), the string returned by <tt>ioeGetErrorString</tt> is the
   argument that was passed to <tt>fail</tt>; for all other errors, the
   string is implementation-dependent.</p>
  -->
  <p>
   ¤µ¤é¤Ë¡¢¥¨¥é¡¼ÃÍ¤Ë´Ø¤¹¤ë¾ðÊó¤òÆÀ¤ë¤¿¤á¤Î´Ø¿ô¤¬3¤ÄÍÑ°Õ¤µ¤ì¤Æ¤¤¤ë¡£
   <tt>ioeGetHandle</tt> ¤Ï¥¨¥é¡¼ÃÍ¤¬¥Ï¥ó¥É¥ë <I>hdl</I> ¤ò
   »²¾È¤·¤Æ¤¤¤ì¤Ð¡¢<tt>Just</tt> <I>hdl</I> ¤òÊÖ¤·¡¢¤µ¤â¤Ê¤±¤ì¤Ð¡¢
   <tt>Nothing</tt> ¤òÊÖ¤¹¡£<tt>ioeGetFileName</tt> ¤Ï¥¨¥é¡¼ÃÍ¤¬
   ¥Õ¥¡¥¤¥ë <i>name</i> ¤ò»²¾È¤·¤Æ¤¤¤ì¤Ð¡¢<tt>Just</tt> <I>name</I>
   ¤òÊÖ¤·¡¢¤µ¤â¤Ê¤±¤ì¤Ð¡¢<tt>Nothing</tt> ¤òÊÖ¤¹¡£
   <tt>ioeGetErrorString</tt> ¤ÏÊ¸»úÎó¤òÊÖ¤¹¡£(<tt>fail</tt> ¤òÍÑ¤¤¤Æ
   °ú¤­µ¯¤³¤µ¤ì¤¿)ÍøÍÑ¼ÔÄêµÁ¤Î¥¨¥é¡¼¤Ë¤Ä¤¤¤Æ¤Ï¡¢
   <tt>ioeGetErrorString</tt> ¤Ë¤è¤Ã¤ÆÊÖ¤µ¤ì¤ëÊ¸»úÎó¤¬¡¢<tt>fail</tt> 
   ¤ËÅÏ¤µ¤ì¤¿°ú¿ô¤Ç¤¢¤ë¡£¤½¤ÎÂ¾¤Î¥¨¥é¡¼¤Ë¤Ä¤¤¤Æ¤ÎÊ¸»úÎó¤Ï¼ÂÁõ°ÍÂ¸¤Ç¤¢¤ë¡£
  </p>
  <!--
  <p> The <tt>try</tt> function returns an error in a computation
   explicitly using the <tt>Either</tt> type.</p>
  -->
  <p>
   <tt>try</tt> ´Ø¿ô¤Ï·×»»¤Î¤Ê¤«¤ÇÌÀ¼¨Åª¤Ë <tt>Either</tt> ·¿¤ò»È¤Ã¤Æ¡¢
   ¥¨¥é¡¼¤òÊÖ¤¹¡£
  </p>
  <!--
  <p> The <tt>bracket</tt> function captures a common allocate, compute,
   deallocate idiom in which the deallocation step must occur even in the
   case of an error during computation. This is similar to
   try-catch-finally in Java.</p>
  -->
  <p>
   <tt>bracket</tt> ´Ø¿ô¤Ï¡¢·×»»ÅÓÃæ¤Î¥¨¥é¡¼¤Î¾ì¹ç¤Ç¤â¡¢¥á¥â¥ê²òÊü¤¬
   É¬Í×¤Ë¤Ê¤ë¤è¤¦¤Ê¡¢¤è¤¯¤¢¤ë¥á¥â¥ê³ÎÊÝ¡¢·×»»¡¢¥á¥â¥ê²òÊü¤ÎÄê·¿¶ç¤ò
   ÊáÂª¤¹¤ë¡£¤³¤ì¤Ï Java ¤Î try-catch-finally ¤Îµ¡¹½¤ËÎà»÷¤·¤Æ¤¤¤ë¡£
  </p>

  <p> <a name="sect21.2"></a></p>
  <!--<h3>21.2<tt>&nbsp;&nbsp;</tt>Files and Handles</h3>-->
  <h3>21.2<tt>&nbsp;&nbsp;</tt>¥Õ¥¡¥¤¥ë¤È¥Ï¥ó¥É¥ë</h3>
  <!--
  <p>Haskell interfaces to the external world through an abstract <i>file
   system</i>. This file system is a collection of named <i>file system
   objects</i>, which may be organised in <i>directories</i> (see
   <tt>Directory</tt>). In some implementations, directories may themselves
   be file system objects and could be entries in other directories. For
   simplicity, any non-directory file system object is termed a
   <i>file</i>, although it could in fact be a communication channel, or
   any other object recognised by the operating system. <i>Physical
   files</i> are persistent, ordered files, and normally reside on disk.</p>
  -->
  <p>
   Haskell ¤Î³°³¦¤È¤Î¥¤¥ó¥¿¥Õ¥§¡¼¥¹¤ÏÃê¾ÝÅª¤Ê<em>¥Õ¥¡¥¤¥ë¥·¥¹¥Æ¥à</em>
   ¤Ç¤¢¤ë¡£¤³¤³¤Ç¤¤¤¦¥Õ¥¡¥¤¥ë¥·¥¹¥Æ¥à¤È¤ÏÌ¾Á°¤ÎÉÕ¤¤¤¿
   <em>¥Õ¥¡¥¤¥ë¥·¥¹¥Æ¥à¥ª¥Ö¥¸¥§¥¯¥È</em>¤Î½¸¤ê¤Ç¤¢¤ê¡¢¤½¤ì¤é¤Ï¡¢
   <em>¥Ç¥£¥ì¥¯¥È¥ê</em>¤Ë¤Þ¤È¤á¤é¤ì¤ë¤â¤Î¤Ç¤¢¤ë
   (<tt>Directory</tt> ¤ò¸«¤è)¡£¼ÂÁõ¤Ë¤è¤Ã¤Æ¤Ï¥Ç¥£¥ì¥¯¥È¥ê¼«¿È¤¬
   ¥Õ¥¡¥¤¥ë¥·¥¹¥Æ¥à¥ª¥Ö¥¸¥§¥¯¥È¤Ç¤¢¤ê¡¢¤Þ¤¿¡¢ÊÌ¤Î¥Ç¥£¥ì¥¯¥È¥ê¤Î
   ¥¨¥ó¥È¥ê¤Ç¤¢¤ë¾ì¹ç¤â¤¢¤ë¡£Ã±½ã²½¤¹¤ë¤¿¤á¤Ë¡¢¤¹¤Ù¤Æ¤Î¥Ç¥£¥ì¥¯¥È¥ê¤Ç¤Ï
   ¤Ê¤¤¥Õ¥¡¥¤¥ë¥·¥¹¥Æ¥à¥ª¥Ö¥¸¥§¥¯¥È¤ò<em>¥Õ¥¡¥¤¥ë</em>¸Æ¤Ö¤³¤È¤Ë¤·¤è¤¦¡£
   ¼ÂºÝ¤Ë¤ÏÄÌ¿®¥Á¥ã¥Í¥ë¤Ç¤¢¤Ã¤¿¤ê¡¢¥ª¥Ú¥ì¡¼¥Æ¥£¥ó¥°¥·¥¹¥Æ¥à¾å¤Ç¤Ï
   ÊÌ¤Î¤â¤Î¤È¤·¤ÆÇ§¼±¤µ¤ì¤ë¤³¤È¤Ï¤¢¤ë¤±¤ì¤É¤â¡£<em>ÊªÍý¥Õ¥¡¥¤¥ë</em>
   ¤Ï±ÊÂ³Åª¤Ç¡¢½ç½øÉÕ¤±¤é¤ì¤¿¥Õ¥¡¥¤¥ë¤Î¤³¤È¤Ç¡¢°ìÈÌ¤Ë¤Ï¥Ç¥£¥¹¥¯¾å¤Ë
   ÃÖ¤«¤ì¤Æ¤¤¤ë¡£
  </p>
  <!--
  <p> File and directory names are values of type <tt>String</tt>, whose
   precise meaning is operating system dependent. Files can be opened,
   yielding a handle which can then be used to operate on the contents of
   that file.</p>
  -->
  <p>
   ¥Õ¥¡¥¤¥ë¤È¥Ç¥£¥ì¥¯¥È¥ê¤ÎÌ¾Á°¤Ï <tt>String</tt> ·¿¤ÎÃÍ¤Ç¤¢¤ë¡£
   ¤½¤ÎÀµ³Î¤Ê°ÕÌ£¤Ï¥ª¥Ú¥ì¡¼¥Æ¥£¥ó¥°¥·¥¹¥Æ¥à¤Ë°ÍÂ¸¤¹¤ë¡£¥Õ¥¡¥¤¥ë¤Ï
   ¥ª¡¼¥×¥ó¤¹¤ë¤³¤È¤¬²ÄÇ½¤Ç¡¢¤½¤Î·ë²Ì¤Ï¥Ï¥ó¥É¥ë¤Ç¤¢¤ê¡¢
   ¤³¤ì¤ò»È¤Ã¤Æ¥Õ¥¡¥¤¥ë¤ÎÆâÍÆ¤òÁàºî¤¹¤ë¤³¤È¤¬¤Ç¤­¤ë¡£
  </p>
  <p><a name="Handles"></a></p>
  <!--
  <p> Haskell defines operations to read and write characters from and to
   files, represented by values of type <tt>Handle</tt>. Each value of this
   type is a <i>handle</i>: a record used by the Haskell run-time system to
   <i>manage</i> I/O with file system objects. A handle has at least the
   following properties:</p>
  -->
  <p>
   Haskell ¤Ç¤Ï¥Õ¥¡¥¤¥ë¤«¤é¤ÎÊ¸»ú¤ÎÆÉ¤ß½Ð¤·¡¢¥Õ¥¡¥¤¥ë¤Ø¤Î
   Ê¸»ú¤Î½ñ¤­¹þ¤ßÁàºî¤¬ÄêµÁ¤µ¤ì¤Æ¤ª¤ê¡¢¤³¤ì¤Ï <tt>Handle</tt> ·¿¤ÎÃÍ¤Ç
   ¤¢¤é¤ï¤µ¤ì¤ë¡£¤³¤Î·¿¤Î¤½¤ì¤¾¤ì¤ÎÃÍ¤Ï<em>¥Ï¥ó¥É¥ë</em>¡¢
   ¤¹¤Ê¤ï¤Á Haskell ¤Î¼Â¹Ô»þ¥·¥¹¥Æ¥à¤¬¥Õ¥¡¥¤¥ë¥·¥¹¥Æ¥à¥ª¥Ö¥¸¥§¥¯¥È¤Î
   Æþ½ÐÎÏ¤ò<em>´ÉÍý</em>¤¹¤ë¤¿¤á¤Ë»È¤¦¤â¤Î¤Ç¤¢¤ë¡£¥Ï¥ó¥É¥ë¤Ï¾¯¤Ê¤¯¤È¤â
   °Ê²¼¤ÎÆÃÀ­¤ò¤â¤Ä¡£
  </p>
  <!--
  <p>
  <ul>
   <li> whether it manages input or output or both;</li>
   <li> whether it is <i>open</i>, <i>closed</i> or <i>semi-closed</i>;</li>
   <li> whether the object is seekable;</li>
   <li> whether buffering is disabled, or enabled on a line or block basis;
    </li>
   <li> a buffer (whose length may be zero).</li>
  </ul>
  </p>
  -->
  <p>
   <ul>
    <li>ÆþÎÏ¤¢¤ë¤¤¤Ï½ÐÎÏ¤¢¤ë¤¤¤Ï¤½¤ÎÎ¾Êý¤ò´ÉÍý¤·¡¢</li>
    <li>¥ª¡¼¥×¥ó¤¢¤ë¤¤¤Ï¥¯¥í¡¼¥º¤¢¤ë¤¤¤ÏÈ¾¥¯¥í¡¼¥º¤Î¾õÂÖ¤Ç¤¢¤ê¡¢</li>
    <li>¥·¡¼¥¯²ÄÇ½¤Ç</li>
    <li>¹Ô¤¢¤ë¤¤¤Ï¥Ö¥í¥Ã¥¯Ã±°Ì¤Ç¡¢¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°ÉÔ²Ä¤¢¤ë¤¤¤Ï²ÄÇ½¤Ç</li>
    <li>¥Ð¥Ã¥Õ¥¡(Ä¹¤µ¤¬¥¼¥í¤Î¾ì¹ç¤â¤¢¤ë)¤ò¤â¤Ä</li>
   </ul>
  </p>
  <!--
  <p> Most handles will also have a current I/O position indicating where
   the next input or output operation will occur. A handle is
   <i>readable</i> if it manages only input or both input and output;
   likewise, it is <i>writable</i> if it manages only output or both input
   and output. A handle is <i>open</i> when first allocated. Once it is
   closed it can no longer be used for either input or output, though an
   implementation cannot re-use its storage while references remain to it.
   Handles are in the <tt>Show</tt> and <tt>Eq</tt> classes. The string
   produced by showing a handle is system dependent; it should include
   enough information to identify the handle for debugging. A handle is
   equal according to <tt>==</tt> only to itself; no attempt is made to
   compare the internal state of different handles for equality.</p>
  -->
  <p>
   ¤Û¤È¤ó¤É¤Î¾ì¹ç¥Ï¥ó¥É¥ë¤Ï¼¡¤ÎÆþ½ÐÎÏÁàºî¤¬¤É¤³¤Çµ¯¤³¤ë¤«¤ò¼¨¤¹
   ¸½ºß¤ÎÆþ½ÐÎÏ°ÌÃÖ¤È¤¤¤¦¤â¤Î¤ò¤â¤Ä¡£¥Ï¥ó¥É¥ë¤Ï¤â¤·ÆþÎÏ¤À¤±¡¢¤¢¤ë¤¤¤Ï
   Æþ½ÐÎÏ¤ÎÎ¾Êý¤ò´ÉÍý¤Ç¤­¤ë¤Î¤Ç¤¢¤ì¤Ð<em>ÆÉ¤ß¹þ¤ß²ÄÇ½</em>¤Ç¤¢¤ë¡£
   Æ±ÍÍ¤Ë¡¢¤â¤·½ÐÎÏ¤À¤±¤¢¤ë¤¤¤ÏÆþ½ÐÎÏ¤ÎÎ¾Êý¤¬´ÉÍý¤Ç¤­¤ë¤Î¤Ç¤¢¤ì¤Ð
   <em>½ñ¤­¤³¤ß²ÄÇ½</em>¤Ç¤¢¤ë¡£¥Ï¥ó¥É¥ë¤ÏºÇ½é¤Ë¥¢¥í¥±¡¼¥È¤µ¤ì¤¿¤È¤­¤Ë
   ¥ª¡¼¥×¥ó¤µ¤ì¤Æ¤¤¤ë¡£°ìÃ¶¥¯¥í¡¼¥º¤µ¤ì¤ë¤È¤½¤ì°Ü¹Ô¡¢ÆþÎÏ¡¢½ÐÎÏ¤È¤â¤Ë
   »È¤¨¤Ê¤¯¤Ê¤ë¡£¤³¤ì¤Ï¡¢¥Ï¥ó¥É¥ë¤Ø¤Î¥ê¥Õ¥¡¥ì¥ó¥¹¤¬¤¿¤È¤¨»Ä¤Ã¤Æ¤¤¤Æ¤â¡¢
   ¼ÂÁõ¤Ï¤½¤Î¥¹¥È¡¼¥ì¥¸¤òºÆÍøÍÑ¤Ç¤­¤Ê¤¤¤È¤¤¤¦¤³¤È¤Ç¤¢¤ë¡£
   ¥Ï¥ó¥É¥ë¤Ï <tt>Show</tt> ¤ª¤è¤Ó <tt>Eq</tt> ¥¯¥é¥¹¤Ç¤¢¤ë¡£
   ¥Ï¥ó¥É¥ëÉ½¼¨¤Î¤¿¤á¤ÎÊ¸»úÎó¤Ï¥·¥¹¥Æ¥à°ÍÂ¸¤Ç¤¢¤ë¡£¤½¤ÎÊ¸»úÎó¤Ë¤Ï
   ¥Ç¥Ð¥Ã¥°ÍÑ¤Ë¥Ï¥ó¥É¥ë¤ò¼±ÊÌ¤¹¤ë¤Î¤Ë½½Ê¬¤Ê¾ðÊó¤ò´Þ¤ó¤Ç¤¤¤ë¡£
   ¥Ï¥ó¥É¥ë¤Ï¡¢<tt>==</tt> ¤Ë´Ø¤·¤Æ¡¢¼«Ê¬¼«¿È¤Ç¤È¤Î¤ßÅù¤·¤¤¡£
   Æ±ÃÍÀ­¤Ë´Ø¤·¤Æ¡¢ÊÌ¤Î¥Ï¥ó¥É¥ë¤ÈÆâÉô¾õÂÖ¤òÈæ³Ó¤¹¤ë¤è¤¦¤Ê¤³¤È¤Ï¤Ê¤¤¡£
  </p>

  <p><a name="StandardHandles"></a></p>
  <p> <a name="sect21.2.1"></a></p>
  <!--<h4>21.2.1<tt>&nbsp;&nbsp;</tt>Standard Handles</h4>-->
  <h4>21.2.1<tt>&nbsp;&nbsp;</tt>É¸½à¥Ï¥ó¥É¥ë</h4>
  <!--
  <p> Three handles are allocated during program initialisation. The first
   two (<tt>stdin</tt> and <tt>stdout</tt>) manage input or output from the
   Haskell program's standard input or output channel respectively. The
   third (<tt>stderr</tt>) manages output to the standard error channel.
   These handles are initially open.</p>
  -->
  <p>
   3 ¤Ä¤Î¥Ï¥ó¥É¥ë¤¬¥×¥í¥°¥é¥à¤Î½é´ü²½Ãæ¤Ë¥¢¥í¥±¡¼¥È¤µ¤ì¤ë¡£ºÇ½é¤ÎÆó¤Ä
   (<tt>stdin</tt> ¤È <tt>stdout</tt>)¤Ï¤½¤ì¤¾¤ì Haskell ¤Î¥×¥í¥°¥é¥à
   ¤Ç¤ÎÉ¸½àÆþÎÏ¥Á¥ã¥Í¥ë¤ÈÉ¸½à½ÐÎÏ¥Á¥ã¥Í¥ë¤ò´ÉÍý¤¹¤ë¤â¤Î¤Ç¤¢¤ë¡£
   3 ¤Ä¤á¤Î¤â¤Î(<tt>stderr</tt>)¤ÏÉ¸½à¥¨¥é¡¼¥Á¥ã¥Í¥ë¤ò´ÉÍý¤¹¤ë¤â¤Î¤Ç¤¢¤ë¡£
   ¤³¤Î 3 ¤Ä¤Î¥Ï¥ó¥É¥ë¤ÏºÇ½é¤«¤é¥ª¡¼¥×¥ó¤µ¤ì¤Æ¤¤¤ë¡£
  </p>

  <a name="SemiClosed"></a>
  <p> <a name="sect21.2.2"></a></p>
  <!--<h4>21.2.2<tt>&nbsp;&nbsp;</tt>Semi-Closed Handles</h4>-->
  <h4>21.2.2<tt>&nbsp;&nbsp;</tt>¥Ï¥ó¥É¥ë¤Î¥»¥ß¥¯¥í¡¼¥º</h4>
  <!--
  <p> The operation <tt>hGetContents</tt><i> hdl</i> (Section <a
   href="io.html#hGetContents">21.9.4</a>) puts a handle <i>hdl</i> into an
   intermediate state, <i>semi-closed</i>. In this state, <i>hdl</i> is
   effectively closed, but items are read from <i>hdl</i> on demand and
   accumulated in a special list returned by <tt>hGetContents</tt>
   <i>hdl</i>.</p>
  -->
  <p>
   Áàºî <tt>hGetContents</tt><i> hdl</i> 
   (<a href="io.html#hGetContents">21.9.4</a> Àá)¤Ï¥Ï¥ó¥É¥ë <i>hdl</i>
   ¤òÃæ´Ö¾õÂÖ<em>¥»¥ß¥¯¥í¡¼¥º</em>¾õÂÖ¤Ë¤¹¤ë¡£¤³¤Î¾õÂÖ¤Ç¤Ï¡¢<i>hdl</i> 
   ¤Ï¼Â¼ÁÅª¤Ë¤Ï¥¯¥í¡¼¥º¾õÂÖ¤Ç¤¢¤ë¤¬¡¢<tt>hdl</tt> ¤«¤éÉ¬Í×¤Ë±þ¤¸¤Æ
   ÆÉ¤ß¹þ¤ß¤ò¤ª¤³¤Ê¤¤¡¢<tt>hGetContents</tt> <i>hdl</i> ¤Ë¤è¤Ã¤Æ
   ÊÖ¤µ¤ì¤ëÆÃÊÌ¤Ê¥ê¥¹¥È¤ËÆÉ¤ß¹þ¤ó¤À¤â¤Î¤¬ÃßÀÑ¤µ¤ì¤ë¡£
  </p>
  <!--
  <p> Any operation that fails because a handle is closed, also fails if a
   handle is semi-closed. The only exception is <tt>hClose</tt>. A
   semi-closed handle becomes closed:</p>
  -->
  <p>
   ¤¹¤Ù¤Æ¤ÎÁàºî¤Ï¥Ï¥ó¥É¥ë¤¬¥¯¥í¡¼¥º¤µ¤ì¤Æ¤¤¤ë¤È¼ºÇÔ¤¹¤ë¡£Æ±ÍÍ¤Ë
   ¥Ï¥ó¥É¥ë¤¬¥»¥ß¥¯¥í¡¼¥º¤µ¤ì¤Æ¤¤¤Æ¤â¼ºÇÔ¤¹¤ë¡£Í£°ì¤ÎÎã³°¤Ï¡¢
   <tt>hClose</tt> ¤Ç¤¢¤ë¡£¥»¥ß¥¯¥í¡¼¥º¤µ¤ì¤¿¥Ï¥ó¥É¥ë¤Ï°Ê²¼¤Î¾ì¹ç¤Ë
   ¥¯¥í¡¼¥º¤µ¤ì¤ë¡£
  </p>
  <!--
  <ul>
   <li> if <tt>hClose</tt> is applied to it;</li>
   <li> if an I/O error occurs when reading an item from the handle;</li>
   <li> or once the entire contents of the handle has been read.</li>
  </ul>
  -->
  <p>
   <ul>
    <li>¤½¤Î¥Ï¥ó¥É¥ë¤Ë <tt>hClose</tt> ¤¬Å¬ÍÑ¤µ¤ì¤¿¾ì¹ç<li>
    <li>¤½¤Î¥Ï¥ó¥É¥ë¤«¤é¤Î¥Ç¡¼¥¿¤òÆÉ¤ß¹þ¤ßÃæ¤Ë I/O ¥¨¥é¡¼¤¬µ¯¤­¤¿¾ì¹ç</li>
    <li>¥Ï¥ó¥É¥ë¤«¤éÁ´ÆâÍÆ¤¬ÆÉ¤ß¹þ¤Þ¤ì¤¿¤¢¤È</li>
   </ul>
  </p>
  <!--
  <p> Once a semi-closed handle becomes closed, the contents of the
   associated list becomes fixed. The contents of this final list is only
   partially specified: it will contain at least all the items of the
   stream that were evaluated prior to the handle becoming closed.</p>
  -->
  <p>
  <p>
   ¥»¥ß¥¯¥í¡¼¥º¾õÂÖ¤Î¥Ï¥ó¥É¥ë¤¬°ìÃ¶¥¯¥í¡¼¥º¤µ¤ì¤Æ¤·¤Þ¤¦¤È¡¢ÂÐ±þ¤¹¤ë
   ¥ê¥¹¥È¤ÎÆâÍÆ¤Ï¸ÇÄê¤µ¤ì¤ë¡£¤³¤ÎºÇ½ªÅª¤Ê¥ê¥¹¥È¤ÎÆâÍÆ¤ÏÉôÊ¬Åª¤Ëµ¬Äê
   ¤µ¤ì¤Æ¤¤¤ë¤Ë¤¹¤®¤Ê¤¤¡£¾¯¤¯¤È¤â¡¢¥Ï¥ó¥É¥ë¤¬¥¯¥í¡¼¥º¤µ¤ì¤ë¤ËÀè¤À¤Ã¤Æ
   É¾²Á¤µ¤ì¤¿¥¹¥È¥ê¡¼¥à¤Î¥Ç¡¼¥¿¤ò´Þ¤à¤³¤È¤Ë¤Ê¤ë¡£
  </p>
  <!--
  <p> Any I/O errors encountered while a handle is semi-closed are simply
   discarded. </p>
  -->
  <p>
   ¥Ï¥ó¥É¥ë¤¬¥»¥ß¥¯¥í¡¼¥º¾õÂÖ¤Ë¤¢¤ë¾ì¹ç¤Ëµ¯¤­¤¿¤¢¤é¤æ¤ë I/O ¥¨¥é¡¼
   ¤ÏÃ±½ã¤ËÇÑ´þ¤µ¤ì¤ë¡£
  </p>
   
  <p><a name="sect21.2.3"></a></p>
  <!--<h4>21.2.3<tt>&nbsp;&nbsp;</tt>File locking</h4>-->
  <h4>21.2.3<tt>&nbsp;&nbsp;</tt>¥Õ¥¡¥¤¥ë¤Î¥í¥Ã¥¯</h4>
  <!--
  <p> Implementations should enforce as far as possible, at least locally
   to the Haskell process, multiple-reader single-writer locking on files.
   That is, <i>there may either be many handles on the same file which
   manage input, or just one handle on the file which manages output</i>.
   If any open or semi-closed handle is managing a file for output, no new
   handle can be allocated for that file. If any open or semi-closed handle
   is managing a file for input, new handles can only be allocated if they
   do not manage output. Whether two files are the same is
   implementation-dependent, but they should normally be the same if they
   have the same absolute path name and neither has been renamed, for
   example.</p>
  -->
  <p>
   ¼ÂÁõ¤Ç¤Ï¤Ç¤­¤¦¤ë¤«¤®¤ê¡¢Haskell ¤Î¥×¥í¥»¥¹Æâ¤Ç¤Ï¡¢¥Õ¥¡¥¤¥ë¤ËÂÐ¤·¤Æ¤Ï
   ÆÉ¤ß¹þ¤ßÂ¿½Å¡¢½ñ¤­¤³¤ß¤Ï 1 ¤Ä¤À¤±¤È¤¤¤¦¥í¥Ã¥¯µ¡¹½¤ò¼Â¸½¤·¤Ê¤±¤ì¤Ð
   ¤Ê¤é¤Ê¤¤¡£¤·¤¿¤¬¤Ã¤Æ¡¢<em>Æ±¤¸¥Õ¥¡¥¤¥ë¤ËÂÐ¤·¤ÆÆþÎÏ´ÉÍýÍÑ¤ËÊ£¿ô¤Î
   ¥Ï¥ó¥É¥ë¤¬Â¸ºß¤¹¤ë²ÄÇ½À­¤¬¤¢¤ê¡¢½ÐÎÏ´ÉÍýÍÑ¤Ë¤Ï°ì¤Ä¤Î¥Õ¥¡¥¤¥ë¤Ë¤Ï
   °ì¤Ä¤Î¥Ï¥ó¥É¥ë¤·¤«Â¸ºß¤·¤Ê¤¤</em>¡£¤â¤·¡¢½ÐÎÏÍÑ¤Ë¥Ï¥ó¥É¥ë¤¬¥ª¡¼¥×¥ó
   ¤µ¤ì¤¿¾õÂÖ¤¢¤ë¤¤¤Ï¥»¥ß¥¯¥í¡¼¥º¤Î¾õÂÖ¤Ç¤¢¤ë¾ì¹ç¤Ë¤Ï¡¢¤½¤Î¥Õ¥¡¥¤¥ë¤Ë
   ÂÐ¤·¤Æ¤Ï¥Ï¥ó¥É¥ë¤ò¥¢¥í¥±¡¼¥È¤¹¤ë¤³¤È¤À¤±¤Ï¤Ç¤­¤ë¤¬¡¢
   ¤½¤Î¥Ï¥ó¥É¥ë¤Ç½ÐÎÏ¤ò´ÉÍý¤¹¤ë¤³¤È¤Ï¤Ç¤­¤Ê¤¤¡£Æó¤Ä¤Î¥Õ¥¡¥¤¥ë¤¬Æ±¤¸¤Ç
   ¤¢¤ë¤«¤É¤¦¤«¤Ï¼ÂÁõ°ÍÂ¸¤Ç¤¢¤ë¤¬¡¢¤¿¤È¤¨¤Ð¡¢¤Õ¤Ä¤¦¡¢Æ±¤¸ÀäÂÐ¥Ñ¥¹Ì¾¤ò
   ¤â¤Á¡¢¥ê¥Í¡¼¥à¤µ¤ì¤Æ¤¤¤Ê¤±¤ì¤Ð¡¢Æ±¤¸¤Ç¤¢¤ë¤Ù¤­¤Ç¤¢¤ë¡£
  </p>
  <!--
  <p> <i>Warning</i>: the <tt>readFile</tt> operation (Section <a
   href="io-13.html#standard-io-functions">7.1</a>) holds a semi-closed
   handle on the file until the entire contents of the file have been
   consumed. It follows that an attempt to write to a file (using
   <tt>writeFile</tt>, for example) that was earlier opened by
   <tt>readFile</tt> will usually result in failure with
   <tt>isAlreadyInUseError</tt>.</p>
  -->
  <p>
   <em>·Ù¹ð¡§</em> <tt>readFile</tt> Áàºî
   (<a href="io-13.html#standard-io-functions">7.1</a> Àá)¤Ï¡¢
   Åö³º¥Õ¥¡¥¤¥ë¤Î¤¹¤Ù¤Æ¤Î¥³¥ó¥Æ¥ó¥Ä¤¬¾ÃÈñ¤µ¤ì¤Æ¤·¤Þ¤ï¤Ê¤¤¤¦¤Á¤Ï
   ¥»¥ß¥¯¥í¡¼¥º¤µ¤ì¤¿¥Ï¥ó¥É¥ë¤òÊÝ»ý¤¹¤ë¡£¤½¤Î·ë²Ì¤È¤·¤Æ¡¢Àè¤Ë
   <tt>readFile</tt> ¤Ç¥ª¡¼¥×¥ó¤µ¤ì¤¿¥Õ¥¡¥¤¥ë¤Ë(¤¿¤È¤¨¤Ð¡¢
   <tt>writeFile</tt> ¤ò»È¤Ã¤Æ)½ñ¤­¹þ¤â¤¦¤È¤¹¤ë¤ÈÄÌ¾ï¡¢
   <tt>isAlreadyInUseError</tt> ¤È¤Ê¤Ã¤Æ¼ºÇÔ¤¹¤ë¤³¤È¤Ë¤Ê¤ë¤À¤í¡£
  </p>

  <p><a name="OpeningClosing"></a></p>
  <p> <a name="sect21.3"></a></p>
  <!--<h3>21.3<tt>&nbsp;&nbsp;</tt>Opening and Closing Files</h3>-->
  <h3>21.3<tt>&nbsp;&nbsp;</tt>¥Õ¥¡¥¤¥ë¤Î¥ª¡¼¥×¥ó¤È¥¯¥í¡¼¥º</h3>
  <p><a name="Opening"></a></p>
  <p> <a name="sect21.3.1"></a></p>

  <!--<h4>21.3.1<tt>&nbsp;&nbsp;</tt>Opening Files</h4>-->
  <h4>21.3.1<tt>&nbsp;&nbsp;</tt>¥Õ¥¡¥¤¥ë¤Î¥ª¡¼¥×¥ó</h4>
  <!--
  <p> Computation <tt>openFile</tt> <i>file</i> <i>mode</i> allocates and
   returns a new, open handle to manage the file <i>file</i>. It manages
   input if <i>mode</i> is <tt>ReadMode</tt>, output if <i>mode</i> is
   <tt>WriteMode</tt> or <tt>AppendMode</tt>, and both input and output if
   mode is <tt>ReadWriteMode</tt>.</p>
  -->
  <p>
   ·×»» <tt>openFile</tt> <I>file</I> <I>mode</I> ¤Ï¥Õ¥¡¥¤¥ë <i>file</i>
   ¤ò´ÉÍý¤¹¤ë¤¿¤á¤Î¿·¤·¤¤¥ª¡¼¥×¥ó¤µ¤ì¤¿¥Ï¥ó¥É¥ë¤ò¥¢¥í¥±¡¼¥È¤·¤½¤ì¤òÊÖ¤¹¡£
   ¤³¤Î¥Ï¥ó¥É¥ë¤Ï <i>mode</i> ¤¬ <tt>ReadMode</tt> ¤Ç¤¢¤ì¤ÐÆþÎÏÍÑ¤Ç¤¢¤ê¡¢
   <i>mode</i> ¤¬ <tt>WriteMode</tt> ¤¢¤ë¤¤¤Ï <tt>AppendMode</tt> 
   ¤Ç¤¢¤ì¤Ð½ÐÎÏÍÑ¤Ç¤¢¤ê¡¢<i>mode</i> ¤¬ <tt>ReadWriteMode</tt> ¤Ê¤é¤Ð
   Æþ½ÐÎÏÎ¾ÍÑ¤Ç¤¢¤ë¡£
  </p>
  <!--
  <p> If the file does not exist and it is opened for output, it should be
   created as a new file. If <i>mode</i> is <tt>WriteMode</tt> and the file
   already exists, then it should be truncated to zero length. Some
   operating systems delete empty files, so there is no guarantee that the
   file will exist following an <tt>openFile</tt> with <i>mode</i>
   <tt>WriteMode</tt> unless it is subsequently written to successfully.
   The handle is positioned at the end of the file if <i>mode</i> is
   <tt>AppendMode</tt>, and otherwise at the beginning (in which case its
   internal I/O position is 0). The initial buffer mode is
   implementation-dependent.</p>
  -->
  <p>
   ¤â¤·¡¢¥Õ¥¡¥¤¥ë¤¬Â¸ºß¤»¤º¡¢½ÐÎÏÍÑ¤Ë¥ª¡¼¥×¥ó¤µ¤ì¤ì¤Ð¿·¤Ë¥Õ¥¡¥¤¥ë¤¬
   ºîÀ®¤µ¤ì¤ë¡£¤â¤·¡¢<i>mode</i> ¤¬ <tt>WriteMode</tt> ¤Ç¥Õ¥¡¥¤¥ë¤¬
   ¤¹¤Ç¤ËÂ¸ºß¤·¤Æ¤¤¤ì¤Ð¡¢¤½¤Î¥Õ¥¡¥¤¥ë¤ÏÄ¹¤µ¥¼¥í¤Ë´Ý¤á¤é¤ì¤ë¡£
   ¥ª¥Ú¥ì¡¼¥Æ¥£¥ó¥°¥·¥¹¥Æ¥à¤Ë¤è¤Ã¤Æ¤Ï¶õ¤Î¥Õ¥¡¥¤¥ë¤ò¾Ãµî¤¹¤ë¤â¤Î¤â
   ¤¢¤ë¤Î¤Ç¡¢¥Õ¥¡¥¤¥ë¤¬ <i>mode</i> <tt>WriteMode</tt> ¤Ç 
   <tt>openFile</tt> ¤µ¤ì¤¿¸å¤Ë½ñ¤­¤³¤ß¤¬À®¸ù¤·¤Ê¤«¤Ã¤¿¾ì¹ç¡¢
   ¤½¤Î¥Õ¥¡¥¤¥ë¤¬ÁêÊÑ¤ï¤é¤ºÂ¸ºß¤·¤Æ¤¤¤ë¤³¤È¤ÏÊÝ¾Ú¤µ¤ì¤Ê¤¤¡£
   ¥Õ¥¡¥¤¥ë¤¬¤â¤·¡¢<tt>AppendMode</tt> ¤Ç¥ª¡¼¥×¥ó¤µ¤ì¤¿¾ì¹ç¤Ë¤Ï
   ¥Ï¥ó¥É¥ë¤Î°ÌÃÖ¤Ï¥Õ¥¡¥¤¥ë¤ÎºÇ¸å¤Ë¤¢¤ê¡¢¤½¤ì°Ê³°¤Î¾ì¹ç¤ÏÀèÆ¬
   (¤³¤Î¾ì¹ç¤Ë¤ÏÆâÉôÅª¤Ê I/O °ÌÃÖ¤¬ 0 )¤Ë¤¢¤ë¡£½é´ü¤Î¥Ð¥Ã¥Õ¥¡¥â¡¼¥É¤Ï
   ¼ÂÁõ°ÍÂ¸¤Ç¤¢¤ë¡£
  </p>
  <!--
  <p> If <tt>openFile</tt> fails on a file opened for output, the file may
   still have been created if it did not already exist.</p>
  -->
  <p>
   ¤â¤·¡¢<tt>openFile</tt> ¤¬½ÐÎÏ¥Õ¥¡¥¤¥ë¤Î¥ª¡¼¥×¥ó¤Ë¼ºÇÔ¤·¤¿¾ì¹ç¤Ç¤â¡¢
   ¤½¤Î¥Õ¥¡¥¤¥ë¤¬Â¸ºß¤·¤Ê¤±¤ì¤Ð¡¢¿·¤¿¤ËºîÀ®¤µ¤ì¤ë¡£
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>openFile</tt> computation may fail
   with <tt>isAlreadyInUseError</tt> if the file is already open and cannot
   be reopened; <tt>isDoesNotExistError</tt> if the file does not exist; or
   <tt>isPermissionError</tt> if the user does not have permission to open
   the file.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em><tt>openFile</tt> ¤Î·×»»¤Ï¤â¤·¥Õ¥¡¥¤¥ë¤¬
   ´û¤Ë¥ª¡¼¥×¥ó¤µ¤ì¤Æ¤¤¤ÆºÆ¥ª¡¼¥×¥ó¤Ç¤­¤Ê¤±¤ì¤Ð¡¢
   <tt>isAlreadyInUseError</tt> ¤È¤Ê¤Ã¤Æ¼ºÇÔ¤·¡¢¥Õ¥¡¥¤¥ë¤¬Â¸ºß¤·¤Ê¤±¤ì¤Ð
   <tt>isDoesNotExistError</tt>¡¢¥Õ¥¡¥¤¥ë¤ò¥ª¡¼¥×¥ó¤¹¤ë¸¢¸Â¤ò
   ¥æ¡¼¥¶¤¬¤â¤¿¤Ê¤±¤ì¤Ð¡¢<tt>isPermissionError</tt>¤È¤Ê¤ë¡£
  </p>

  <p><a name="Closing"></a></p>
  <p> <a name="sect21.3.2"></a></p>

  <!--<h4>21.3.2<tt>&nbsp;&nbsp;</tt>Closing Files</h4>-->
  <h4>21.3.2<tt>&nbsp;&nbsp;</tt>¥Õ¥¡¥¤¥ë¤Î¥¯¥í¡¼¥º</h4>

  <!--
  <p> Computation <tt>hClose</tt> <i>hdl</i> makes handle <i>hdl</i>
   closed. Before the computation finishes, if <i>hdl</i> is writable its
   buffer is flushed as for <tt>hFlush</tt>. Performing <tt>hClose</tt> on
   a handle that has already been closed has no effect; doing so not an
   error. All other operations on a closed handle will fail. If
   <tt>hClose</tt> fails for any reason, any further operations (apart from
   <tt>hClose</tt>) on the handle will still fail as if <i>hdl</i> had been
   successfully closed.</p>
  -->
  <p>
   <tt>hClose</tt> <i>hdl</i> ¤È¤¤¤¦·×»»¤Ï¥Ï¥ó¥É¥ë <i>hdl</i> ¤ò
   ¥¯¥í¡¼¥º¤¹¤ë¡£¤³¤Î·×»»¤¬½ªÎ»¤¹¤ëÁ°¤Ë¡¢¤â¤·¡¢<i>hdl</i> ¤¬½ñ¤­¤³¤ß
   ²ÄÇ½¤Ç¤¢¤ì¤Ð¡¢¤½¤Î¥Ð¥Ã¥Õ¥¡¤Ï <tt>hFlush</tt> ¤ò»È¤¦¤Î¤ÈÆ±ÍÍ¤Ë
   ¥Õ¥é¥Ã¥·¥å¤µ¤ì¤ë¡£<tt>hClose</tt> ¤ò¤¹¤Ç¤Ë¥¯¥í¡¼¥º¤µ¤ì¤¿¥Ï¥ó¥É¥ë¤Ë
   ¼Â¹Ô¤·¤Æ¤â¡¢²¿¤â¤ª¤³¤é¤º¡¢¥¨¥é¡¼¤Ë¤â¤Ê¤é¤Ê¤¤¡£¥¯¥í¡¼¥º¤µ¤ì¤¿
   ¥Ï¥ó¥É¥ë¤Ø¤Î¤½¤ì°Ê³°¤ÎÁàºî¤Ï¼ºÇÔ¤¹¤ë¡£¤â¤·¡¢<tt>hClose</tt>¤¬¡¢
   ¤Ê¤ó¤é¤«¤ÎÍýÍ³¤Ç¼ºÇÔ¤·¤¿¤é¡¢¤½¤ì°Ê¾å¤Î(<tt>hClose</tt>°Ê³°¤Î)
   ¥ª¥Ú¥ì¡¼¥·¥ç¥ó¤Ï <i>hdl</i> ¤¬Àµ¤·¤¯¥¯¥í¡¼¥º¤µ¤ì¤¿¾ì¹ç¤ÈÆ±ÍÍ¤Ë
   ¼ºÇÔ¤¹¤ë¡£
  </p>

  <p><a name="FileSize"></a></p>
  <p> <a name="sect21.4"></a></p>
  <!--<h3>21.4<tt>&nbsp;&nbsp;</tt>Determining the Size of a File</h3>-->
  <h3>21.4<tt>&nbsp;&nbsp;</tt>¥Õ¥¡¥¤¥ë¥µ¥¤¥º¤Î·èÄê</h3>
  <!--
  <p> For a handle <i>hdl</i> which is attached to a physical file,
   <tt>hFileSize </tt><i>hdl</i> returns the size of that file in 8-bit
   bytes (<i>&gt;=</i> 0).</p>
  -->
  <p>
   ÊªÍýÅª¤Ê¥Õ¥¡¥¤¥ë¤Ë·ë¤ÓÉÕ¤±¤é¤ì¤¿¥Ï¥ó¥É¥ë <i>hdl</i> ¤ËÂÐ¤·¤Æ¡¢
   <tt>hFileSize</tt> <i>hdl</i> ¤Ï¥Õ¥¡¥¤¥ë¤ÎÂç¤­¤µ¤ò 8-bit ¥Ð¥¤¥È¤ÇÊÖ¤¹
   (<i>&gt;=</i> 0)¡£
  </p>
 
  <p><a name="EOF"></a></p>
  <p> <a name="sect21.5"></a></p>

  <!--<h3>21.5<tt>&nbsp;&nbsp;</tt>Detecting the End of Input</h3>-->
  <h3>21.5<tt>&nbsp;&nbsp;</tt>ÆþÎÏ½ªÃ¼¤Î¸¡½Ð</h3>
  <!--
  <p> For a readable handle <i>hdl</i>, computation <tt>hIsEOF</tt>
   <i>hdl</i> returns <tt>True </tt>if no further input can be taken from
   <i>hdl</i>; for a handle attached to a physical file this means that the
   current I/O position is equal to the length of the file. Otherwise, it
   returns <tt>False</tt>. The computation <tt>isEOF</tt> is identical,
   except that it works only on <tt>stdin</tt>.</p>
  -->
  <p>
   ÆÉ¤ß½Ð¤·²ÄÇ½¤Ê¥Ï¥ó¥É¥ë <i>hdl</i> ¤ËÂÐ¤·¡¢·×»» <tt>hIsEOF</tt>
   <i>hdl</i> ¤Ï¡¢<i>hdl</i> ¤«¤é¤³¤ì°Ê¾åÆþÎÏ¤ò¼è¤ê½Ð¤»¤Ê¤¤¾ì¹ç¤Ë¤Ï
   <tt>True</tt> ¤òÊÖ¤¹¡£¤³¤Î¤³¤È¤Ï¡¢ÊªÍýÅª¤Ê¥Õ¥¡¥¤¥ë¤Ë·ë¤ÓÉÕ¤±¤é¤ì¤¿
   ¥Ï¥ó¥É¥ë¤Ë¤Ä¤¤¤Æ¸À¤¨¤Ð¡¢¸½ºß¤ÎÆþ½ÐÎÏ°ÌÃÖ¤¬¤½¤Î¥Õ¥¡¥¤¥ë¤ÎÄ¹¤µ¤ËÅù¤·¤¤
   ¤È¤¤¤¦¤³¤È¤Ç¤¢¤ë¡£¤â¤·¡¢½ªÃ¼¤Ç¤Ê¤±¤ì¤Ð¡¢<tt>False</tt> ¤¬ÊÖ¤ë¡£
   ·×»» <tt>isEOF</tt> ¤Ï <tt>stdin</tt> ¾å¤Ç¤Î¤ßÆ°ºî¤¹¤ë¤È¤¤¤¦¤³¤È¤ò
   ½ü¤±¤Ð¡¢Æ±°ì¤Î·×»»¤Ç¤¢¤ë¡£
  </p>

  <p><a name="Buffering"></a></p>
  <p> <a name="sect21.6"></a></p>
  <!--<h3>21.6<tt>&nbsp;&nbsp;</tt>Buffering Operations</h3>-->
  <h3>21.6<tt>&nbsp;&nbsp;</tt>¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°Áàºî</h3>
  <!--
  <p> Three kinds of buffering are supported: line-buffering,
   block-buffering or no-buffering. These modes have the following effects.
   For output, items are written out, or <i>flushed</i>, from the internal
   buffer according to the buffer mode:</p>
  -->
  <p>
   3 ¼ïÎà¤Î¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¤¬¥µ¥Ý¡¼¥È¤µ¤ì¤Æ¤¤¤ë¡£¹Ô¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¡¢
   ¥Ö¥í¥Ã¥¯¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¡¢¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¤Ê¤·¡¢¤Ç¤¢¤ë¡£¤³¤ì¤é¤Î¥â¡¼¥É¤Ï
   °Ê²¼¤Î¸ú²Ì¤¬¤¢¤ë¡£½ÐÎÏ¤Ë´Ø¤·¤Æ¤Ï¡¢¹àÌÜ¤ÏÆâÉô¥Ð¥Ã¥Õ¥¡¤«¤é¤½¤Î
   ¥Ð¥Ã¥Õ¥¡¥â¡¼¥É¤Ë±þ¤¸¤Æ½ñ¤­½Ð¤µ¤ì¤ë¤«¡¢¤¢¤ë¤¤¤Ï<em>¥Õ¥é¥Ã¥·¥å¤µ¤ì¤ë
   </em>¡£
  </p>
  <!--
  <ul>
   <li> <b>line-buffering: </b>the entire buffer is flushed whenever a
    newline is output, the buffer overflows, a <tt>hFlush</tt> is issued,
    or the handle is closed.</li>

   <li> <b>block-buffering: </b>the entire buffer is written out whenever
    it overflows, a <tt>hFlush</tt> is issued, or the handle is closed.</li>

   <li> <b>no-buffering: </b>output is written immediately, and never
    stored in the buffer.</li>
  </ul>
  -->
  <p>
   <ul>
    <li>
     <b>¹Ô¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¡§</b>¼¡¤Î¤³¤È¤¬µ¯¤³¤ë¤¿¤Ó¤Ë¥Ð¥Ã¥Õ¥¡Á´ÂÎ¤¬
     ¥Õ¥é¥Ã¥·¥å¤µ¤ì¤ë¡£²þ¹Ô¤¬½ÐÎÏ¤µ¤ì¤¿¡£¥Ð¥Ã¥Õ¥¡¤¬¥ª¡¼¥Ð¡¼¥Õ¥í¡¼¤·¤¿¡£
     <tt>hFlush</tt>¤¬È¯¹Ô¤µ¤ì¤¿¡£¥Ï¥ó¥É¥ë¤¬¥¯¥í¡¼¥º¤µ¤ì¤¿¡£</li>
    <li>
     <b>¥Ö¥í¥Ã¥¯¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¡§</b>¼¡¤Î¤³¤È¤¬µ¯¤³¤ë¤¿¤Ó¤Ë¥Ð¥Ã¥Õ¥¡Á´ÂÎ¤¬
     ½ñ¤­½Ð¤µ¤ì¤ë¡£¥Ð¥Ã¥Õ¥¡¤¬¥ª¡¼¥Ð¡¼¥Õ¥í¡¼¤·¤¿¡£<tt>hFlush</tt> ¤¬
     È¯¹Ô¤µ¤ì¤¿¡£¥Ï¥ó¥É¥ë¤¬¥¯¥í¡¼¥º¤µ¤ì¤¿¡£</li>
    <li><b>¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¤Ê¤·¡§</b>½ÐÎÏ¤ÏÄ¾¤Á¤Ë½ñ¤­½Ð¤µ¤ì¡¢
     ¥Ð¥Ã¥Õ¥¡¤Ë³ÊÇ¼¤µ¤ì¤ë¤³¤È¤Ï¤Ê¤¤¡£</li>
   </ul>
  </p>
  <!--
  <p>An implementation is free to flush the buffer more frequently, but not
   less frequently, than specified above. The buffer is emptied as soon as
   it has been written out.</p>
  -->
  <p>
   ¼ÂÁõ¤Ï¾å¤Ç¤Îµ¬Äê¤è¤ê¤âÉÑÈË¤Ë¥Ð¥Ã¥Õ¥¡¤ò¥Õ¥é¥Ã¥·¥å¤·¤Æ¤â¤è¤¤¡£¤·¤«¤·¡¢
   ¾å¤Îµ¬Äê°Ê²¼¤ÎÉÑÅÙ¤Ë¤·¤Æ¤Ï¤Ê¤é¤Ê¤¤¡£¥Ð¥Ã¥Õ¥¡¤Ï½ñ¤­½Ð¤·¤¬ºÑ¤à¤È¤¹¤°¤Ë
   ¶õ¤Ë¤µ¤ì¤ë¡£
  </p>
  <!--
  <p> Similarly, input occurs according to the buffer mode for handle
   <i>hdl</i>.</p>
  -->
  <p>
   Æ±ÍÍ¤Ë¤·¤Æ¡¢ÆþÎÏ¤Ï¤½¤Î¥Ï¥ó¥É¥ë <i>hdl</i> ¤Î¥Ð¥Ã¥Õ¥¡¥â¡¼¥É¤Ë
   ¤·¤¿¤¬¤Ã¤Æµ¯¤³¤ë¡£
  </p>
  <!--
  <ul>
   <li> <b>line-buffering: </b>when the buffer for <i>hdl</i> is not empty,
    the next item is obtained from the buffer; otherwise, when the buffer
    is empty, characters are read into the buffer until the next newline
    character is encountered or the buffer is full. No characters are
    available until the newline character is available or the buffer is
    full.</li>
   <li> <b>block-buffering:</b> when the buffer for <i>hdl</i> becomes
    empty, the next block of data is read into the buffer.</li>
   <li> <b>no-buffering:</b> the next input item is read and returned. The
    <tt>hLookAhead</tt> operation (Section <a
    href="io.html#hLookAhead">21.9.3</a>) implies that even a no-buffered
    handle may require a one-character buffer.</li>
  </ul>
  -->
  <p>
   <ul>
    <li><b>¹Ô¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¡§</b><i>hdl</i> ¤ËÂÐ±þ¤¹¤ë¥Ð¥Ã¥Õ¥¡¤¬
     ¶õ¤Ç¤Ê¤¤¾ì¹ç¡¢¼¡¤Î¹àÌÜ¤¬¥Ð¥Ã¥Õ¥¡¤«¤éÆÉ¤ß¹þ¤Þ¤ì¤ë¡£¶õ¤Ç¤¢¤Ã¤¿¾ì¹ç¡¢
     ²þ¹ÔÊ¸»ú¤¬¤¯¤ë¤«¡¢¥Ð¥Ã¥Õ¥¡¤¬¥Õ¥ë¤Ë¤Ê¤ë¤Þ¤Ç¡¢¥Ð¥Ã¥Õ¥¡¤ËÆÉ¤ß¹þ¤Þ¤ì¤ë¡£
     ²þ¹ÔÊ¸»ú¤¬Í­¸ú¤Ë¤Ê¤ë¤«¡¢¥Ð¥Ã¥Õ¥¡¤¬¥Õ¥ë¤Ë¤Ê¤ë¤Þ¤Ç¤Ï¡¢ÆþÎÏÊ¸»ú¤Ï
     Í­¸ú¤Ë¤Ê¤é¤Ê¤¤¡£</li>
    <li><b>¥Ö¥í¥Ã¥¯¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¡§</b><i>hdl</i> ¤ËÂÐ±þ¤¹¤ë¥Ð¥Ã¥Õ¥¡¤¬
     ¶õ¤Ë¤Ê¤Ã¤¿¤È¤­¡¢¤Ä¤®¤Î¥Ö¥í¥Ã¥¯¤¬¥Ð¥Ã¥Õ¥¡¤ËÆÉ¤ß¹þ¤Þ¤ì¤ë¡£</li>
    <li><b>¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¤Ê¤·¡§</b>¼¡¤ÎÆþÎÏ¤¬ÆÉ¤ß¹þ¤Þ¤ìÊÖ¤µ¤ì¤ë¡£
     <tt>hLookAhead</tt> Áàºî</li>
     (<a href="io.html#hLookAhead">21.9.3</a>Àá) ¤Ï¤¿¤È¤¨¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°
     ¤Ê¤·¥â¡¼¥É¤Î¥Ï¥ó¥É¥ë¤Ç¤¢¤Ã¤Æ¤â°ìÊ¸»úÊ¬¤Î¥Ð¥Ã¥Õ¥¡¤¬É¬Í×¤Ç¤¢¤ë¤³¤È¤ò
     ¼¨¤·¤Æ¤¤¤ë¡£
   </ul>
  </p>
  <!--
  <p> For most implementations, physical files will normally be
   block-buffered and terminals will normally be line-buffered.</p>
  -->
  <p>
   ÂçÂ¿¿ô¤Î¼ÂÁõ¤Ç¤Ï¡¢ÊªÍýÅª¤Ê¥Õ¥¡¥¤¥ë¤Ï¤Õ¤Ä¤¦¥Ö¥í¥Ã¥¯¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°
   ¥â¡¼¥É¤ÇÁàºî¤·¡¢¥¿¡¼¥ß¥Ê¥ë¤Ï¹Ô¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¥â¡¼¥É¤ÇÁàºî¤¹¤ë¡£
  </p>
  <!--
  <p> Computation <tt>hSetBuffering</tt> <i>hdl</i> <i>mode</i> sets the
   mode of buffering for handle <i>hdl</i> on subsequent reads and writes.</p>
  -->
  <p>
   ·×»» <tt>hSetBuffering</tt> <i>hdl</i> <i>mode</i> ¤Ï¥Ï¥ó¥É¥ë <i>hdl</i>
   ¤Î¤½¤Î¸å¤ÎÆÉ¤ß½ñ¤­¤Î¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¥â¡¼¥É¤òÀßÄê¤¹¤ë¡£
  </p>
  <!--
  <ul>
   <li> If <i>mode</i> is <tt>LineBuffering</tt>, line-buffering is enabled
    if possible.</li>

   <li> If <i>mode</i> is <tt>BlockBuffering</tt> <i>size</i>, then
    block-buffering is enabled if possible. The size of the buffer is
    <i>n</i> items if <i>size</i> is <tt>Just&nbsp;</tt><i>n</i> and is
    otherwise implementation-dependent.</li>

   <li> If <i>mode</i> is <tt>NoBuffering</tt>, then buffering is disabled
    if possible.</li>
  </ul>
  -->
  <p>
   <ul>
    <li>¤â¤·¡¢<i>mode</i> ¤¬ <tt>LineBuffering</tt> ¤Ç¤¢¤ë¾ì¹ç¡¢
    ²ÄÇ½¤Ç¤Ê¤é¹Ô¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¤¬Í­¸ú¤Ë¤Ê¤ë¡£</li>
    <li>¤â¤·¡¢<i>mode</i> ¤¬ <tt>BlockBuffering</tt> <i>size</i>
    ¤Ç¤¢¤ë¾ì¹ç¡¢²ÄÇ½¤Ê¤é¥Ö¥í¥Ã¥¯¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¤¬Í­¸ú¤Ë¤Ê¤ë¡£
    ¥Ð¥Ã¥Õ¥¡¤Î¥µ¥¤¥º¤Ï¡¢<i>size</i> ¤¬ <tt>Just&nbsp;</tt> <i>n</i>
    ¤Ç¤¢¤ë¾ì¹ç¡¢ <i>n</i> Ã±°Ì¤Ç¤¢¤ê¡¢¤µ¤â¤Ê¤±¤ì¤Ð¡¢¼ÂÁõ°ÍÂ¸¤Ç¤¢¤ë¡£</li>
    <li>¤â¤·¡¢<i>mode</i> ¤¬ <tt>NoBuffering</tt> ¤Ç¤¢¤ë¾ì¹ç¡¢²ÄÇ½¤Ê¤é¤Ð¡¢
     ¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¤ÏÌµ¸ú¤Ë¤Ê¤ë¡£</li>
   </ul>
  </p>
  <!--
  <p> If the buffer mode is changed from <tt>BlockBuffering</tt> or
   <tt>LineBuffering</tt> to <tt>NoBuffering</tt>, then</p>
  -->
  <p>
   ¤â¤·¡¢¥Ð¥Ã¥Õ¥¡¥â¡¼¥É¤¬ <tt>BlockBuffering</tt> ¤Þ¤¿¤Ï¡¢
   <tt>LineBuffering</tt> ¤«¤é <tt>NoBuffering</tt> ¤ØÊÑ¹¹¤µ¤ì¤¿¾ì¹ç¡¢
  </p>
  <!--
  <ul>
   <li> if <i>hdl</i> is writable, the buffer is flushed as for
    <tt>hFlush</tt>;</li>
   <li> if <i>hdl</i> is not writable, the contents of the buffer is
    discarded.</li>
  </ul>
  -->
  <p>
   <ul>
    <li><i>hdl</i> ¤¬½ñ¤­¤³¤ß²ÄÇ½¤Ç¤¢¤ì¤Ð¡¢<tt>hFlush</tt> ¤ò»ÈÍÑ¤¹¤ë
     ¤Î¤ÈÆ±ÍÍ¤Ë¥Ð¥Ã¥Õ¥¡¤Ï¥Õ¥é¥Ã¥·¥å¤µ¤ì¤ë¡£</li>
    <li><i>hdl</i> ¤¬½ñ¤­¤³¤ßÉÔ²Ä¤Ç¤¢¤ì¤Ð¡¢¥Ð¥Ã¥Õ¥¡¤ÎÆâÍÆ¤ÏÇË´þ¤µ¤ì¤ë¡£</li>
   </ul>
  </p>
  <!--  
  <p> <i>Error reporting</i>: the <tt>hSetBuffering</tt> computation may
   fail with <tt>isPermissionError</tt> if the handle has already been used
   for reading or writing and the implementation does not allow the
   buffering mode to be changed.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em>¤â¤·¡¢¥Ï¥ó¥É¥ë¤¬¤¹¤Ç¤ËÆÉ¤ß¹þ¤ß¡¢¤¢¤ë¤¤¤Ï
   ½ñ¤­½Ð¤·ÍÑ¤Ë»ÈÍÑ¤µ¤ì¤Æ¤¤¤Æ¡¢¤«¤Ä¡¢¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¥â¡¼¥É¤ÎÊÑ¹¹¤ò
   µö¤µ¤Ê¤¤¤è¤¦¤Ë¼ÂÁõ¤µ¤ì¤Æ¤¤¤ë¾ì¹ç¤Ë¤Ï¡¢<tt>hSetBuffering</tt> ·×»»¤Ï 
   <tt>isPermissionError</tt> ¤È¤Ê¤ê¼ºÇÔ¤¹¤ë¡£
  </p>
  <!--
  <p> Computation <tt>hGetBuffering</tt> <i>hdl</i> returns the current
   buffering mode for <i>hdl</i>.</p>
  -->
  <p>
   ·×»» <tt>hGetBuffering</tt> <i>hdl</i> ¤Ï <i>hdl</i> ¤Î¸½ºß¤Î
   ¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¥â¡¼¥É¤òÊÖ¤¹¡£
  </p>
  <!--
  <p> The default buffering mode when a handle is opened is
   implementation-dependent and may depend on the file system object which
   is attached to that handle.</p>
  -->
  <p>
   ¥Ï¥ó¥É¥ë¤¬¥ª¡¼¥×¥ó¤µ¤ì¤¿¤È¤­¤Î¥Ç¥Õ¥©¥ë¥È¤Î¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¥â¡¼¥É¤Ï
   ¼ÂÁõ°ÍÂ¸¤Ç¤¢¤ê¡¢¥Ï¥ó¥É¥ë¤¬³ä¤êÅö¤Æ¤é¤ì¤¿¥Õ¥¡¥¤¥ë¥·¥¹¥Æ¥à¥ª¥Ö¥¸¥§¥¯¥È
   ¤Ë°ÍÂ¸¤¹¤ë¡£
  </p>

  <p><a name="Flushing"></a></p>
  <p> <a name="sect21.6.1"></a></p>
  <!--<h4>21.6.1<tt>&nbsp;&nbsp;</tt>Flushing Buffers</h4>-->
  <h4>21.6.1<tt>&nbsp;&nbsp;</tt>¥Ð¥Ã¥Õ¥¡¤Î¥Õ¥é¥Ã¥·¥å</h4>
  <!--
  <p> Computation <tt>hFlush</tt> <i>hdl</i> causes any items buffered for
   output in handle <i>hdl</i> to be sent immediately to the operating
   system.</p>
  -->
  <p>
   ·×»» <tt>hFlush</tt> <i>hdl</i> ¤Ï¥Ï¥ó¥É¥ë <i>hdl</i> ¤Î
   ½ÐÎÏ¥Ð¥Ã¥Õ¥¡¤ÎÁ´¤Æ¤ÎÆâÍÆ¤òÄ¾¤Á¤Ë¥ª¥Ú¥ì¡¼¥Æ¥£¥ó¥°¥·¥¹¥Æ¥à¤ØÁ÷¤ê¤³¤à¡£
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hFlush</tt> computation may fail
   with: <tt>isFullError</tt> if the device is full;
   <tt>isPermissionError</tt> if a system resource limit would be exceeded.
   It is unspecified whether the characters in the buffer are discarded or
   retained under these circumstances.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em>¤â¤·¡¢¥Ç¥Ð¥¤¥¹¤¬¥Õ¥ë¤Ç¤¢¤ì¤Ð <tt>hFlush</tt> 
   ·×»»¤Ï <tt>isFullError</tt> ¤È¤Ê¤ê¡¢¥·¥¹¥Æ¥à¥ê¥½¡¼¥¹¤ÎÀ©¸Â¤ò
   Ä¶¤¨¤¿¾ì¹ç¤Ï <tt>isPermissionError</tt> ¤È¤Ê¤Ã¤Æ¼ºÇÔ¤¹¤ë¡£
   ¥Ð¥Ã¥Õ¥¡Æâ¤ÎÊ¸»ú¤¬ÇË´þ¤µ¤ì¤ë¤«¡¢¤½¤Î¤Þ¤Þ¤Î¾õÂÖ¤Ë¤Ê¤ë¤«¤Ïµ¬Äê¤µ¤ì¤Æ¤¤¤Ê¤¤¡£
  </p>

  <p><a name="Seeking"></a></p>
  <p> <a name="sect21.7"></a></p>
  <!--<h3>21.7<tt>&nbsp;&nbsp;</tt>Repositioning Handles</h3>-->
  <h3>21.7<tt>&nbsp;&nbsp;</tt>¥Ï¥ó¥É¥ë¤ÎºÆÇÛÃÖ</h3>

  <p> <a name="sect21.7.1"></a></p>
  <!--<h4>21.7.1<tt>&nbsp;&nbsp;</tt>Revisiting an I/O Position</h4>-->
  <h4>21.7.1<tt>&nbsp;&nbsp;</tt>I/O °ÌÃÖ¤ÎºÆË¬</h4>
  <!--
  <p> Computation <tt>hGetPosn</tt> <i>hdl</i> returns the current I/O
   position of <i>hdl</i> as a value of the abstract type
   <tt>HandlePosn</tt>. If a call to <tt>hGetPosn</tt><i> h</i> returns a
   position <i>p</i>, then computation <tt>hSetPosn</tt> <i>p</i> sets the
   position of <i>h</i> to the position it held at the time of the call to
   <tt>hGetPosn</tt>.</p>
  -->
  <p>
   ·×»» <tt>hGetPosn</tt> <i>hdl</i> ¤Ï <i>hdl</i> ¤Î¸½ºß¤Î I/O °ÌÃÖ¤ò
   Ãê¾Ý¥Ç¡¼¥¿·¿ <tt>HandlePosn</tt> ¤ÎÃÍ¤È¤·¤ÆÊÖ¤¹¡£¤â¤·¡¢
   <tt>hGetPosn</tt> <i>h</i> ¤Î¸Æ¤Ó½Ð¤·¤¬°ÌÃÖ <i>p</i> ¤òÊÖ¤·¤¿¤é¡¢
   ·×»»<tt>hSetPosn</tt> <i>p</i> ¤Ï <i>h</i> ¤Î°ÌÃÖ¤ò
   <tt>hGetPosn</tt> ¤¬¸Æ¤Ó½Ð¤µ¤ì¤¿»þ¤Î°ÌÃÖ¤ËÀßÄê¤¹¤ë¡£
  </p>  
  <!--
  <p> <i>Error reporting</i>: the <tt>hSetPosn</tt> computation may fail
   with: <tt>isPermissionError</tt> if a system resource limit would be
   exceeded.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em>¤â¤·¡¢¥·¥¹¥Æ¥à¥ê¥½¡¼¥¹¤ÎÀ©¸Â¤òÄ¶¤¨¤¿¤é¡¢·×»» 
   <tt>hSetPosn</tt> ¤Ï <tt>isPermissionError</tt> ¤È¤Ê¤ê¼ºÇÔ¤¹¤ë¡£
  </p>

  <p> <a name="sect21.7.2"></a></p>
  <!--<h4>21.7.2<tt>&nbsp;&nbsp;</tt>Seeking to a new Position</h4>-->
  <h4>21.7.2<tt>&nbsp;&nbsp;</tt>¿·¤·¤¤°ÌÃÖ¤Ø¤Î¥·¡¼¥¯</h4>
  <!--
  <p> Computation <tt>hSeek</tt> <i>hdl</i> <i>mode</i> <i>i</i> sets the
   position of handle <i>hdl</i> depending on <i>mode</i>. If <i>mode</i>
   is:</p>
  -->
  <p>
   ·×»» <tt>hSeek</tt> <i>hdl</i> <i>mode</i> <i>i</i> ¤Ï¥Ï¥ó¥É¥ë 
   <i>hdl</i> ¤Î°ÌÃÖ¤ò <i>mode</i> ¤Ë¤·¤¿¤¬¤Ã¤ÆÀßÄê¤¹¤ë¡£
   ¤â¤· <i>mode</i> ¤¬
  </p>
  <!--
  <ul>
   <li> <tt>AbsoluteSeek</tt>: the position of <i>hdl</i> is set to
    <i>i</i>.</li>

   <li> <tt>RelativeSeek</tt>: the position of <i>hdl</i> is set to offset
    <i>i</i> from the current position.</li>

   <li> <tt>SeekFromEnd</tt>: the position of <i>hdl</i> is set to offset
    <i>i</i> from the end of the file.</li>
  </ul>
  -->
  <p>
   <ul>
    <li><tt>AbsoluteSeek</tt> : ¤Ê¤é¤Ð¡¢<i>hdl</i> ¤Î°ÌÃÖ¤Ï <i>i</i> ¤ËÀßÄê
     ¤µ¤ì¤ë¡£</li>
    <li><tt>RelativeSeek</tt> : ¤Ê¤é¤Ð¡¢<i>hdl</i> ¤Î°ÌÃÖ¤Ï¸½ºß¤Î°ÌÃÖ¤«¤é
        ¥ª¥Õ¥»¥Ã¥È <i>i</i> ¤Î°ÌÃÖ¤ËÀßÄê¤µ¤ì¤ë¡£</li>
    <li><tt>SeekFromEnd</tt> : ¤Ê¤é¤Ð¡¢<i>hdl</i> ¤Î°ÌÃÖ¤Ï¥Õ¥¡¥¤¥ë¤Î½ªÃ¼¤«¤é
	¥ª¥Õ¥»¥Ã¥È <i>i</i> ¤Î°ÌÃÖ¤ËÀßÄê¤µ¤ì¤ë¡£</li>
   </ul>
  </p>
  <!--
  <p>The offset is given in terms of 8-bit bytes.</p>
  -->
  <p>
   ¥ª¥Õ¥»¥Ã¥È¤Ï 8-bit ¥Ð¥¤¥È¤ÇÍ¿¤¨¤é¤ì¤ë¡£
  </p>
  <!--
  <p> If <i>hdl</i> is block- or line-buffered, then seeking to a position
   which is not in the current buffer will first cause any items in the
   output buffer to be written to the device, and then cause the input
   buffer to be discarded. Some handles may not be seekable (see
   <tt>hIsSeekable</tt>), or only support a subset of the possible
   positioning operations (for instance, it may only be possible to seek to
   the end of a tape, or to a positive offset from the beginning or current
   position). It is not possible to set a negative I/O position, or for a
   physical file, an I/O position beyond the current end-of-file.</p>
  -->
  <p>
   ¤â¤·¡¢<i>hdl</i> ¤¬¥Ö¥í¥Ã¥¯¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¥â¡¼¥É¤¢¤ë¤¤¤Ï¥é¥¤¥ó
   ¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¥â¡¼¥É¤Ê¤é¡¢¸½ºß¤Î¥Ð¥Ã¥Õ¥¡Æâ¤Ë¤Ê¤¤°ÌÃÖ¤Ø¤Î¥·¡¼¥¯¤ò
   ¹Ô¤¦¤È¡¢¤Þ¤º¡¢½ÐÎÏ¥Ð¥Ã¥Õ¥¡Æâ¤Ë¤¢¤ë¥Ç¡¼¥¿¤ò¤¹¤Ù¤Æ¥Ç¥Ð¥¤¥¹¤Ë
   ½ñ¤­½Ð¤·¡¢¤½¤Î¤¢¤È¡¢ÆþÎÏ¥Ð¥Ã¥Õ¥¡¤òÇË´þ¤¹¤ë¡£°ìÉô¤Î¥Ï¥ó¥É¥ë¤Ï
   ¥·¡¼¥¯ÉÔ²ÄÇ½¤Ê¾ì¹ç¤¬¤¢¤ë( <tt>hIsSeekable</tt>¤Î¹à¤ò¸«¤è)¡£¤Þ¤¿¤Ï¡¢
   ²ÄÇ½¤Ê°ÌÃÖ¤É¤êÁàºî¤Î¤ß¤ò¥µ¥Ý¡¼¥È¤¹¤ë¾ì¹ç(¤¿¤È¤¨¤Ð¡¢¥Æ¡¼¥×¤ÎºÇ¸å¤Ë
   ¤Î¤ß°ÌÃÖ¤É¤ê¤ò¤¹¤ë¤³¤È¤¬²ÄÇ½¤Ç¤¢¤ë¤È¤«¡¢ÀèÆ¬¤Î°ÌÃÖ¤¢¤ë¤¤¤Ï¸½ºß
   °ÌÃÖ¤«¤é¤Î¥ª¥Õ¥»¥Ã¥È¤Ç¤Î¤ß°ÌÃÖ¤É¤ê¤¬¤Ç¤­¤ë¤È¤¤¤¦¤³¤È)¤â¤¢¤ë¡£
   Éé¤ÎI/O°ÌÃÖ¤òÀßÄê¤¹¤ë¤Î¤ÏÉÔ²ÄÇ½¤Ç¤¢¤ë¡£¤Þ¤¿¡¢ÊªÍýÅª¤Ê¥Õ¥¡¥¤¥ë¤Ë
   ÂÐ¤·¤Æ¸½ºß¤Î½ªÃ¼¤òÄ¶¤¨¤ë°ÌÃÖ¤É¤ê¤âÉÔ²ÄÇ½¤Ç¤¢¤ë¡£
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hSeek</tt> computation may fail with:
   <tt>isPermissionError</tt> if a system resource limit would be
   exceeded.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em> <tt>hSeek</tt> ·×»»¤Ï¥·¥¹¥Æ¥à¤Î»ñ¸»¸Â³¦¤ò
   Ä¶¤¨¤ë¤È <tt>isPerissionError</tt> ¤Ç¼ºÇÔ¤¹¤ë¡£
  </p>

  <p><a name="Query"></a></p>
  <p> <a name="sect21.8"></a></p>

  <!--  <h3>21.8<tt>&nbsp;&nbsp;</tt>Handle Properties</h3>-->
  <h3>21.8<tt>&nbsp;&nbsp;</tt>¥Ï¥ó¥É¥ë¤ÎÀ­¼Á</h3>
  <!--
  <p> The functions <tt>hIsOpen</tt>, <tt>hIsClosed</tt>,
   <tt>hIsReadable</tt>, <tt>hIsWritable</tt> and <tt>hIsSeekable
   </tt>return information about the properties of a handle. Each of these
   returns <tt>True</tt> if the handle has the specified property, and
   <tt>False</tt> otherwise.</p>
  -->
  <p>
   ´Ø¿ô
   <tt>hIsOpen</tt>¡¢ 
   <tt>hIsClosed</tt>¡¢
   <tt>hIsReadable</tt>¡¢
   <tt>hIsWritable</tt> ¤ª¤è¤Ó
   <tt>hIsSeekable</tt>
   ¤Ï¥Ï¥ó¥É¥ë¤ÎÀ­¼Á¤Ë´Ø¤¹¤ë¾ðÊó¤òÊÖ¤¹¡£¤³¤ì¤é¤Î´Ø¿ô¤Ï¥Ï¥ó¥É¥ë¤¬¡¢
   »ØÄê¤ÎÀ­¼Á¤ò¤â¤Ä¤Ê¤é <tt>True</tt> ¤òÊÖ¤·¡¢¤½¤¦¤Ç¤Ê¤±¤ì¤Ð¡¢
   <tt>False</tt> ¤òÊÖ¤¹¡£
  </p>

  <p> <a name="sect21.9"></a></p>
  <!--<h3>21.9<tt>&nbsp;&nbsp;</tt>Text Input and Output</h3>-->
  <h3>21.9<tt>&nbsp;&nbsp;</tt>¥Æ¥­¥¹¥ÈÆþ½ÐÎÏ</h3>
  <!--
  <p> Here we define a standard set of input operations for reading
   characters and strings from text files, using handles. Many of these
   functions are generalizations of Prelude functions. I/O in the Prelude
   generally uses <tt>stdin</tt> and <tt>stdout</tt>; here, handles are
   explicitly specified by the I/O operation.</p>
  -->
  <p>
   ¤³¤³¤Ç¡¢¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤«¤é¥Ï¥ó¥É¥ë¤òÍÑ¤¤¤ÆÊ¸»ú¤¢¤ë¤¤¤ÏÊ¸»úÎó¤ò
   ÆÉ¤ß½Ð¤¹¤¿¤á¤ÎÉ¸½à¤ÎÆþÎÏÁàºî·²¤òÄêµÁ¤¹¤ë¡£¤³¤ì¤é¤Î´Ø¿ô¤ÎÂ¿¤¯¤Ï
   ¥×¥ì¥ê¥å¡¼¥É¤Ë¤¢¤ë´Ø¿ô¤Î°ìÈÌ²½¤·¤¿¤â¤Î¤Ç¤¢¤ë¡£¥×¥ì¥ê¥å¡¼¥É¤ÎI/O´Ø¿ô¤Ï
   ¤Û¤È¤ó¤É¤¬¡¢<tt>stdin</tt> ¤ª¤è¤Ó <tt>stdout</tt> ¤ò»È¤¦¤â¤Î¤Ç¤¢¤ë¤¬¡¢
   ¤³¤³¤Ç¤Ï¡¢¥Ï¥ó¥É¥ë¤¬ÌÀ¼¨Åª¤ËI/OÁàºî¤Ë¤è¤Ã¤Æ»ØÄê¤µ¤ì¤Æ¤¤¤ë¡£
  </p>
  <p><a name="hReady"></a></p>
  <p> <a name="sect21.9.1"></a></p>
  <!--<h4>21.9.1<tt>&nbsp;&nbsp;</tt>Checking for Input</h4>-->
  <h4>21.9.1<tt>&nbsp;&nbsp;</tt>ÆþÎÏ¤Î¤¿¤á¤Î¥Á¥§¥Ã¥¯</h4>
  <p><a name="hWaitForInput"></a></p>
  <!--
  <p> Computation <tt>hWaitForInput</tt> <i>hdl</i> <i>t</i> waits until
   input is available on handle <i>hdl</i>. It returns <tt>True</tt> as
   soon as input is available on <i>hdl</i>, or <tt>False</tt> if no input
   is available within <i>t</i> milliseconds.</p>
  -->
  <p>
   <tt>hWaitForInput</tt> <i>hdl</i> <i>t</i> ¤Î·×»»¤Ï¥Ï¥ó¥É¥ë <i>hdl</i> 
   ¾å¤ÇÆþÎÏ¤¬ÍøÍÑ²ÄÇ½¤Ë¤Ê¤ë¤Î¤òÂÔ¤Á¹ç¤ï¤»¤ë¡£¤³¤Î´Ø¿ô¤Ï¥Ï¥ó¥É¥ë <i>hdl</i> 
   ¾å¤ÇÆþÎÏ¤¬ÍøÍÑ²ÄÇ½¤Ë¤Ê¤ê¤·¤À¤¤ <tt>True</tt> ¤òÊÖ¤¹¡£¤â¤· <i>t</i> ¥ß¥ê
   ÉÃ°ÊÆâ¤ËÆþÎÏ¤¬ÍøÍÑ²ÄÇ½¤Ë¤Ê¤é¤Ê¤±¤ì¤Ð¡¢<tt>False</tt> ¤òÊÖ¤¹¡£
  </p>
  <!--
  <p> Computation <tt>hReady</tt> <i>hdl</i> indicates whether at least one
   item is available for input from handle <i>hdl</i>.</p>
  -->
  <p>
   <tt>hReady</tt> <i>hdl</i> ¤Î·×»»¤Ï¤¹¤Ê¤¯¤È¤â 1 ¤Ä¤Î¹àÌÜ¤¬¥Ï¥ó¥É¥ë 
   <i>hdl</i> ¤ÇÍøÍÑ²ÄÇ½¤Ë¤Ê¤Ã¤Æ¤¤¤ë¤«¤É¤¦¤«¤òÉ½¼¨¤¹¤ë¡£
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hWaitForInput</tt> and
   <tt>hReady</tt> computations fail with <tt>isEOFError</tt> if the end of
   file has been reached.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em> <tt>hWaitForInput</tt>¡¢<tt>hReady</tt> ¤Î·×»»¤Ï¡¢
   ¥Õ¥¡¥¤¥ë¤Î½ªÃ¼¤ËÅþÃ£¤·¤Æ¤¤¤ë¤È <tt>isEOFError</tt> ¤Ç¼ºÇÔ¤¹¤ë¡£
  </p>

  <p> <a name="sect21.9.2"></a></p>
  <!--<h4>21.9.2<tt>&nbsp;&nbsp;</tt>Reading Input</h4>-->
  <h4>21.9.2<tt>&nbsp;&nbsp;</tt>ÆþÎÏ¤ÎÆÉ¤ß¹þ¤ß</h4>
  <!--
  <p> Computation <tt>hGetChar</tt> <i>hdl</i> reads a character from the
   file or channel managed by <i>hdl</i>.</p>
  -->
  <p>
   <tt>hGetChar</tt> <i>hdl</i> ·×»»¤Ï <i>hdl</i> ¤Ë¤è¤ê´ÉÍý¤µ¤ì¤Æ¤¤¤ë
   ¥Õ¥¡¥¤¥ë¤¢¤ë¤¤¤Ï¥Á¥ã¥Í¥ë¤«¤é°ìÊ¸»úÆÉ¤ß½Ð¤¹¡£
  </p>
  <!--
  <p> Computation <tt>hGetLine</tt> <i>hdl</i> reads a line from the file
   or channel managed by <i>hdl</i>. The Prelude's <tt>getLine</tt> is a
   shorthand for <tt>hGetLine&nbsp;stdin</tt>.</p>
  -->
  <p>
   <tt>hGetLine</tt> <i>hdl</i> ·×»»¤Ï <i>hdl</i> ¤Ë¤è¤ê´ÉÍý¤µ¤ì¤Æ¤¤¤ë
   ¥Õ¥¡¥¤¥ë¤¢¤ë¤¤¤Ï¥Á¥ã¥Í¥ë¤«¤é°ì¹ÔÆÉ¤ß½Ð¤¹¡£¥×¥ì¥ê¥å¡¼¥ÉÃæ¤Î 
   <tt>getLine</tt> ¤Ï <tt>hGetLine&nbsp;stdin</tt> ¤È¤Î¾ÊÎ¬·Á¤Ç¤¢¤ë¡£
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hGetChar</tt> computation fails with
   <tt>isEOFError</tt> if the end of file has been reached. The
   <tt>hGetLine</tt> computation fails with <tt>isEOFError</tt> if the end
   of file is encountered when reading the <i>first</i> character of the
   line. If <tt>hGetLine</tt> encounters end-of-file at any other point
   while reading in a line, it is treated as a line terminator and the
   (partial) line is returned.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em> <tt>hGetContents</tt> ·×»»¤Ï¡¢¥Õ¥¡¥¤¥ë¤Î½ªÃ¼¤Ë
   ÅþÃ£¤·¤Æ¤¤¤ì¤Ð¡¢<tt>isEOFError</tt> ¤Ç¼ºÇÔ¤¹¤ë¡£<tt>hGetLine</tt>
   ·×»»¤Ï¡¢¹Ô¤ÎºÇ½é¤ÎÊ¸»ú¤òÆÉ¤ó¤À¤È¤­¤Ë¡¢¥Õ¥¡¥¤¥ë½ªÃ¼¤Ë½Ð²ñ¤¨¤Ð¡¢
   <tt>isEOFError</tt> ¤Ç¼ºÇÔ¤¹¤ë¡£<tt>hGetLine</tt> ¤¬¤½¤ì°Ê³°¤Î
   ¾ì½ê¤Ç¥Õ¥¡¥¤¥ë½ªÃ¼¤Ë½Ð²ñ¤¨¤Ð¡¢¤½¤ì¤ò¹Ô¤Î½ªÃ¼¤È¤·¤Æ°·¤¤¡¢¤½¤Î
   (ÉôÊ¬)¹Ô¤òÊÖ¤¹¡£
  </p>
  <p><a name="hLookAhead"></a></p>
  <p> <a name="sect21.9.3"></a></p>

  <!--<h4>21.9.3<tt>&nbsp;&nbsp;</tt>Reading Ahead</h4>-->
  <h4>21.9.3<tt>&nbsp;&nbsp;</tt>ÀèÆÉ¤ß</h4>
  <!--
  <p> Computation <tt>hLookAhead</tt> <i>hdl</i> returns the next character
   from handle <i>hdl</i> without removing it from the input buffer,
   blocking until a character is available.</p>
  -->
  <p>
   <tt>hLookAhead</tt> <i>hdl</i> ¤Î·×»»¤Ï¥Ï¥ó¥É¥ë <i>hdl</i> ¤«¤é
   ¼¡¤Î°ìÊ¸»ú¤òÆÉ¤ß½Ð¤¹¤¬¡¢¤½¤ì¤òÆþÎÏ¥Ð¥Ã¥Õ¥¡¤«¤é¼è¤ê½ü¤«¤Ê¤¤¡£¤Þ¤¿¡¢
   °ìÊ¸»úÍøÍÑ²ÄÇ½¤Ë¤Ê¤ë¤Þ¤Ç¡¢¥Ö¥í¥Ã¥¯¤¹¤ë¡£
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hLookAhead</tt> computation may fail
   with: <tt>isEOFError</tt> if the end of file has been reached.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em>
   <tt>hLookahead</tt> ·×»»¤Ï¡¢¥Õ¥¡¥¤¥ë¤Î½ªÃ¼¤ËÅþÃ£¤·¤Æ¤¤¤ë¤È
   <tt>isEOFError</tt> ¤Ç¼ºÇÔ¤¹¤ë¡£
  </p>

  <p><a name="hGetContents"></a></p>
  <p> <a name="sect21.9.4"></a></p>
  <!--<h4>21.9.4<tt>&nbsp;&nbsp;</tt>Reading The Entire Input</h4>-->
  <h4>21.9.4<tt>&nbsp;&nbsp;</tt>ÆþÎÏÁ´ÂÎ¤ÎÆÉ¤ß¹þ¤ß</h4>
  <!--
  <p> Computation <tt>hGetContents</tt> <i>hdl</i> returns the list of
   characters corresponding to the unread portion of the channel or file
   managed by <i>hdl</i>, which is made semi-closed.</p>
  -->
  <p>
   <tt>hGetContents</tt> <i>hdl</i> ·×»»¤Ï <i>hdl</i> ¤Ë¤è¤ê
   ´ÉÍý¤µ¤ì¤Æ¤¤¤ë¥Õ¥¡¥¤¥ë¤¢¤ë¤¤¤Ï¥Á¥ã¥Í¥ë¤ÎÌ¤ÆÉÉôÊ¬¤Ë¤¢¤ëÊ¸»ú¤Î
   ¥ê¥¹¥È¤òÊÖ¤·¡¢¥Ï¥ó¥É¥ë¤ò¥»¥ß¥¯¥í¡¼¥º¤¹¤ë¡£
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hGetContents</tt> computation may
   fail with: <tt>isEOFError</tt> if the end of file has been reached.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em>
   <tt>hGetContents</tt> ·×»»¤Ï¡¢¥Õ¥¡¥¤¥ë¤Î½ªÃ¼¤ËÅþÃ£¤·¤Æ¤¤¤ì¤Ð¡¢
   <tt>isEOFError</tt> ¤Ç¼ºÇÔ¤¹¤ë¡£
  </p>
  <p> <a name="sect21.9.5"></a></p>
  <!--<h4>21.9.5<tt>&nbsp;&nbsp;</tt>Text Output</h4>-->
  <h4>21.9.5<tt>&nbsp;&nbsp;</tt>¥Æ¥­¥¹¥È½ÐÎÏ</h4>
  <!--
  <p> Computation <tt>hPutChar</tt> <i>hdl</i> <i>c</i> writes the
   character <i>c</i> to the file or channel managed by <i>hdl</i>.
   Characters may be buffered if buffering is enabled for <i>hdl</i>.</p>
  -->
  <p>
   <tt>hPutChar</tt> <i>hdl</i> <i>c</i> ·×»»¤ÏÊ¸»ú <i>c</i> ¤ò <i>hdl</i> 
   ¤Ç´ÉÍý¤µ¤ì¤Æ¤¤¤ë¥Õ¥¡¥¤¥ë¤¢¤ë¤¤¤Ï¥Á¥ã¥Í¥ë¤Ë½ñ¤­¹þ¤à¡£<i>hdl</i> ¤ËÂÐ¤·¤Æ
   ¥Ð¥Ã¥Õ¥¡¥ê¥ó¥°¤¬²ÄÇ½¤Ë¤Ê¤Ã¤Æ¤¤¤ì¤Ð¡¢Ê¸»ú¤Ï¥Ð¥Ã¥Õ¥¡¤ËÃß¤¨¤é¤ì¤ë¡£
  </p>
  <!--
  <p> Computation <tt>hPutStr</tt> <i>hdl</i> <i>s</i> writes the string
   <i>s</i> to the file or channel managed by <i>hdl</i>.</p>
  --> 
  <p>
   <tt>hPutStr</tt> <i>hdl</i> <i>s</i> ·×»»¤ÏÊ¸»úÎó <i>s</i> ¤ò 
   <i>hdl</i> ¤Ç´ÉÍý¤µ¤ì¤Æ¤¤¤ë¥Õ¥¡¥¤¥ë¤¢¤ë¤¤¤Ï¥Á¥ã¥Í¥ë¤Ë½ñ¤­¹þ¤à¡£
  </p>
  <!--
  <p> Computation <tt>hPrint</tt> <i>hdl</i> <i>t</i> writes the string
   representation of <i>t </i>given by the <tt>shows</tt> function to the
   file or channel managed by <i>hdl</i> and appends a newline.</p>
  -->
  <p>
   <tt>hPrint</tt> <i>hdl</i> <i>t</i> ·×»»¤Ï <tt>shows</tt> ´Ø¿ô¤Ç
   ¤¢¤¿¤¨¤é¤ì¤ë <i>t</i> ¤òÉ½¸½¤¹¤ëÊ¸»úÎó¤ò<i>hdl</i> 
   ¤Ç´ÉÍý¤µ¤ì¤Æ¤¤¤ë¥Õ¥¡¥¤¥ë¤¢¤ë¤¤¤Ï¥Á¥ã¥Í¥ë¤Ë½ñ¤­¹þ¤ß¡¢²þ¹Ô¤òÄÉ²Ã¤¹¤ë¡£
  </p>
  <!--
  <p> <i>Error reporting</i>: the <tt>hPutChar</tt>, <tt>hPutStr</tt> and
   <tt>hPrint</tt> computations may fail with:
   <tt>isFull</tt>-<tt>Error</tt> if the device is full; or
   <tt>isPermissionError</tt> if another system resource limit would be
   exceeded.</p>
  -->
  <p>
   <em>¥¨¥é¡¼Êó¹ð¡§</em>
   <tt>hPutChar</tt>¡¢<tt>hPutStr</tt> ¤ª¤è¤Ó <tt>hPrint</tt> ¤Î
   ·×»»¤Ï¥Ç¥Ð¥¤¥¹¤¬¥Õ¥ë¤Ç¤¢¤ì¤Ð <tt>isFull</tt>-<tt>Error</tt> ¤Ç¼ºÇÔ¤·¡¢
   ÊÌ¤Î¥·¥¹¥Æ¥à»ñ¸»¤ÎÀ©¸Â¤òÄ¶¤¨¤ë¤È <tt>isPermissionError</tt> ¤Ç¼ºÇÔ¤¹¤ë¡£
  </p>

  <p> <a name="sect21.10"></a></p>
  <!--<h3>21.10<tt>&nbsp;&nbsp;</tt>Examples</h3>-->
  <h3>21.10<tt>&nbsp;&nbsp;</tt>Îã</h3>
  <!--
  <p> Here are some simple examples to illustrate Haskell I/O.</p>
  -->
  <p>Haskell ¤ÎÆþ½ÐÎÏ¤òÀâÌÀ¤¹¤ë¤¿¤á¤Ë¤¤¤¯¤Ä¤«Îã¤ò¤¢¤²¤è¤¦¡£</p>

  <p> <a name="sect21.10.1"></a></p>
  <h4>21.10.1<tt>&nbsp;&nbsp;</tt>Æó¤Ä¤Î¿ô¤ÎÏÂ</h4>
  <!--
  <p> This program reads and sums two <tt>Integer</tt>s.
  -->
  <p> ¤³¤Î¥×¥í¥°¥é¥à¤ÏÆÉ¤ß¹þ¤ó¤ÀÆó¤Ä¤Î <tt>Integer</tt>¤ÎÏÂ¤ò·×»»¤¹¤ë
   <tt><br />
   <br />
   import&nbsp;IO<br />
   <br />
   main&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hSetBuffering&nbsp;stdout&nbsp;NoBuffering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;&nbsp;&nbsp;"Enter&nbsp;an&nbsp;integer:&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x1&nbsp;&lt;-&nbsp;readNum&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;&nbsp;&nbsp;"Enter&nbsp;another&nbsp;integer:&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x2&nbsp;&lt;-&nbsp;readNum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;&nbsp;("Their&nbsp;sum&nbsp;is&nbsp;"&nbsp;++&nbsp;show&nbsp;(x1+x2)&nbsp;++&nbsp;"\n")<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where&nbsp;readNum&nbsp;::&nbsp;IO&nbsp;Integer<br />
   --&nbsp;Providing&nbsp;a&nbsp;type&nbsp;signature&nbsp;avoids&nbsp;reliance&nbsp;on<br />
   --&nbsp;the&nbsp;defaulting&nbsp;rule&nbsp;to&nbsp;fix&nbsp;the&nbsp;type&nbsp;of&nbsp;x1,x2<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readNum&nbsp;=&nbsp;readLn<br />
   <br />
   </tt></p>
  
  <p> <a name="sect21.10.2"></a></p>
  <!--<h4>21.10.2<tt>&nbsp;&nbsp;</tt>Copying Files</h4>-->
  <h4>21.10.2<tt>&nbsp;&nbsp;</tt>¥Õ¥¡¥¤¥ë¤Î¥³¥Ô¡¼</h4>
  <!--
  <p> A simple program to create a copy of a file, with all lower-case
   characters translated to upper-case. This program will not allow a file
   to be copied to itself. This version uses character-level I/O. Note that
   exactly two arguments must be supplied to the program. 
  -->
  <p>
   ¥Õ¥¡¥¤¥ë¤ÎÊ£À½¤òºî¤ëÃ±½ã¤Ê¥×¥í¥°¥é¥à¤Ç¡¢¤¹¤Ù¤Æ¤Î¾®Ê¸»ú¤ÏÂçÊ¸»ú¤Ë
   ÊÑ´¹¤µ¤ì¤ë¡£¤³¤Î¥×¥í¥°¥é¥à¤Ï¼«Ê¬¼«¿È¤Ø¤Î¥³¥Ô¡¼¤Ïµö¤µ¤Ê¤¤¡£
   ¤³¤Î¥Ð¡¼¥¸¥ç¥ó¤Ç¤ÏÊ¸»ú¥ì¥Ù¥ë¤ÎÆþ½ÐÎÏ¤ò»È¤¦¡£É¬¤º¡¢¥×¥í¥°¥é¥à¤Ø¤Ï
   °ú¿ô¤òÆó¤ÄÍ¿¤¨¤Ê¤±¤ì¤Ð¤Ê¤é¤Ê¤¤¤³¤È¤ËÃí°Õ¤»¤è¡£
   <tt><br />
   <br />
   import&nbsp;IO<br />
   import&nbsp;System<br />
   import&nbsp;Char(&nbsp;toUpper&nbsp;)<br />
   <br />
   main&nbsp;=&nbsp;do&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f1,f2]&nbsp;&lt;-&nbsp;getArgs<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h1&nbsp;&lt;-&nbsp;openFile&nbsp;f1&nbsp;ReadMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h2&nbsp;&lt;-&nbsp;openFile&nbsp;f2&nbsp;WriteMode&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyFile&nbsp;h1&nbsp;h2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hClose&nbsp;h1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hClose&nbsp;h2<br />
   <br />
   copyFile&nbsp;h1&nbsp;h2&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eof&nbsp;&lt;-&nbsp;hIsEOF&nbsp;h1<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;eof&nbsp;then&nbsp;return&nbsp;()&nbsp;else<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&lt;-&nbsp;hGetChar&nbsp;h1<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hPutChar&nbsp;h2&nbsp;(toUpper&nbsp;c)&nbsp;&nbsp;&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyFile&nbsp;h1&nbsp;h2<br />
   <br />
   </tt></p>
  <!--
  <p> An equivalent but much shorter version, using string I/O is:
  -->
  <p> Ê¸»úÎó¤ÎÆþ½ÐÎÏ¤òÍÑ¤¤¤¿Æ±Åù¤Î¤º¤Ã¤ÈÃ»¤¤¥Ð¡¼¥¸¥ç¥ó¤Ï°Ê²¼¤Î¤È¤ª¤ê¡£
   <tt><br />
   <br />
   import&nbsp;System<br />
   import&nbsp;Char(&nbsp;toUpper&nbsp;)<br />
   <br />
   main&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f1,f2]&nbsp;&lt;-&nbsp;getArgs<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;&lt;-&nbsp;readFile&nbsp;f1<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeFile&nbsp;f2&nbsp;(map&nbsp;toUpper&nbsp;s)<br />
   <br />
   </tt></p>

  <p> <a name="sect21.11"></a></p>
  <!--<h3>21.11<tt>&nbsp;&nbsp;</tt>Library <tt>IO</tt></h3>-->
  <h3>21.11<tt>&nbsp;&nbsp;</tt><tt>IO</tt> ¥é¥¤¥Ö¥é¥ê</h3>
  <p>
   <tt>module&nbsp;IO&nbsp;{-&nbsp;export&nbsp;list&nbsp;omitted&nbsp;-}&nbsp;where<br />
   <br />
   --&nbsp;Just&nbsp;provide&nbsp;an&nbsp;implementation&nbsp;of&nbsp;the&nbsp;system-independent<br />
   --&nbsp;actions&nbsp;that&nbsp;IO&nbsp;exports.<br />
   <br />
   try&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;IO&nbsp;(Either&nbsp;IOError&nbsp;a)<br />
   try&nbsp;f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;catch&nbsp;(do&nbsp;r&nbsp;&lt;-&nbsp;f<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(Right&nbsp;r))<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(return&nbsp;.&nbsp;Left)<br />
   <br />
   bracket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;c)&nbsp;-&gt;&nbsp;IO&nbsp;c<br />
   bracket&nbsp;before&nbsp;after&nbsp;m&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&lt;-&nbsp;before<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rs&nbsp;&lt;-&nbsp;try&nbsp;(m&nbsp;x)<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after&nbsp;x<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;rs&nbsp;of<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;r&nbsp;-&gt;&nbsp;return&nbsp;r<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;&nbsp;e&nbsp;-&gt;&nbsp;ioError&nbsp;e<br />
   <br />
   --&nbsp;variant&nbsp;of&nbsp;the&nbsp;above&nbsp;where&nbsp;middle&nbsp;computation&nbsp;doesn't&nbsp;want&nbsp;x<br />
   bracket_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;IO&nbsp;c&nbsp;-&gt;&nbsp;IO&nbsp;c<br />
   bracket_&nbsp;before&nbsp;after&nbsp;m&nbsp;=&nbsp;do<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&lt;-&nbsp;before<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rs&nbsp;&lt;-&nbsp;try&nbsp;m<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after&nbsp;x<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;rs&nbsp;of<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;r&nbsp;-&gt;&nbsp;return&nbsp;r<br />
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;&nbsp;e&nbsp;-&gt;&nbsp;ioError&nbsp;e<br />
   </tt></p>

  <hr />

  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="monad.html">back</a> | <a
   href="directory.html">next</a> | <a href="index98.html">contents</a> |
   <a href="prelude-index.html">function index</a> <br />
   <font size="2">December 2002</font></p>
 </body>
</html>
