<!DOCTYPE html>
<html lang="ja">
 <head>
  <meta charset="utf-8">
  <!--<title>The Haskell 98 Report: Modules</title>-->
  <title>The Haskell 98 Report: モジュール</title>
 </head>

 <body bgcolor="#ffffff">
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="decls.html">back</a> | <a
   href="basic.html">next</a> | <a href="index98.html">contents</a> | <a
   href="prelude-index.html">function index</a> <br />
  </p>
  <hr />
  <p><a name="sect5"></a></p>
  <!--<h2>5<tt>&nbsp;&nbsp;</tt>Modules</h2>-->
  <h2>5<tt>&nbsp;&nbsp;</tt>モジュール</h2>
  <p><a name="modules"></a></p>
  <!--
  <p> A module defines a collection of values, datatypes, type synonyms,
   classes, etc. (see Chapter <a href="decls.html#declarations">4</a>), in
   an environment created by a set of <i>imports</i> (resources brought
   into scope from other modules). It <i>exports</i> some of these
   resources, making them available to other modules. We use the term
   <i>entity</i> to refer to a value, type, or class defined in, imported
   into, or perhaps exported from a module.</p>
  -->
  <p>モジュールは、値、データ型、型シノニム、クラスなど (<a
   href="decls.html#declarations">4</a> 章を見よ)を、他のモジュールから
   有効範囲に持ち込むリソースの集合、<em>インポート部</em>と、リソースの
   一部を他のモジュールで利用することを可能にする<em>エクスポート部</em>
   によって生成された環境において定義するものである。モジュールで定義さ
   れたり、インポートされたり、あるいはエクスポートされたりする値、型、
   クラスのことをいうのに<em>エンティティ</em>という用語を使う。</p> 
  <!--
  <p> A Haskell <i>program</i> is a collection of modules, one of which, by
   convention, must be called <tt>Main</tt> and must export the value
   <tt>main</tt>. The <i>value</i> of the program is the value of the
   identifier <tt>main</tt> in module <tt>Main</tt>, which must be a
   computation of type <tt>IO</tt> t for some type t (see Chapter <a
   href="io-13.html#io">7</a>). When the program is executed, the
   computation <tt>main</tt> is performed, and its result (of type t) is
   discarded.</p>
  -->
  <p>Haskell の<em>プログラム</em>はモジュールの集りであり、そのなかの一
   つは慣用的に <tt>Main</tt> と呼ばれるもので、値 <tt>main</tt> をエク
   スポートするものでなければならない。プログラムの<em>値</em>は
   <tt>Main</tt> モジュールの識別子 <tt>main</tt> の値である。これはある
   型 t に対する <tt>IO</tt> t 型の計算(<a href="io-13.html#io">7</a> 章
   を見よ)でなければならない。プログラムが実行されたとき、計算
   <tt>main</tt> が行われる。(型 t の)結果は破棄される。</p>
  <!--
  <p> Modules may reference other modules via explicit <tt>import</tt>
   declarations, each giving the name of a module to be imported and
   specifying its entities to be imported. Modules may be mutually
   recursive.</p>
  -->
  <p>モジュールはインポートされるモジュール名を与え、インポートするエン
   ティティを指定する明示的な <tt>import</tt> 宣言を通じて他のモジュール
   を参照する。モジュールは相互再帰にすることができる。</p>
  <!--
  <p> Modules are used for name-space control, and are not first class
   values. A multi-module Haskell program can be converted into a
   single-module program by giving each entity a unique name, changing all
   occurrences to refer to the appropriate unique name, and then
   concatenating all the module bodies (There are two minor exceptions to
   this statement. First, <tt>default</tt> declarations scope over a single
   module (Section <a href="decls.html#default-decls">4.3.4</a>). Second,
   Rule 2 of the monomorphism restriction (Section <a
   href="decls.html#sect:monomorphism-restriction">4.5.5</a>) is affected
   by module boundaries. ). For example, here is a three-module program:
  -->
  <p>モジュールは、単に名前空間を制御するためだけに使われ、モジュール自
   身は第一級の値ではない。複数モジュールからなる Haskell のプログラムは、
   それぞれのエンティティにユニークな名前をふり、すべての出現において適
   切なユニーク名を参照するように変更してから、すべてのモジュール本体を
   連結することにより、単一モジュールのプログラムに変換することができる。
   (これには、2 つのちょっとした例外がある。第一は、<tt>default</tt> 宣
   言は一つのモジュール上でのスコープしかもたない
   (<a href="decls.html#default-decls">4.3.4</a> 節)。第二に、単相性制限
   の規則 2 は(<a
   href="decls.html#sect:monomorphism-restriction">4.5.5</a> 節)
   モジュールの境界に影響される)。
   たとえば、以下は 3 つのモジュールからなるプログラムである。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;Main&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;A<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;B<br />
   &nbsp;&nbsp;&nbsp;&nbsp;main&nbsp;=&nbsp;A.f&nbsp;&gt;&gt;&nbsp;B.f<br />
   <br />
   &nbsp;&nbsp;module&nbsp;A&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;...<br />
   <br />
   &nbsp;&nbsp;module&nbsp;B&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;...<br />
   <br />
   </tt>
   <!--It is equivalent to the following single-module program:-->
   これは次の単一モジュールのプログラムと同等である。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;Main&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;main&nbsp;=&nbsp;af&nbsp;&gt;&gt;&nbsp;bf<br />
   <br />
   &nbsp;&nbsp;&nbsp;&nbsp;af&nbsp;=&nbsp;...<br />
   <br />
   &nbsp;&nbsp;&nbsp;&nbsp;bf&nbsp;=&nbsp;...<br />
   <br />
   </tt>
  <!--
   Because they are allowed to be mutually recursive, modules allow a
   program to be partitioned freely without regard to dependencies.</p>
  -->
   これらのモジュールは相互再帰的であるので、プログラムを依存性を気にす
   ることなく自由に分割することができる。</p>
  <!--
  <p> The name-space for modules themselves is flat, with each module being
   associated with a unique module name (which are Haskell identifiers
   beginning with a capital letter; i.e. <i>modid</i>). There is one
   distinguished module, <tt>Prelude</tt>, which is imported into all
   modules by default (see Section <a
   href="modules.html#standard-prelude">5.6</a>), plus a set of standard
   library modules that may be imported as required (see Part II).</p>
  -->
  <p>モジュールそのものの名前空間はフラットでそれぞれのモジュールには
   ユニークなモジュール名(Haskell では大文字ではじまる識別子、すなわち、
   <i>modid</i>)を付ける。特別なモジュール <tt>Prelude</tt> というのがあっ
   て、デフォルトですべてのプログラムにインポートされる。(<a
   href="modules.html#standard-prelude">5.6</a> 節を見よ。) さらに標準ラ
   イブラリが必要な場合にはインポートされる。(Part II を見よ。)</p> 

  <p> <a name="sect5.1"></a></p>
  <!--<h3>5.1<tt>&nbsp;&nbsp;</tt>Module Structure</h3>-->
  <h3>5.1<tt>&nbsp;&nbsp;</tt>モジュール構造</h3>
  <p><a name="module-implementations"></a></p>
  <!--
  <p> A module defines a mutually recursive scope containing declarations
   for value bindings, data types, type synonyms, classes, etc. (see
   Chapter <a href="decls.html#declarations">4</a>).</p>
  -->
  
  <p>モジュールは値束縛、データ型、型シノニム、クラス、そのほかに対する
   宣言を含む相互再帰的有効範囲を定義する。(<a
   href="decls.html#declarations">4</a> 章を見よ。)</p>

  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> module</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>module</tt> modid [exports] <tt>where</tt> body</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> body</td>
   </tr>
   <tr>
    <td> body</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>{</tt> impdecls <tt>;</tt> topdecls <tt>} </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>{</tt> impdecls <tt>} </tt></td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>{</tt> topdecls <tt>} </tt></td>
   </tr>
   <tr>
    <td> modid</td>
    <td> <tt>-&gt;</tt></td>
    <td> conid</td>
   </tr>
   <tr>
    <td> impdecls</td>
    <td> <tt>-&gt;</tt></td>
    <td> impdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> impdecl<sub>n</sub></td>
    <td> (n&gt;=1)</td>
   </tr>
   <tr>
    <td> topdecls</td>
    <td> <tt>-&gt;</tt></td>
    <td> topdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> topdecl<sub>n</sub></td>
    <td> (n&gt;=1)</td>
   </tr>
  </table>
  <!--
  <p> A module begins with a header: the keyword <tt>module</tt>, the
   module name, and a list of entities (enclosed in round parentheses) to
   be exported. The header is followed by a possibly-empty list of
   <tt>import</tt> declarations (<i>impdecls</i>, Section <a
   href="modules.html#import">5.3</a>) that specify modules to be imported,
   optionally restricting the imported bindings. This is followed by a
   possibly-empty list of top-level declarations (<i>topdecls</i>, Chapter
   <a href="decls.html#declarations">4</a>).</p>
  -->
  <p>モジュールはヘッダ部分から始まる。ヘッダ部とは、<tt>module</tt> と
   いうキーワード、モジュール名、そして、エクスポートするエンティティの
   リスト(これは丸括弧でかこまれる)である。ヘッダ部のあとには、必須では
   ないが、インポートするモジュールを指定する <tt>import</tt> 宣言のリス
   ト(<i>impdecls</i>、<a href="modules.html#import">5.3</a> 節)がつづく。
   インポートする束縛を限定することもできる。そして、その後にモジュール
   の本体とつづく。単にトップレベルの
   宣言のリスト(<i>topdecls</i>、<a
   href="decls.html#declarations">4</a>)である。</p> 
  <!--
  <p> An abbreviated form of module, consisting only of the module body, is
   permitted. If this is used, the header is assumed to be
   `<tt>module&nbsp;Main(main)&nbsp;where</tt>'. If the first lexeme in the
   abbreviated module is not a <tt>{</tt>, then the layout rule applies for
   the top level of the module.</p>
  -->
  <p>モジュールの簡略形式は、モジュールの本体のみを含むモジュールで、こ
   れは許されている。この簡略形がつかわれた場合、ヘッダ部は
   `<tt>module&nbsp;Main(main)&nbsp;where</tt>' と仮定する。簡略形のモ
   ジュールの最初の字句が <tt>{</tt> ではない場合、レイアウト規則がこの
   モジュールのトップレベルに対して適用される。</p>

  <p><a name="export"></a></p>
  <p><a name="sect5.2"></a></p>
  <!--<h3>5.2<tt>&nbsp;&nbsp;</tt>Export Lists</h3>-->
  <h3>5.2<tt>&nbsp;&nbsp;</tt>エクスポートリスト</h3>
  <p></p>
  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr></tr>
   <tr>
    <td> exports</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>(</tt> export<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     export<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> export</td>
    <td> <tt>-&gt;</tt></td>
    <td> qvar</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> qtycon [<tt>(..)</tt> | <tt>(</tt> cname<sub>1</sub> <tt>,</tt>
     ... <tt>,</tt> cname<sub>n</sub> <tt>)</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> qtycls [<tt>(..)</tt> | <tt>(</tt> var<sub>1</sub> <tt>,</tt> ...
     <tt>,</tt> var<sub>n</sub> <tt>)</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>module</tt> modid</td>
   </tr>
   <tr>
    <td> cname</td>
    <td> <tt>-&gt;</tt></td>
    <td> var | con</td>
   </tr>
  </table>
  <!--
  <p> An <i>export list</i> identifies the entities to be exported by a
   module declaration. A module implementation may only export an entity
   that it declares, or that it imports from some other module. If the
   export list is omitted, all values, types and classes defined in the
   module are exported, <i>but not those that are imported</i>.</p>
  -->
  <p><em>エクスポートリスト</em>はモジュール宣言によりエクスポートされる
   エンティティを同定するものである。モジュールの実装はこれが宣言するエ
   ンティティあるいは他にモジュールからインポートされたもののみをエクス
   ポートする。エクスポートリストが省略された場合、このモジュールで定義
   されたすべての値、型、クラスがエクスポートされる。<em>ただし、インポー
   トされたものについてはエクスポートされない。</em></p>
  <!--
  <p> Entities in an export list may be named as follows:</p>
  -->
  <p>エクスポートリストにあるエンティティは以下のように名前付けされる。</p>
  <ol>
   <li>
    <!--
    A value, field name, or class method, whether declared in the
    module body or imported, may be named by giving the name of the value
    as a <i>qvarid</i>, which must be in scope. Operators should be
    enclosed in parentheses to turn them into <i>qvarid</i>s.
    <p></p>
    -->
    <p>値、フィールドネーム、あるいはクラスメソッドは当該モジュール本体
     で宣言されているかインポートされている場合、<i>qvarid</i> をその値の
     名前として与えられ名前付けされる。演算子は括弧でかこって、
     <i>qvarid</i> としな ければならない。</p> 
   </li>

   <li>
    <!--
    An algebraic datatype <i>T </i>declared by a <tt>data</tt> or
    <tt>newtype</tt> declaration may be named in one of three ways:
    -->
    <p><tt>data</tt> 宣言あるいは <tt>newtype</tt> 宣言による代数データ型
     <i>T</i> 次の 3 つ方法のうちどれかによって名前を付けることができる。
     <ul>
      <li>
       <!-- 
       The form <i>T</i> names the type <i>but not the constructors or
       field names</i>. The ability to export a type without its
       constructors allows the construction of abstract datatypes (see
       Section <a href="modules.html#abstract-types">5.8</a>).
       -->
       <i>T</i> という形式は型に対して名前を与えるが、<em>構成子あるいは
       フィールドの名前を与えるものではない。</em> 構成子なしで型をエク
       スポートすることが可能であるため、抽象データ型
       (<a href="modules.html#abstract-types">5.8</a> 節を見よ)の構築が
       可能である。
       </li>
      <li>
       <!--
       The form
       T<tt>(</tt>c<sub>1</sub><tt>,</tt>...<tt>,</tt>c<sub>n</sub><tt>)</tt>,
       names the type and some or all of its constructors and field
       names.
       -->
       T<tt>(</tt>qcname<sub>1</sub><tt>,</tt>...<tt>,</tt>qcname<sub>n</sub><tt>)</tt> 
       という形式は、qcname<sub>i</sub> が T 内の構成子およびフィールド
       名に名前をあたえるもので、これは型とその構成子およびフィールド名
       の一部あるいは全部は名前を与えるものである。qcname<sub>i</sub> は
       重複を含んではならない。</li>
      <li>
       <!--
       The abbreviated form <i>T</i><tt>(..)</tt> names the type and all
       its constructors and field names that are currently in scope (whether
       qualified or not).
       -->
       <i>T</i><tt>(..)</tt> という簡略形式は型および、現在の有効範囲に
       ある(限定修飾の有無を問わず)その構成子およびフィールド名のすべて
       に名前を与える。</li>
     </ul>
    <!--
     In all cases, the (possibly-qualified) type constructor <i>T</i> must
     be in scope. The constructor and field names c<sub>i</sub> in the
     second form are unqualified; one of these subordinate names is legal if
     and only if (a) it names a constructor or field of <i>T</i>, and (b)
     the constructor or field is in scope in the module body <i>regardless
     of whether it is in scope under a qualified or unqualified name</i>.
     For example, the following is legal 
    -->
     すべての場合において、(おそらくは修飾されている)型構成子 <i>T</i>
     はスコープ内になければならない。第二の形式の構成子とフィールド名
     c<sub></sub> は修飾されていない。これらの従属名のひとつは
     次の場合にかぎって正当である。(a) <i>T</i> の構成子あるいはフィール
     ド名であり、かつ、その構成子あるいはフィールド名が、そのモジュール
     本体のスコープ内にある場合。<em>それが修飾された名前もとでスコープ
     内にあるか、修飾されていない名前のもとでスコープ内であるかに関係し
     ない</em>。
     <tt><br />
     <br />
     &nbsp;&nbsp;module&nbsp;A(&nbsp;Mb.Maybe(&nbsp;Nothing,&nbsp;Just&nbsp;)&nbsp;)&nbsp;where<br />
     &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;qualified&nbsp;Maybe&nbsp;as&nbsp;Mb<br />
     <br />
     </tt>
    <!--
     Data constructors cannot be named in export lists except as
     subordinate names, because they cannot otherwise be distinguished from
     type constructors.
    </p>
    -->
    データ構成子は subordinate 名として以外でエクスポートリストのなかで
    名前を与えることはできない。そうでなければ、型構成子と区別がつかない
    からである。</p>
   </li>
   <li>
    <!--
    A type synonym <i>T</i> declared by a <tt>type</tt> declaration may
    be named by the form <i>T</i>, where <i>T</i> is in scope.
    <p></p>
    -->
    <p><tt>type</tt> 宣言による型シノニム <i>T</i> は <i>T</i> という形
   式で名 前を与えることができる。ここで、<i>T</i> はスコープ内にあると
   する。</p> 
   </li>
   <li> 
    <!--
    A class C with operations f<sub>1</sub>,...,f<sub>n</sub> declared
    in a <tt>class</tt> declaration may be named in one of three ways:
    <ul>
     <li> The form <i>C</i> names the class <i>but not the class
      methods</i>.</li>
     <li> The form
      C<tt>(</tt>f<sub>1</sub><tt>,</tt>...<tt>,</tt>f<sub>n</sub><tt>)</tt>,
      names the class and some or all of its methods.</li>
     <li> The abbreviated form C<tt>(..)</tt> names the class and all its
      methods that are in scope (whether qualified or not).</li>
    </ul>
    In all cases, <i>C</i> must be in scope. In the second form, one of the
    (unqualified) subordinate names f<sub>i</sub> is legal if and only if
    (a) it names a class method of <i>C</i>, and (b) the class method is in
    scope in the module body regardless of whether it is in scope under a
    qualified or unqualified name.
    <p></p>
    -->
    <p><tt>class</tt> 宣言による演算 f<sub>1</sub>,...,f<sub>n</sub> をもつ
    クラス C は次の 3 つの方法のどれかで名前があたえられる。
    <ul>
     <li><i>C</i> という形式はそのクラスに名前を与えるが<em>クラスメソッド
      には名前を与えない。</em></li>
     <li>C<tt>(</tt>f<sub>1</sub><tt>,</tt>...<tt>,</tt>f<sub>n</sub><tt>)</tt>
      という形式は、そのクラスとそのクラスのいくつかあるいはすべてのメソッ
      ドに名前を与える。</li> 
     <li> 簡略形式 C<tt>(..)</tt> は有効範囲で(修飾のあるなしにかかわら
      ず)クラスとクラスのメソッドすべてに名前を与える。</li>
    </ul>
    すべての場合において、<i>C</i> は有効範囲内になければならない。第 2
    の形式では以下の場合に限って(修飾されていない)従属名 f<sub>i</sub>
    の一つが正しいものとなる。(a) <i>C</i> のクラスメソッドに名前を与え
    るものであり、かつ、(b)そのクラスのメソッドがそのモジュール本体の中
    でスコープ内にある場合。それが修飾された名前もとでスコープ内にあるか、
    修飾されていない名前のもとでスコープ内であるかに関係しない。
    </p></li>
   <li>
    <!--
    The form "<tt>module&nbsp;M</tt>" names the set of all entities
    that are in scope with both an unqualified name "<tt>e</tt>" and a
    qualified name "<tt>M.e</tt>". This set may be empty. For example:
    -->
    <p>"<tt>module&nbsp;M</tt>" という形式は、修飾されていない名前
     "<tt>e</tt>" および修飾された名前 "<tt>M.e</tt>" の両方のスコープ
     内にあるすべてのエンティティの集合に名前をあたえる。この集合は空で
     もよい。たとえば、
     <tt><br />
     <br />
     &nbsp;&nbsp;module&nbsp;Queue(&nbsp;module&nbsp;Stack,&nbsp;enqueue,&nbsp;dequeue&nbsp;)&nbsp;where<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;Stack<br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />
     <br />
     </tt>
     <!--
     Here the module <tt>Queue</tt> uses the module name <tt>Stack</tt>
     in its export list to abbreviate all the entities imported from
     <tt>Stack</tt>.</p>
     -->
     ここでモジュール <tt>Queue</tt> は <tt>Stack</tt> からインポートさ
     れた全てのエンティティを纏めるために、エクスポートリストの中で、モ
     ジュール名 <tt>Stack</tt> を使っている。</p>
    <!--
    <p> A module can name its own local definitions in its export list
     using its own name in the "<tt>module&nbsp;M</tt>" syntax, because a
     local declaration brings into scope both a qualified and unqualified
     name (Section <a href="modules.html#qualifiers">5.5.1</a>). For
     example:
    -->
    <p>ひとつのモジュールはそれ自身の局所定義に、エクスポートリスト内で
     <tt>module&nbsp;M</tt> という構文で自身の名前をつかうことで、名前
     を与えることができる。局所的な宣言はそのスコープに修飾された名前と
     修飾されない名前の両方を持ち込むからである
     (<a href="modules.html#qualifiers">5.5.1</a> 節)。たとえば、
     <tt><br />
     <br />
     &nbsp;&nbsp;module&nbsp;Mod1(&nbsp;module&nbsp;Mod1,&nbsp;module&nbsp;Mod2&nbsp;)&nbsp;where<br />
     &nbsp;&nbsp;import&nbsp;Mod2<br />
     &nbsp;&nbsp;import&nbsp;Mod3<br />
     <br />
     </tt>
    <!--
     Here module <tt>Mod1</tt> exports all local definitions as well
     as those imported from <tt>Mod2</tt> but not those imported from
     <tt>Mod3</tt>.</p>
    -->
    ここで、モジュール <tt>Mod1</tt> はそのすべての局所定義と
     <tt>Mod2</tt> からインポートしたすべての定義をエクスポートしいるが、
     <tt>Mod3</tt> か らインポートしたものはエクスポートしていない。</p>
    <!--
    <p> It is an error to use <tt>module&nbsp;M</tt> in an export list
     unless <tt>M</tt> is the module bearing the export list, or <tt>M</tt>
     is imported by at least one import declaration (qualified or
     unqualified).</p>
    -->
    <p>エクスポートリスト中で <tt>module&nbsp;M</tt> を使うのは、
     以下の場合のどちらかでなければ、誤りである。<tt>M</tt> が
     エクスポートリストから生れたものであるか、あるいは <tt>M</tt> が
     (限定修飾されているかどうかにかかわらず)少くともひとつのインポート
     宣言によってインポートされている。</p>
   </li>
  </ol>
  <!--
  <p>Exports lists are cumulative: the set of entities exported by an
   export list is the union of the entities exported by the individual
   items of the list.</p>
  -->
  <p>エクスポートリストは cumulative である。エクスポートリストにより
   エクスポートされるエンティティの集合は、そのリストの個別の項目により
   エクスポートされるエンティティの和集合である。</p>
  <!--
  <p> It makes no difference to an importing module how an entity was
   exported. For example, a field name <tt>f</tt> from data type <tt>T</tt>
   may be exported individually (<tt>f</tt>, item (1) above); or as an
   explicitly-named member of its data type (<tt>T(f)</tt>, item (2)); or
   as an implicitly-named member (<tt>T(..)</tt>, item(2)); or by exporting
   an entire module (<tt>module&nbsp;M</tt>, item (5)).</p>
  -->
  <p>エンティティがどのようにエクスポートされたかは、モジュールの
   インポートに差をつけるものではない。たとえば、データ型 <tt>T</tt>
   のフィールド名 <tt>f</tt> は (<tt>f</tt>、上の(1)の場合)のように
   個別にエクスポートすことができる。また、そのデータ型の明示的名前の
   メンバーとして(<tt>T(f)</tt>、(2)の場合)エクスポートすることもできる。
   また、暗黙的名前のメンバー(<tt>T(...)</tt>、(2)の場合)としても
   エクスポートできる。さらに、モジュール全体をエクスポートすること
   (<tt>module&nbsp;M</tt>、(5)の場合)でエクスポートすることができる。
   </p>
  <!--
  <p> The <i>unqualified</i> names of the entities exported by a module
   must all be distinct (within their respective namespace). For example
  -->
  <p>モジュールによってエクスポートされたエンティティの
   <em>限定修飾されていない</em>名前は(それが属している
   名前空間において)すべて別々のものでなければならない。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;A&nbsp;(&nbsp;C.f,&nbsp;C.g,&nbsp;g,&nbsp;module&nbsp;B&nbsp;)&nbsp;where&nbsp;&nbsp;&nbsp;--&nbsp;an&nbsp;invalid&nbsp;module<br />
   &nbsp;&nbsp;import&nbsp;B(f)<br />
   &nbsp;&nbsp;import&nbsp;qualified&nbsp;C(f,g)<br />
   &nbsp;&nbsp;g&nbsp;=&nbsp;f&nbsp;True<br />
   <br />
   </tt>
  <!--
   There are no name clashes within module <tt>A</tt> itself, but
   there are name clashes in the export list between <tt>C.g</tt> and <tt>g
   </tt>(assuming <tt>C.g</tt> and <tt>g</tt> are different entities --
   remember, modules can import each other recursively), and between
   <tt>module&nbsp;B</tt> and <tt>C.f </tt>(assuming <tt>B.f</tt> and
   <tt>C.f</tt> are different entities).</p>
  -->
   モジュール <tt>A</tt> そのものの中では名前の衝突はないが、
   エクスポートリスト中の <tt>C.g</tt> と <tt>g</tt> では衝突がある
   (<tt>C.g</tt> と <tt>g</tt> は別のエンティティであることを
   仮定している -- モジュールは相互再帰的にインポートできることを
   思い出せ)。また、<tt>module&nbsp;B</tt> と <tt>C.f</tt> との間にも
   衝突がある( <tt>B.f</tt> と <tt>C.f</tt> は別のエンティティであること
   を仮定する)。</p>

  <p><a name="import"></a></p>
  <p><a name="sect5.3"></a></p>

  <!--<h3>5.3<tt>&nbsp;&nbsp;</tt>Import Declarations</h3>-->
  <h3>5.3<tt>&nbsp;&nbsp;</tt>インポート宣言</h3>

  <p></p>

  <table cellspacing="0" cellspacing="0">
   <tr>
    <td width="100"></td>
    <td width="20"></td>
    <td width="250"></td>
   </tr>
   <tr>
    <td> impdecl</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>import</tt> [<tt>qualified</tt>] modid [<tt>as</tt> modid]
     [impspec]</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td></td>
    <td> (empty declaration)</td>
   </tr>
   <tr>
    <td> impspec</td>
    <td> <tt>-&gt;</tt></td>
    <td> <tt>(</tt> import<sub>1</sub> <tt>,</tt> ... <tt>,</tt>
     import<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> <tt>hiding</tt> <tt>(</tt> import<sub>1</sub> <tt>,</tt> ...
     <tt>,</tt> import<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt></td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> import</td>
    <td> <tt>-&gt;</tt></td>
    <td> var</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> tycon [ <tt>(..)</tt> | <tt>(</tt> cname<sub>1</sub> <tt>,</tt>
     ... <tt>,</tt> cname<sub>n</sub> <tt>)</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td></td>
    <td> <tt>|</tt></td>
    <td> tycls [<tt>(..)</tt> | <tt>(</tt> var<sub>1</sub> <tt>,</tt> ...
     <tt>,</tt> var<sub>n</sub> <tt>)</tt>]</td>
    <td> (n&gt;=0)</td>
   </tr>
   <tr>
    <td> cname</td>
    <td> <tt>-&gt;</tt></td>
    <td> var | con</td>
   </tr>
  </table>
  <!--
  <p> The entities exported by a module may be brought into scope in
   another module with an <tt>import </tt>declaration at the beginning of
   the module. The <tt>import</tt> declaration names the module to be
   imported and optionally specifies the entities to be imported. A single
   module may be imported by more than one <tt>import</tt> declaration.
   Imported names serve as top level declarations: they scope over the
   entire body of the module but may be shadowed by local non-top-level
   bindings.</p>
  -->
  <p> モジュールによりエクスポートされたエンティティは、別のモジュールの
   最初の部分で <tt>import</tt> 宣言することで、そのモジュールの有効範囲
   に持ち込むことができる。<tt>import</tt> 宣言は、インポートする
   モジュールに名前を付け、オプションとしてインポートするエンティティを
   指定する。単一のモジュールが複数の <tt>import</tt> 宣言により
   インポートすることが可能である。インポートされた名前はトップレベル
   の宣言として機能し、そのモジュールの本体全体に渡る有効範囲をもつが、
   トップレベルではない局所的な束縛により覆い隠される可能性がある。</p>
  <!--
  <p> The effect of multiple <tt>import</tt> declarations is strictly
   cumulative: an entity is in scope if it is imported by any of the
   <tt>import </tt>declarations in a module. The ordering of import
   declarations is irrelevant.</p>
  -->
  <p>複数の <tt>import</tt> 宣言の効果は厳密に累積的である。すなわち、
   一つのエンティティは、あるモジュール内のすべての <tt>import</tt> 
   宣言によって名付られたものの有効範囲内にある。このとき、インポート
   の順は関係ない。</p>
  <!--
  <p> Lexically, the terminal symbols "<tt>as</tt>", "<tt>qualified</tt>"
   and "<tt>hiding</tt>" are each a <i>varid</i> rather than a
   <i>reservedid</i>. They have special significance only in the context of
   an <tt>import</tt> declaration; they may also be used as variables.</p>
  -->
  <p> 字句構造としては、終端記号「<tt>as</tt>」、
   「<tt>qualified</tt>」、「<tt>hiding</tt>」はそれぞれ、<i>varid</i>
   であって、<i>reservedid</i> ではない。これらは <tt>import</tt> 宣言
   の文脈中でのみ特別な意味をもち、それ以外では変数として用いることが
   できる。</p>

  <p><a name="whatisimported"></a></p>
  <p><a name="sect5.3.1"></a></p>

  <!--<h4>5.3.1<tt>&nbsp;&nbsp;</tt>What is imported</h4>-->
  <h4>5.3.1<tt>&nbsp;&nbsp;</tt>インポートされるもの</h4>

  <!--
  <p> Exactly which entities are to be imported can be specified in one of
   the following three ways:</p>
  -->
  <p> どのエンティティがインポートされるかは、正確には次の3つの方法のうち
   どれかの方法で指定することができる。</p>

  <ol>
   <!--
   <li><p> The imported entities can be specified explicitly by listing them
    in parentheses. Items in the list have the same form as those in export
    lists, except qualifiers are not permitted and the `<tt>module</tt>
    <i>modid</i>' entity is not permitted. When the <tt>(..)</tt> form of
    import is used for a type or class, the <tt>(..)</tt> refers to all of
    the constructors, methods, or field names exported from the module.</p>
    <p> The list must name only entities exported by the imported module.
     The list may be empty, in which case nothing except the instances is
     imported.</p>
   </li>
   -->
   <li><p> インポートするエンティティを明示的に括弧の中でリストアップする。
     このリスト内の項目はエクスポートリストないのそれと同じ形式である。
     ただし、限定修飾子は許されないことと、「<tt>module</tt> <I>modid</I>」
     というエンティティが許されないことが例外である。<tt>(..)</tt> とい
     う形式が型やクラスに対して使用された場合、<tt>(..)</tt> は、その
     モジュールからエクスポートされた、そのすべての構成子、メソッド、あるいは
     フィールド名をあらわす。</p>
     <p>インポートリストはインポートするモジュールがエクスポートしている
     エンティティのみ名指ししなければならない。空のリスト
     であってもかまわない。その場合はそのインスタンス以外はなにも
     インポートされない。</p></li>
   <!--
   <li> Entities can be excluded by using the form
    <tt>hiding(</tt><i>import</i><sub><i>1</i></sub><i> </i><tt>,</tt><i>
    ... </i><tt>,</tt><i> import</i><sub><i>n</i></sub> <tt>)</tt>, which
    specifies that all entities exported by the named module should be
    imported except for those named in the list. Data constructors may be
    named directly in hiding lists without being prefixed by the associated
    type. Thus, in <tt><br />
    <br />
    &nbsp;&nbsp;import&nbsp;M&nbsp;hiding&nbsp;(C)<br />
    <br />
    </tt>any constructor, class, or type named <tt>C</tt> is excluded. In
    contrast, using <tt>C</tt> in an import list names only a class or
    type.
    <p> It is an error to hide an entity that is not, in fact, exported by
     the imported module.</p>
   </li>
   -->
   <li><p><tt>hiding(</tt><I>import</I><sub><I>1</I></sub><I>
    </I><tt>,</tt><I> ... </I><tt>,</tt><I>
    import</I><sub><I>n</I></sub><tt>)</tt> という形式を使用することに
    よりエンティティを除外することができる。これは、その名指しされたモ
    ジュールによりエクスポートされるすべてのエンティティはそのリスト内
    の名指しされたエンティティを除いてすべてインポートすることを指示し
    ている。データ構成子は隠蔽リストのなかで直接名指しされその型名が接
    頭辞としてつくことはない。それゆえ、
    <tt><br>
    <br>
    &nbsp;&nbsp;import&nbsp;M&nbsp;hiding&nbsp;(C)<br>
    <br>
    </tt>
    では <tt>C</tt> という名前の構成子、クラス、型のすべてが除外される。
    一方、インポートリスト内で <tt>C</tt> を使うとこれはクラスあるいは
    タイプだけが対象となる。</p>
    <p>インポートされるモジュールによってエクスポートされてない
     エンティティを隠蔽しようとすることはエラーである。</p>
   </li>
   <!--
   <li> Finally, if <i>impspec</i> is omitted then all the entities
    exported by the specified module are imported.</li>
   -->
   <li><p><i>impspec</i> が省略された場合は、指定されたモジュールにより
    エクスポートされたすべてのエンティティがインポートされる。</p>
   </li>
  </ol>

  <p> <a name="sect5.3.2"></a></p>
  <!--<h4>5.3.2<tt>&nbsp;&nbsp;</tt>Qualified import</h4>-->
  <h4>5.3.2<tt>&nbsp;&nbsp;</tt>修飾子付インポート</h4>
  <!--
  <p> For each entity imported under the rules of Section <a
   href="modules.html#whatisimported">5.3.1</a>, the top-level environment
   is extended. If the import declaration used the <tt>qualified</tt>
   keyword, only the <i>qualified name</i> of the entity is brought into
   scope. If the <tt>qualified</tt> keyword is omitted, then <i>both</i>
   the qualified <i>and</i> unqualified name of the entity is brought into
   scope. Section <a href="modules.html#qualifiers">5.5.1</a> describes
   qualified names in more detail.</p>
  -->
  <p> <a href="modules.html#whatisimported">5.3.1</a>節のルールで
   インポートされたそれぞれのエンティティごとに、トップレベルの環境が
   拡張される。<tt>qualified</tt> キーワードを使ったインポート宣言に
   よってスコープに持ち込まれる名前は、インポートされたエンティティの
   <em>修飾された名前</em>だけである。<tt>qualified</tt> キーワードを
   省略すると、修飾された名前と修飾されない名前の両方がスコープに持ち
   込まれる。修飾されあた名前については
   <a href="modules.html#qualifiers">5.5.1</a> 節で詳述する。</p>
  <!--
  <p> The qualifier on the imported name is either the name of the imported
   module, or the local alias given in the <tt>as</tt> clause (Section <a
   href="modules.html#as-clause">5.3.3</a>) on the <tt>import</tt>
   statement. Hence, <i>the qualifier is not necessarily the name of the
   module in which the entity was originally declared</i>.</p>
  -->
  <p>インポートされた名前に付く修飾子はインポートされたモジュールの名前で
  あるか、<tt>import</tt> ステートメントに付いた <tt>as</tt> 節
  (<a href="modules.html#as-clause">5.3.3</a> 節)により与えられた局所的な
  別名のどちらかである。それゆえ、<em>修飾子はエンティティがもともと
  宣言されていたモジュールの名前である必要はない。</em></p>
  <!--
  <p> The ability to exclude the unqualified names allows full programmer
   control of the unqualified namespace: a locally defined entity can share
   the same name as a qualified import: 
  -->
  <p> 修飾されていない名前を排除できるので、プログラマは修飾されて
   いない名前空間を完全に制御することができる。すなわち、局所的に
   定義されたエンティティは修飾されてインポートされたものと同じ名前を
   共有することができる。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;Ring&nbsp;where<br />
   &nbsp;&nbsp;import&nbsp;qualified&nbsp;Prelude&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;All&nbsp;Prelude&nbsp;names&nbsp;must&nbsp;be&nbsp;qualified<br />
   &nbsp;&nbsp;import&nbsp;List(&nbsp;nub&nbsp;)<br />
   <br />
   &nbsp;&nbsp;l1&nbsp;+&nbsp;l2&nbsp;=&nbsp;l1&nbsp;Prelude.++&nbsp;l2&nbsp;&nbsp;--&nbsp;This&nbsp;+&nbsp;differs&nbsp;from&nbsp;the&nbsp;one&nbsp;in&nbsp;the&nbsp;Prelude<br />
   &nbsp;&nbsp;l1&nbsp;*&nbsp;l2&nbsp;=&nbsp;nub&nbsp;(l1&nbsp;+&nbsp;l2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;This&nbsp;*&nbsp;differs&nbsp;from&nbsp;the&nbsp;one&nbsp;in&nbsp;the&nbsp;Prelude<br />
   <br />
   &nbsp;&nbsp;succ&nbsp;=&nbsp;(Prelude.+&nbsp;1)<br />
   <br />
   </tt>
  </p>   

  <p> <a name="as-clause"></a></p>
  <p> <a name="sect5.3.3"></a></p>

  <!--<h4>5.3.3<tt>&nbsp;&nbsp;</tt>Local aliases</h4>-->
  <h4>5.3.3<tt>&nbsp;&nbsp;</tt>局所的な別名</h4>

  <!--
  <p> Imported modules may be assigned a local alias in the importing
   module using the <tt>as</tt> clause. For example, in 
  -->
  <p> インポートされたモジュールには、<tt>as</tt> 節を用いてインポート
   したモジュール内で局所的な別名を割当ることができる。たとえば、
   <tt><br />
   <br />
   &nbsp;&nbsp;import&nbsp;qualified&nbsp;VeryLongModuleName&nbsp;as&nbsp;C<br />
   <br />
   </tt>
  <!--
   entities must be referenced using `<tt>C.</tt>' as a qualifier
   instead of `<tt>VeryLongModuleName.</tt>'. This also allows a different
   module to be substituted for <tt>VeryLongModuleName</tt> without
   changing the qualifiers used for the imported module. It is legal for
   more than one module in scope to use the same qualifier, provided that
   all names can still be resolved unambiguously. For example: 
  -->
   では、エンティティは`<tt>C.</tt>'を`<tt>Complex</tt>'の代わりに
   修飾子として使用して参照しなければならない。このことにより別の
   モジュールをインポートされたモジュールに対して用いられた修飾子を
   変更することなく<tt>Complex</tt> に対して置換えることができる。
   これにより、スコープ内にある 2 つ以上のモジュールが同じ修飾子を
   使うことは、すべての名前が曖昧なところなく解決可能であれば、
   正当である。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;M&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;qualified&nbsp;Foo&nbsp;as&nbsp;A<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;qualified&nbsp;Baz&nbsp;as&nbsp;A<br />
   &nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;A.f<br />
   <br />
   </tt>
  <!--
   This module is legal provided only that <tt>Foo</tt> and
   <tt>Baz</tt> do not both export <tt>f</tt>.</p>
  -->
   このモジュールは、<tt>Foo</tt> および <tt>Baz</tt> のどちらもが
   <tt>f</tt> をエクスポートしているということがないかぎり、正当である。</p>
  <!--
  <p> An <tt>as</tt> clause may also be used on an un-<tt>qualified</tt>
   <tt>import</tt> statement: 
  -->
  <p> <tt>as</tt> 節は、<tt>qualified</tt> が付かない <tt>import</tt> 
   ステートメント上で使うこともできる。
   <tt><br />
   <br />
   &nbsp;&nbsp;import&nbsp;Foo&nbsp;as&nbsp;A(f)<br />
   <br />
   </tt>
  <!--
   This declaration brings into scope <tt>f</tt> and <tt>A.f</tt>.</p>
  -->
   この宣言はスコープに <tt>f</tt> および <tt>A.f</tt> 持ち込む。</p>

  <p> <a name="sect5.3.4"></a></p>
  <!--<h4>5.3.4<tt>&nbsp;&nbsp;</tt>Examples</h4>-->
  <h4>5.3.4<tt>&nbsp;&nbsp;</tt>例</h4>

  <!--
  <p> To clarify the above import rules, suppose the module <tt>A</tt>
   exports <tt>x</tt> and <tt>y</tt>. Then this table shows what names are
   brought into scope by the specified import statement:</p>
  -->
  <p>上述のインポート規則を明確にするために、モジュール <tt>A</tt> が
   <tt>x</tt> と <tt>y</tt>をエクスポートしていると仮定する。以下の表は
   それぞれのインポート宣言によってスコープに持ち込まれる名前を示すもの
   である。</p>

  <div align="center">
   <table>
    <tr>
     <td> Import declaration</td>
     <td> Names brought into scope</td>
    </tr>
    <tr>
     <td> <tt>import&nbsp;A</tt></td>
     <td> <tt>x</tt>, <tt>y</tt>, <tt>A.x</tt>, <tt>A.y</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;A()</tt></td>
     <td> (nothing)</td>
    </tr>
    <tr>
     <td><tt>import&nbsp;A(x)</tt></td>
     <td> <tt>x</tt>, <tt>A.x</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;qualified&nbsp;A</tt></td>
     <td> <tt>A.x</tt>, <tt>A.y</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;qualified&nbsp;A()</tt></td>
     <td> (nothing)</td>
    </tr>
    <tr>
     <td><tt>import&nbsp;qualified&nbsp;A(x)</tt></td>
     <td> <tt>A.x</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;A&nbsp;hiding&nbsp;()</tt></td>
     <td> <tt>x</tt>, <tt>y</tt>, <tt>A.x</tt>, <tt>A.y</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;A&nbsp;hiding&nbsp;(x)</tt></td>
     <td> <tt>y</tt>, <tt>A.y</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;qualified&nbsp;A&nbsp;hiding&nbsp;()</tt></td>
     <td> <tt>A.x</tt>, <tt>A.y</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;qualified&nbsp;A&nbsp;hiding&nbsp;(x)</tt></td>
     <td> <tt>A.y</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;A&nbsp;as&nbsp;B</tt></td>
     <td> <tt>x</tt>, <tt>y</tt>, <tt>B.x</tt>, <tt>B.y</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;A&nbsp;as&nbsp;B(x)</tt></td>
     <td> <tt>x</tt>, <tt>B.x</tt></td>
    </tr>
    <tr>
     <td><tt>import&nbsp;qualified&nbsp;A&nbsp;as&nbsp;B</tt></td>
     <td> <tt>B.x</tt>, <tt>B.y</tt></td>
    </tr>
    <tr>
     <td></td>
    </tr>
   </table>
  </div>

  <!--
  <p>In all cases, all instance declarations in scope in module <tt>A</tt>
   are imported (Section <a
   href="modules.html#import-instances">5.4</a>).</p>
  -->
  <p>どの場合にも、モジュール <tt>A</tt> のスコープにあるすべての
   インスタンス宣言がインポートされる
   (<a href="modules.html#import-instances">5.4</a> 節)</p>


  <p> <a name="import-instances"></a></p>
  <p> <a name="sect5.4"></a></p>
  <!--
  <h3>5.4<tt>&nbsp;&nbsp;</tt>Importing and Exporting Instance Declarations</h3>
  -->
  <h3>5.4<tt>&nbsp;&nbsp;</tt>インスタンス宣言のインポートとエクスポート</h3>

  <!--
  <p> Instance declarations cannot be explicitly named on import or export
   lists. All instances in scope within a module are <i>always </i>exported
   and any import brings <i>all</i> instances in from the imported module.
   Thus, an instance declaration is in scope if and only if a chain of
   <tt>import </tt>declarations leads to the module containing the instance
   declaration.</p>
  -->
  <p>インスタンス宣言はインポートあるいはエクスポートリストで明示的に
   名前を付与することはできない。ひとつのモジュール内の有効範囲にある
   インスタンスは<em>常に</em>すべてエクスポートされ、どのような
   インポートもインポートされたモジュールからの<em>すべての</em>
   インスタンスを持ち込む。したがって、インスタンス宣言は <tt>import</tt>
   宣言のチェーン当該のインスタンス宣言を含むモジュールに到達する場合かつ
   その場合に限り有効範囲内にある。</p>
  <!--
  <p> For example, <tt>import&nbsp;M()</tt> does not bring any new names in
   scope from module <tt>M</tt>, but does bring in any instances visible in
   <tt>M</tt>. A module whose only purpose is to provide instance
   declarations can have an empty export list. For example 
  -->
  <p> たとえば、<tt>import&nbsp;M()</tt> はモジュール <tt>M</tt> から
   あらたな名前はなにも持ち込むことはないが、<tt>M</tt> 内のすべての
   インスタンスは有効範囲に持ち込まれる。インスタンス宣言を供給すること
   のみを目的としたモジュールは、空のエクスポートリストを持つことができる。
   たとえば、
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;MyInstances()&nbsp;where<br />
   &nbsp;&nbsp;instance&nbsp;Show&nbsp;(a&nbsp;-&gt;&nbsp;b)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;show&nbsp;fn&nbsp;=&nbsp;"&lt;&lt;function&gt;&gt;"<br />
   &nbsp;&nbsp;instance&nbsp;Show&nbsp;(IO&nbsp;a)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;show&nbsp;io&nbsp;=&nbsp;"&lt;&lt;IO&nbsp;action&gt;&gt;"<br />
   <br /></tt></p>
   
  <p><a name="qualifiers"></a></p>
  <p> <a name="sect5.5"></a></p>
  <!--<h3>5.5<tt>&nbsp;&nbsp;</tt>Name Clashes and Closure</h3>-->
  <h3>5.5<tt>&nbsp;&nbsp;</tt>名前の衝突とクロージャ</h3>

  <p> <a name="sect5.5.1"></a></p>
  <!--<h4>5.5.1<tt>&nbsp;&nbsp;</tt>Qualified names</h4>-->
  <h4>5.5.1<tt>&nbsp;&nbsp;</tt>修飾された名前</h4>

  <!--
  <p> A <i>qualified name</i> is written as
   <i>modid</i><tt>.</tt><i>name</i> (Section <a
   href="lexemes.html#ids">2.4</a>). A qualified name is brought into
   scope:</p>
  -->
  <p><em>修飾された名前</em> は <I>modid</I><tt>.</tt><I>name</I> 
   のように書く(<a href="lexemes.html#ids">2.4</a> 節)。
   修飾された名前はスコープ内に持ち込まれる。</p>
  <ul>
   <!--
   <li><i>By a top level declaration. </i>A top-level declaration brings
    into scope both the unqualified <i>and </i>the qualified name of the
    entity being defined. Thus: 
   -->
   <li> <em>トップレベルでの宣言</em>。トップレベルの宣言は定義された
    エンティティの修飾されていない名前<em>と同時に</em>修飾された名前を
    有効範囲に持ち込む。したがって、
    <tt><br />
    <br />
    &nbsp;&nbsp;module&nbsp;M&nbsp;where<br />
    &nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;x&nbsp;=&nbsp;...<br />
    &nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;x&nbsp;=&nbsp;M.f&nbsp;x&nbsp;x<br />
    <br />
    </tt>
   <!--
    is legal. The <i>defining</i> occurrence must mention the
    <i>unqualified</i> name; therefore, it is illegal to write
   -->
    は正当である。<em>定義</em>は修飾されていない名前に対して行わなければな
    らない。それゆえ、以下のように書くのは不正である。
    <tt><br />
    <br />
    &nbsp;&nbsp;module&nbsp;M&nbsp;where<br />
    &nbsp;&nbsp;&nbsp;&nbsp;M.f&nbsp;x&nbsp;=&nbsp;...
    --&nbsp;不正<br />
    &nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;x&nbsp;=&nbsp;let&nbsp;M.y&nbsp;=&nbsp;x+1&nbsp;in&nbsp;...
    --&nbsp;不正<br />
    <br />
    </tt></li>
   <!--
   <li><i>By an </i><tt>import</tt><i> declaration.</i> An <tt>import</tt>
    declaration, whether <tt>qualified</tt> or not, always brings into
    scope the qualified name of the imported entity (Section <a
    href="modules.html#import">5.3</a>). This allows a qualified import to
    be replaced with an unqualified one without forcing changes in the
    references to the imported names.</li>
   -->
   <li> <em>ひとつの</em><tt>import</tt><em>宣言</em>。<tt>import</tt> 
    宣言は、<tt>qualified</tt> のあるなしにかかわらず、つねにインポート
    されたエンティティの修飾された名前を有効範囲に持ち込む
    (<a href="modules.html#import">5.3</a> 節)。これにより修飾された
    インポートは、インポートされた名前に対する参照の仕方を変更することを
    強制されることなく、修飾されていないインポートに置き換えることが
    可能である。</li>
  </ul>

  <p> <a name="sect5.5.2"></a></p>
  <!--<h4>5.5.2<tt>&nbsp;&nbsp;</tt>Name clashes</h4>-->
  <h4>5.5.2<tt>&nbsp;&nbsp;</tt>名前の衝突</h4>

  <!--
  <p> If a module contains a bound occurrence of a name, such as <tt>f</tt>
   or <tt>A.f</tt>, it must be possible unambiguously to resolve which
   entity is thereby referred to; that is, there must be only one binding
   for <tt>f</tt> or <tt>A.f</tt> respectively.</p>
  -->
  <p>あるモジュールが、<tt>f</tt> あるいは <tt>A.f</tt> という名前の束
   縛を含んでいれば、それは曖昧なところなく、どのエンティティを参照している
   か解決できるものでなければならない。すなわち、<tt>f</tt> あるいは
   <tt>A.f</tt> の束縛はそれぞれ唯一でなければならない。</p>
  <!--
  <p> It is <i>not</i> an error for there to exist names that cannot be so
   resolved, provided that the program does not mention those names. For
   example: 
  -->
  <p>解決できない名前があることは、そのプログラムがそれらの名前に言及しないか
   ぎりはエラー<em>ではない</em>。たとえば、
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;A&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;B<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;C<br />
   &nbsp;&nbsp;&nbsp;&nbsp;tup&nbsp;=&nbsp;(b,&nbsp;c,&nbsp;d,&nbsp;x)<br />
   &nbsp;&nbsp;<br />
   &nbsp;&nbsp;module&nbsp;B(&nbsp;d,&nbsp;b,&nbsp;x,&nbsp;y&nbsp;)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;D<br />
   &nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;...<br />
   &nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;...<br />
   &nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;...<br />
   &nbsp;&nbsp;<br />
   &nbsp;&nbsp;module&nbsp;C(&nbsp;d,&nbsp;c,&nbsp;x,&nbsp;y&nbsp;)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;D<br />
   &nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;...<br />
   &nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;...<br />
   &nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;...<br />
   <br />
   &nbsp;&nbsp;module&nbsp;D(&nbsp;d&nbsp;)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;...<br />
   <br />
   </tt>
  <!--
   Consider the definition of <tt>tup</tt>.</p>
  -->
   <tt>tup</tt> の定義について考えてみよ。
  <ul>
   <!--
   <li>The references to <tt>b</tt> and <tt>c </tt>can be unambiguously
    resolved to <tt>b</tt> declared in <tt>B</tt>, and <tt>c</tt> declared
    in <tt>C</tt> respectively.</li>
   -->
   <li><tt>b</tt> および <tt>c</tt> を参照することは、<tt>B</tt> 内で
    宣言されている <tt>b</tt> を参照することであり、<tt>C</tt> 内で宣言
    されている <tt>c</tt> を参照することであると、それぞれ曖昧なところなく
    解決できる。</li>
   <!--
   <li>The reference to <tt>d</tt> is unambiguously resolved to <tt>d</tt>
    declared in <tt>D</tt>. In this case the same entity is brought into
    scope by two routes (the import of <tt>B</tt> and the import of
    <tt>C</tt>), and can be referred to in <tt>A</tt> by the names
    <tt>d</tt>, <tt>B.d</tt>, and <tt>C.d</tt>.</li>
   -->
   <li><tt>d</tt> を参照することは、<tt>D</tt> 内で宣言された <tt>d</tt>
    を参照することであると曖昧なところなく解決できる。この場合、同じ
    エンティティが二つのルート(<tt>B</tt> のインポートと <tt>C</tt> 
    のインポート)で導入されており、これは、<tt>A</tt> 内で <tt>d</tt>、
    <tt>B.d</tt> および <tt>C.d</tt> で参照することができる。</li>
   <!--
   <li>The reference to <tt>x</tt> is ambiguous: it could mean <tt>x</tt>
    declared in <tt>B</tt>, or <tt>x</tt> declared in <tt>C</tt>. The
    ambiguity could be fixed by replacing the reference to <tt>x</tt> by
    <tt>B.x</tt> or <tt>C.x</tt>.</li>
   -->
   <li><tt>x</tt> への参照は曖昧である。<tt>B</tt> で宣言された <tt>x</tt>
    とも、<tt>C</tt> で宣言された <tt>x</tt> であるともとれるからである。
    この曖昧さは <tt>x</tt> を参照するのに <tt>B.x</tt> あるいは
    <tt>C.x</tt> に置き換えることで解消する。</li>
   <!--
   <li>There is no reference to <tt>y</tt>, so it is not erroneous that
    distinct entities called <tt>y</tt> are exported by both <tt>B</tt> and
    <tt>C</tt>. An error is only reported if <tt>y</tt> is actually
    mentioned.</li>
   -->
   <li><tt>y</tt> を参照しているところはないので、<tt>B</tt> と <tt>C</tt>
    の両方からエクスポートされている別々の <tt>y</tt> と呼ばれるエンティティ
    はエラーにならない。</li>
  </ul>

  <!--
  <p> The name occurring in a type signature or fixity declarations is
   always unqualified, and unambiguously refers to another declaration in
   the same declaration list (except that the fixity declaration for a
   class method can occur at top level --- Section <a
   href="decls.html#fixity">4.4.2</a>). For example, the following module
   is legal:
  -->
  <p> 型シグネチャ内あるいは結合性宣言内での名前は常に修飾されていないが、
   同じ宣言リスト(トップレベルにあらわれるクラスメソッドに対する結合性
   宣言は例外 -- <a href="decls.html#fixity">4.4.2</a> 節)内の他の宣言を
   曖昧なところなく参照する。たとえば、以下のモジュールは正当なものである。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;F&nbsp;where<br />
   <br />
   &nbsp;&nbsp;&nbsp;&nbsp;sin&nbsp;::&nbsp;Float&nbsp;-&gt;&nbsp;Float<br />
   &nbsp;&nbsp;&nbsp;&nbsp;sin&nbsp;x&nbsp;=&nbsp;(x::Float)<br />
   <br />
   &nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;x&nbsp;=&nbsp;Prelude.sin&nbsp;(F.sin&nbsp;x)<br />
   <br />
   </tt>
  <!--
   The local declaration for <tt>sin</tt> is legal, even though the
   Prelude function <tt>sin</tt> is implicitly in scope. The references to
   <tt>Prelude.sin</tt> and <tt>F.sin</tt> must both be qualified to make
   it unambiguous which <tt>sin</tt> is meant. However, the unqualified
   name <tt>sin</tt> in the type signature in the first line of <tt>F</tt>
   unambiguously refers to the local declaration for <tt>sin</tt>.</p>
  -->
   たとえ、プレリュード関数 <tt>sin</tt> が暗黙のうちにスコープ内に
   あっても、局所的な <tt>sin</tt> の宣言が正当なものである。
   <tt>Prelude.sin</tt> と <tt>F.sin</tt> はともに、
   どちらの <tt>sin</tt> かが曖昧にならないように、修飾されている必要が
   ある。しかしながら、<tt>F</tt> の最初の行の型シグネチャ中の
   修飾されていない <tt>sin</tt> は曖昧なとろなく、<tt>sin</tt> の
   局所宣言を参照している。
   </p>

  <p> <a name="closure"></a></p>
  <p> <a name="sect5.5.3"></a></p>

  <!--<h4>5.5.3<tt>&nbsp;&nbsp;</tt>Closure</h4>-->
  <h4>5.5.3<tt>&nbsp;&nbsp;</tt>クロージャ</h4>

  <!--
  <p> Every module in a Haskell program must be <i>closed</i>. That is,
   every name explicitly mentioned by the source code must be either
   defined locally or imported from another module. However, entities that
   the compiler requires for type checking or other compile time analysis
   need not be imported if they are not mentioned by name. The Haskell
   compilation system is responsible for finding any information needed for
   compilation without the help of the programmer. That is, the import of a
   variable <tt>x</tt> does not require that the datatypes and classes in
   the signature of <tt>x</tt> be brought into the module along with
   <tt>x</tt> unless these entities are referenced by name in the user
   program. The Haskell system silently imports any information that must
   accompany an entity for type checking or any other purposes. Such
   entities need not even be explicitly exported: the following program is
   valid even though <tt>T</tt> does not escape <tt>M1</tt>: 
  -->
  <p>ひとつの Haskell プログラム内のすべてのモジュールは<em>閉じたもの
   </em>でなければならない。すなわち、ソースコードによって明示的に言及さ
   れたすべての名前は局所的に定義されているか、あるいは、別のモジュール
   からインポートされたものであるかどちらかでなくてはならない。型チェッ
   クあるいは別のコンパイル時解析のためにコンパイラが必要とするエンティ
   ティは、名前により言及されなければインポートされている必要はない。
   Haskell のコンパイルシステムはコンパイルに必要な全ての情報をプログラ
   マの助けなしに見つける責任がある。すなわち、ある変数 <tt>x</tt> のイ
   ンポートすることで、これらのエンティティがユーザのプログラムのなかで
   名前で参照されないうちに、<tt>x</tt> のシグネチャ中のデータ型およびク
   ラスが当該のモジュールに <tt>x</tt> と同時に持ち込まれることを要求し
   てはいけない。Haskell システムは型チェックやその他の目的のためにエン
   ティティに付随するはずのすべての情報を黙ってインポートしなければなら
   ない。このようなエンティティは明示的にエクスポートされている必要もな
   い。以下のプログラムは、<tt>T</tt> が <tt>M1</tt> をエスケープしてい
   るわけではないのにもかかわらず正当なプログラムである。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;M1(x)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;T&nbsp;=&nbsp;T<br />
   &nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;T<br />
   &nbsp;&nbsp;<br />
   &nbsp;&nbsp;module&nbsp;M2&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;M1(x)<br />
   &nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;x<br />
   <br />
   </tt>
  <!--
   In this example, there is no way to supply an explicit type
   signature for <tt>y</tt> since <tt>T</tt> is not in scope. Whether or
   not <tt>T</tt> is explicitly exported, module <tt>M2</tt> knows enough
   about <tt>T</tt> to correctly type check the program.</p>
  -->
   この例では、<tt>y</tt> に対する明示的な型シグネチャを与える方法はない。
   それは <tt>T</tt> が有効範囲にないからである。<tt>T</tt> が明示的にエ
   クスポートされてようとなかろうと、モジュール <tt>M2</tt> はプログラム
   の型チェックを正しく行うために <tt>T</tt> について十分知っている。</p>
  <!--
  <p> The type of an exported entity is unaffected by non-exported type
   synonyms. For example, in
  -->
  <p>エクスポートされたあるエンティティの型はエクスポートされていない型
   シノニムには影響されない。たとえば、 
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;M(x)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;T&nbsp;=&nbsp;Int<br />
   &nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;::&nbsp;T<br />
   &nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;1<br />
   <br />
   </tt>
  <!--
   the type of <tt>x</tt> is both <tt>T</tt> and <tt>Int</tt>; these
   are interchangeable even when <tt>T</tt> is not in scope. That is, the
   definition of <tt>T</tt> is available to any module that encounters it
   whether or not the name <tt>T</tt> is in scope. The only reason to
   export <tt>T</tt> is to allow other modules to refer it by name; the
   type checker finds the definition of <tt>T</tt> if needed whether or not
   it is exported.</p>
  -->
   のなかで、<tt>x</tt> の型は <tt>T</tt> でかつ <tt>Int</tt> である。こ
   れらは <tt>T</tt> が有効範囲になくとも交換可能である。すなわち、
   <tt>T</tt> の定義はその名前 <tt>T</tt> が有効範囲にあるなしにかかわら
   ず、それにあたったすべてのモジュールに対して利用可能である。
   <tt>T</tt> をエクスポートする唯一の理由は他のモジュールがそれを名前で
   参照することを可能にするためである。型チェッカーはそれがエクスポート
   さていようがいまいが、必要なら <tt>T</tt> の定義を見つけだす。</p>

  <p> <a name="standard-prelude"></a></p>
  <p> <a name="sect5.6"></a></p>

  <!--<h3>5.6<tt>&nbsp;&nbsp;</tt>Standard Prelude</h3>-->
  <h3>5.6<tt>&nbsp;&nbsp;</tt>標準プレリュード</h3>

  <!--
  <p>Many of the features of Haskell are defined in Haskell itself as a
   library of standard datatypes, classes, and functions, called the
   "Standard Prelude." In Haskell , the Prelude is contained in the module
   <tt>Prelude</tt>. There are also many predefined library modules, which
   provide less frequently used functions and types. For example, complex
   numberss, arrays, and most of the input/output are all part of the
   standard libraries. These are defined in Part II Separating libraries
   from the Prelude has the advantage of reducing the size and complexity
   of the Prelude, allowing it to be more easily assimilated, and
   increasing the space of useful names available to the programmer.</p>
  -->
  <p>Haskell の特徴の多くは、「標準プレリュード」と呼ばれる、標準データ
   型、標準クラスおよび標準関数のライブラリとして、Haskell 自身で定義さ
   れている。Haskell ではこのプレリュードは、モジュール <tt>Prelude</tt>
   に含まれている。おおくの定義済みのライブラリモジュールもあり、これら
   には、利用頻度のより少ない関数や型を供給している。たとえば、配列、表、
   入出力のほとんどはどれも標準ライブラリにある。これらは別のドキュメン
   ト Haskell Library Report [<a href="haskell.html#$libraries">8</a>]
   の中で定義されている。ライブラリをプレリュードとは別することはでサイ
   ズを削りプレリュードが複雑になるのを軽減するという利点がある。そうす
   ることで簡単に同化することができ、プログラマが利用できる有用な名前空
   間を増すことができる。</p> 
  <!--
  <p> Prelude and library modules differ from other modules in that their
   semantics (but not their implementation) are a fixed part of the Haskell
   language definition. This means, for example, that a compiler may
   optimize calls to functions in the Prelude without consulting the source
   code of the Prelude.</p>
  -->
  <p>プレリュードとライブラリモジュールが他のモジュールと異るのは、セマ
   ンティクス(実装ではない)として Haskell の言語定義の固定された部分であ
   るという点である。その意味は、例えば、コンパイラがこのプレリュードの
   ソースコードを参考にすることなくプレリュード中の関数の呼出しを最適化
   してもよいということである。</p> 

  <p> <a name="sect5.6.1"></a></p>
  <!--<h4>5.6.1<tt>&nbsp;&nbsp;</tt>The <tt>Prelude</tt> Module</h4>-->
  <h4>5.6.1<tt>&nbsp;&nbsp;</tt> <tt>Prelude</tt> モジュール</h4>

  <!--
  <p> The <tt>Prelude</tt> module is imported automatically into all
   modules as if by the statement `<tt>import&nbsp;Prelude</tt>', if and
   only if it is not imported with an explicit <tt>import</tt> declaration.
   This provision for explicit import allows entities defined in the
   Prelude to be selectively imported, just like those from any other
   module.</p>
  -->
  <p><tt>Prelude</tt> モジュールは`<tt>import&nbsp;Prelude</tt>'があるか
   のようにすべてのモジュールに自動的にインポートされるが、これは、明示
   的に <tt>import</tt>宣言によってインポートされない場合に限る。明示的
   なインポートに対するこの規約はプレリュード中で定義されたエンティティ
   を、他のモジュールからインポートする場合と同様に、選択的にインポート
   することを可能にします。</p>
  <!--
  <p> The semantics of the entities in <tt>Prelude</tt> is specified by a
   reference implementation of <tt>Prelude</tt> written in Haskell , given
   in Chapter <a href="standard-prelude.html#stdprelude">8</a>. Some
   datatypes (such as <tt>Int</tt>) and functions (such as <tt>Int</tt>
   addition) cannot be specified directly in Haskell . Since the treatment
   of such entities depends on the implementation, they are not formally
   defined in Chapter <a href="standard-prelude.html#stdprelude">8</a>. The
   implementation of <tt>Prelude</tt> is also incomplete in its treatment
   of tuples: there should be an infinite family of tuples and their
   instance declarations, but the implementation only gives a scheme.</p>
  -->
  <p><tt>Prelude</tt> 内のエンティティのセマンティクスは、
   <a href="standard-prelude.html#stdprelude">8</a> 章で与えられている
   Haskell で書かれた <tt>Prelude</tt> の実装によって指定される。いくつ
   かの型( <tt>Int</tt> など)および、いくつかの関数(たとえば、
   <tt>Int</tt> の加算など)については直接 Haskell で指定することはできな
   い。このようなエンティティの扱いは実装に依存するので、
   この <a href="standard-prelude.html#stdprelude">8</a> 章では形式的に
   定義しない。<tt>Prelude</tt> はタプルの扱いについても完全なもの
   ではない。タプルの族およびそのインスタンス宣言は無限にあるはずだが、
   実装はひとつの図式をしめすだけである。</p> 
  <!--
  <p> Chapter <a href="standard-prelude.html#stdprelude">8</a> defines the
   module <tt>Prelude</tt> using several other modules:
   <tt>PreludeList</tt>, <tt>PreludeIO</tt>, and so on. These modules are
   <i>not</i> part of Haskell 98, and they cannot be imported separately.
   They are simply there to help explain the structure of the
   <tt>Prelude</tt> module; they should be considered part of its
   implementation, not part of the language definition. </p>
  -->
  <p><a href="standard-prelude.html#stdprelude">8</a> 章は
   <tt>Prelude</tt> モジュールを <tt>PreludeList</tt>、
   <tt>PreludeIO</tt> などのいくつかの他のモジュールを用いて定義している。
   これらのモジュールは、Haskell 98 の一部では<em>なく</em>、一部だけ別々
   にインポートすることはできない。<tt>Prelude</tt> モジュールの構造を説
   明するのに役立つように存在しているにすぎない。言語定義の一部ではなく、
   実装の一部であると考えられるべきものである。</p>

  <p><a name="std-prel-shadowing"></a></p>
  <p><a name="sect5.6.2"></a></p>

  <h4>5.6.2<tt>&nbsp;&nbsp;</tt>プレリュード名の隠蔽</h4>

  <!--
  <p> The rules about the Prelude have been cast so that it is possible to
   use Prelude names for nonstandard purposes; however, every module that
   does so must have an <tt>import</tt> declaration that makes this
   nonstandard usage explicit. For example: 
  <p> プレリュードに関するこの規則は、プレリュードの名前を非標準的な
   目的のために使用できるように設けられている。しかし、そのような使い方
   をするモジュールはどれも、その非標準的な使い方を明示する
   <tt>import</tt> 宣言を持たなければならない。たとえば、
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;A(&nbsp;null,&nbsp;nonNull&nbsp;)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;Prelude&nbsp;hiding(&nbsp;null&nbsp;)&nbsp;<br />
   &nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;nonNull&nbsp;::&nbsp;Int&nbsp;-&gt;&nbsp;Bool<br />
   &nbsp;&nbsp;&nbsp;&nbsp;null&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;x&nbsp;==&nbsp;0<br />
   &nbsp;&nbsp;&nbsp;&nbsp;nonNull&nbsp;x&nbsp;=&nbsp;not&nbsp;(null&nbsp;x)<br />
   <br />
   </tt>
  <!--
   Module <tt>A</tt> redefines <tt>null</tt>, and contains an
   unqualified reference to <tt>null </tt>on the right hand side of
   <tt>nonNull</tt>. The latter would be ambiguous without the
   <tt>hiding(null)</tt> on the <tt>import&nbsp;Prelude</tt> statement.
   Every module that imports <tt>A</tt> unqualified, and then makes an
   unqualified reference to <tt>null</tt> must also resolve the ambiguous
   use of <tt>null</tt> just as <tt>A</tt> does. Thus there is little
   danger of accidentally shadowing Prelude names.</p>
  -->
   モジュール <tt>A</tt> は <tt>null</tt> を再定義しているが、このことを
   <tt>null</tt> を除外して <tt>Prelude</tt> をインポートすることにより
   表示しなければならない。さらに、<tt>A</tt> は <tt>null</tt> をエクス
   ポートするが、<tt>A</tt> から修飾子なしに <tt>null</tt> をインポート
   するモジュールはどれも、<tt>Prelude</tt> からの <tt>null</tt> を隠蔽
   し、<tt>A</tt>からのだけをインポートしなければならない。したがって、
   プレリュードの名前が意図せず隠蔽されてしまうことはほとんどない。</p>
  <!--
  <p> It is possible to construct and use a different module to serve in
   place of the Prelude. Other than the fact that it is implicitly
   imported, the Prelude is an ordinary Haskell module; it is special only
   in that some objects in the Prelude are referenced by special syntactic
   constructs. Redefining names used by the Prelude does not affect the
   meaning of these special constructs. For example, in 
  -->
  <p> プレリュードをその場で提供するために別のモジュールを使うあるいは
   構築することが可能である。プレリュードは、それが暗黙のうちにインポー
   トされるということを除けば、普通の他の Haskell のモジュールと同じであ
   る。いくつかのプレリュード中のオブジェクトで特殊な構文構成で参照さ
   れということのみが特別あつかいである。プレリュードによる名前の再定義
   はこれらの特別な構文構成の意味には影響しない。たとえば、
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;B&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;Prelude()<br />
   &nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;MyPrelude<br />
   &nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;x&nbsp;=&nbsp;(x,x)<br />
   &nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;x&nbsp;=&nbsp;(,)&nbsp;x&nbsp;x<br />
   &nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;x&nbsp;=&nbsp;[x]&nbsp;++&nbsp;[]<br />
   <br />
   </tt>
  <!--
   the explicit <tt>import&nbsp;Prelude()</tt> declaration prevents
   the automatic import of <tt>Prelude</tt>, while the declaration
   <tt>import&nbsp;MyPrelude</tt> brings the non-standard prelude into
   scope. The special syntax for tuples (such as <tt>(x,x)</tt> and
   <tt>(,)</tt>) and lists (such as <tt>[x]</tt> and <tt>[]</tt>) continues
   to refer to the tuples and lists defined by the standard
   <tt>Prelude</tt>; there is no way to redefine the meaning of
   <tt>[x]</tt>, for example, in terms of a different implementation of
   lists. On the other hand, the use of <tt>++</tt> is not special syntax,
   so it refers to <tt>++</tt> imported from <tt>MyPrelude</tt>.</p>
  -->
   明示的な <tt>import&nbsp;qualified&nbsp;Prelude</tt> 宣言は、
   <tt>Prelude</tt> からの自動的なインポートを妨げる。一方、
   <tt>import&nbsp;MyPrelude</tt> は非標準のプレリュードをスコープに持ち
   込む。タプルの特別な構文(<tt> (x,x) </tt>や<tt> (,) </tt>など)や
   リストの特別な構文(<tt> [x] </tt>や<tt> [] </tt>など)は引き続き
   標準<tt>Prelude</tt>によって定義されたタプルやリストを参照する。
   たとえば、リストの別のインプリメンテーションという意味では、
   <tt>[x]</tt> を再定義する方法はない。しかし、一方では、<tt>++</tt> は
   特別な構文ではなく、<tt>MyPrelude</tt> からインポートされた
   <tt>++</tt> を参照することになる</p>
  <!--
  <p> It is not possible, however, to hide <tt>instance</tt> declarations
   in the <tt>Prelude</tt>. For example, one cannot define a new instance
   for <tt>Show&nbsp;Char</tt>.</p>
  -->
  <p>しかし、<tt>Prelude</tt> 中の <tt>instance</tt> 宣言を隠蔽すること
   はできない。たとえば、 <tt>Show&nbsp;Char</tt> に対して新しいインスタ
   ンスを定義することはできない。</p> 

  <p> <a name="sect5.7"></a></p>
  <!--<h3>5.7<tt>&nbsp;&nbsp;</tt>Separate Compilation</h3>-->
  <h3>5.7<tt>&nbsp;&nbsp;</tt>分割コンパイル</h3>

  <!--
  <p>Depending on the Haskell implementation used, separate compilation of
   mutually recursive modules may require that imported modules contain
   additional information so that they may be referenced before they are
   compiled. Explicit type signatures for all exported values may be
   necessary to deal with mutual recursion. The precise details of separate
   compilation are not defined by this report. </p>
  -->
  <p> どの Haskell の実装を用いるかによっては、相互再帰的なモジュールの
   分割コンパイルは、インポートされたモジュールは、それがコンパイルされ
   る前に参照されてもいいように付加的な情報が必要となる。すべてのエクス
   ポートされた値の明示的な型シグネチャが相互再帰を処理するために必要と
   なる。分割コンパイルの正確な詳細はこのレポートでは定義しない。</p> 

  <p> <a name="abstract-types"></a></p>
  <p> <a name="sect5.8"></a></p>
  <!--<h3>5.8<tt>&nbsp;&nbsp;</tt>Abstract Datatypes</h3>-->
  <h3>5.8<tt>&nbsp;&nbsp;</tt>抽象データ型</h3>

  <!--
  <p> The ability to export a datatype without its constructors allows the
   construction of abstract datatypes (ADTs). For example, an ADT for
   stacks could be defined as: 
  -->
  <p>構成子なしでデータ型をエクスポートできるということは、抽象データ型
   (ADT)の構成を可能にする。たとえば、スタックに対応する ADT は以下のよ
   うに定義することができる。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;Stack(&nbsp;StkType,&nbsp;push,&nbsp;pop,&nbsp;empty&nbsp;)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;StkType&nbsp;a&nbsp;=&nbsp;EmptyStk&nbsp;|&nbsp;Stk&nbsp;a&nbsp;(StkType&nbsp;a)<br />
   &nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;x&nbsp;s&nbsp;=&nbsp;Stk&nbsp;x&nbsp;s<br />
   &nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;(Stk&nbsp;_&nbsp;s)&nbsp;=&nbsp;s<br />
   &nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;=&nbsp;EmptyStk<br />
   <br />
   </tt>
  <!--
   Modules importing <tt>Stack</tt> cannot construct values of type
   <tt>StkType </tt>because they do not have access to the constructors of
   the type. Instead, they must use <tt>push</tt>, <tt>pop</tt>, and
   <tt>empty</tt> to construct such values.</p>
  -->
   <tt>Stack</tt> をインポートするモジュールは <tt>StkType</tt> 型の値を
   構成することはできない、それはこの型の構成子にアクセスすることができ
   ないからである。</p>
  <!--
  <p> It is also possible to build an ADT on top of an existing type by
   using a <tt>newtype</tt> declaration. For example, stacks can be defined
   with lists: 
  -->
  <p><tt>newtype</tt> 宣言を用いて、既存の型のうえに ADT を構築すること
   も可能である。たとえば、スタックはリストを使って定義可能である。
   <tt><br />
   <br />
   &nbsp;&nbsp;module&nbsp;Stack(&nbsp;StkType,&nbsp;push,&nbsp;pop,&nbsp;empty&nbsp;)&nbsp;where<br />
   &nbsp;&nbsp;&nbsp;&nbsp;newtype&nbsp;StkType&nbsp;a&nbsp;=&nbsp;Stk&nbsp;[a]<br />
   &nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;x&nbsp;(Stk&nbsp;s)&nbsp;=&nbsp;Stk&nbsp;(x:s)<br />
   &nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;(Stk&nbsp;(_:s))&nbsp;=&nbsp;Stk&nbsp;s<br />
   &nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;=&nbsp;Stk&nbsp;[]<br />
   </tt></p>
  <hr />
  <p><i>The Haskell 98 Report</i><br />
   <a href="index.html">top</a> | <a href="decls.html">back</a> | <a
   href="basic.html">next</a> | <a href="index98.html">contents</a> | <a
   href="prelude-index.html">function index</a> <br />
   <font size="2">December 2002</font></p>
  <p></p>
 </body>
</html>
